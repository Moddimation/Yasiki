<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File GXBump.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-gxbumpc">File GXBump.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_b80c028b3e970eff7f2a07684ffcf104/"><strong>gx</strong></a> <strong>&gt;</strong> <a href="../_g_x_bump_8c/"><strong>GXBump.c</strong></a></p>
<p><a href="../_g_x_bump_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/gx.h&gt;
#include &lt;dolphin/os.h&gt;
#include &lt;macros.h&gt;

#include &quot;dolphin/gx/GXEnum.h&quot;
#include &quot;GXPrivate.h&quot;

#if DEBUG
#define GX_WRITE_SOME_REG5(a, b)                                                               \
    do {                                                                                       \
        GX_WRITE_U8 (a);                                                                       \
        GX_WRITE_U32 (b);                                                                      \
        __gxVerif-&gt;rasRegs[(b &gt;&gt; 24) &amp; 0xFF] = b;                                              \
    }                                                                                          \
    while (0)
#else
#define GX_WRITE_SOME_REG5(a, b)                                                               \
    do {                                                                                       \
        GX_WRITE_U8 (a);                                                                       \
        GX_WRITE_U32 (b);                                                                      \
    }                                                                                          \
    while (0)
#endif
void
GXSetTevIndirect (GXTevStageID     tev_stage,
                  GXIndTexStageID  ind_stage,
                  GXIndTexFormat   format,
                  GXIndTexBiasSel  bias_sel,
                  GXIndTexMtxID    matrix_sel,
                  GXIndTexWrap     wrap_s,
                  GXIndTexWrap     wrap_t,
                  GXBool           add_prev,
                  GXBool           utc_lod,
                  GXIndTexAlphaSel alpha_sel)
{
    u32 reg;

    CHECK_GXBEGIN (0x7F, &quot;GXInitIndTexture&quot;);
    reg = 0;
    SET_REG_FIELD (0x81, reg, 2, 0, ind_stage);
    SET_REG_FIELD (0x82, reg, 2, 2, format);
    SET_REG_FIELD (0x83, reg, 3, 4, bias_sel);
    SET_REG_FIELD (0x84, reg, 2, 7, alpha_sel);
    SET_REG_FIELD (0x85, reg, 4, 9, matrix_sel);
    SET_REG_FIELD (0x86, reg, 3, 13, wrap_s);
    SET_REG_FIELD (0x87, reg, 3, 16, wrap_t);
    SET_REG_FIELD (0x88, reg, 1, 19, utc_lod);
    SET_REG_FIELD (0x89, reg, 1, 20, add_prev);
    SET_REG_FIELD (0x8A, reg, 8, 24, tev_stage + 16);
    GX_WRITE_SOME_REG5 (0x61, reg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetIndTexMtx (GXIndTexMtxID mtx_id, f32 offset[2][3], s8 scale_exp)
{
    s32 mtx[6];
    u32 reg;
    u32 id;

    CHECK_GXBEGIN (0xA7, &quot;GXSetIndTexMtx&quot;);

    switch (mtx_id)
    {
        case GX_ITM_0:
        case GX_ITM_1:
        case GX_ITM_2:
            id = (u32)mtx_id - 1;
            break;
        case GX_ITM_S0:
        case GX_ITM_S1:
        case GX_ITM_S2:
            id = (u32)mtx_id - 5;
            break;
        case GX_ITM_T0:
        case GX_ITM_T1:
        case GX_ITM_T2:
            id = (u32)mtx_id - 9;
            break;
        default:
            id = 0;
            break;
    }

    mtx[0]     = (int)(1024.0f * offset[0][0]) &amp; 0x7FF;
    mtx[1]     = (int)(1024.0f * offset[1][0]) &amp; 0x7FF;
    scale_exp += 0x11;
    reg        = 0;
    SET_REG_FIELD (0xBD, reg, 11, 0, mtx[0]);
    SET_REG_FIELD (0xBE, reg, 11, 11, mtx[1]);
    SET_REG_FIELD (0xBF, reg, 2, 22, scale_exp &amp; 3);
    SET_REG_FIELD (0xC0, reg, 8, 24, id * 3 + 6);
    GX_WRITE_SOME_REG5 (0x61, reg);

    mtx[2] = (int)(1024.0f * offset[0][1]) &amp; 0x7FF;
    mtx[3] = (int)(1024.0f * offset[1][1]) &amp; 0x7FF;
    reg    = 0;
    SET_REG_FIELD (0xC6, reg, 11, 0, mtx[2]);
    SET_REG_FIELD (0xC7, reg, 11, 11, mtx[3]);
    SET_REG_FIELD (0xC8, reg, 2, 22, (scale_exp &gt;&gt; 2) &amp; 3);
    SET_REG_FIELD (0xC9, reg, 8, 24, id * 3 + 7);
    GX_WRITE_SOME_REG5 (0x61, reg);

    mtx[4] = (int)(1024.0f * offset[0][2]) &amp; 0x7FF;
    mtx[5] = (int)(1024.0f * offset[1][2]) &amp; 0x7FF;
    reg    = 0;
    SET_REG_FIELD (0xCF, reg, 11, 0, mtx[4]);
    SET_REG_FIELD (0xD0, reg, 11, 11, mtx[5]);
    SET_REG_FIELD (0xD1, reg, 2, 22, (scale_exp &gt;&gt; 4) &amp; 3);
    SET_REG_FIELD (0xD2, reg, 8, 24, id * 3 + 8);
    GX_WRITE_SOME_REG5 (0x61, reg);

    __GXData-&gt;bpSent = 1;
}

void
GXSetIndTexCoordScale (GXIndTexStageID ind_state, GXIndTexScale scale_s, GXIndTexScale scale_t)
{
    CHECK_GXBEGIN (0xE6, &quot;GXSetIndTexScale&quot;);

    switch (ind_state)
    {
        case GX_INDTEXSTAGE0:
            SET_REG_FIELD (0xEA, __GXData-&gt;IndTexScale0, 4, 0, scale_s);
            SET_REG_FIELD (0xEB, __GXData-&gt;IndTexScale0, 4, 4, scale_t);
            SET_REG_FIELD (0xEC, __GXData-&gt;IndTexScale0, 8, 24, 0x25);
            GX_WRITE_SOME_REG5 (0x61, __GXData-&gt;IndTexScale0);
            break;
        case GX_INDTEXSTAGE1:
            SET_REG_FIELD (0xF0, __GXData-&gt;IndTexScale0, 4, 8, scale_s);
            SET_REG_FIELD (0xF1, __GXData-&gt;IndTexScale0, 4, 12, scale_t);
            SET_REG_FIELD (0xF2, __GXData-&gt;IndTexScale0, 8, 24, 0x25);
            GX_WRITE_SOME_REG5 (0x61, __GXData-&gt;IndTexScale0);
            break;
        case GX_INDTEXSTAGE2:
            SET_REG_FIELD (0xF6, __GXData-&gt;IndTexScale1, 4, 0, scale_s);
            SET_REG_FIELD (0xF7, __GXData-&gt;IndTexScale1, 4, 4, scale_t);
            SET_REG_FIELD (0xF8, __GXData-&gt;IndTexScale1, 8, 24, 0x26);
            GX_WRITE_SOME_REG5 (0x61, __GXData-&gt;IndTexScale1);
            break;
        case GX_INDTEXSTAGE3:
            SET_REG_FIELD (0xFC, __GXData-&gt;IndTexScale1, 4, 8, scale_s);
            SET_REG_FIELD (0xFD, __GXData-&gt;IndTexScale1, 4, 12, scale_t);
            SET_REG_FIELD (0xFE, __GXData-&gt;IndTexScale1, 8, 24, 0x26);
            GX_WRITE_SOME_REG5 (0x61, __GXData-&gt;IndTexScale1);
            break;
        default:
            ASSERTMSGLINE (0x102, 0, &quot;GXSetIndTexCoordScale: Invalid Indirect Stage Id&quot;);
            break;
    }
    __GXData-&gt;bpSent = 1;
}

void
GXSetIndTexOrder (GXIndTexStageID ind_stage, GXTexCoordID tex_coord, GXTexMapID tex_map)
{
    CHECK_GXBEGIN (0x11B, &quot;GXSetIndTexOrder&quot;);

    ASSERTMSGLINE (0x11D, tex_map &lt; 8, &quot;GXSetIndTexOrder: Invalid direct texture Id&quot;);
    ASSERTMSGLINE (0x11E, tex_coord &lt; 8, &quot;GXSetIndTexOrder: Invalid texture coord&quot;);

    switch (ind_stage)
    {
        case GX_INDTEXSTAGE0:
            SET_REG_FIELD (0x122, __GXData-&gt;iref, 3, 0, tex_map);
            SET_REG_FIELD (0x123, __GXData-&gt;iref, 3, 3, tex_coord);
            break;
        case GX_INDTEXSTAGE1:
            SET_REG_FIELD (0x126, __GXData-&gt;iref, 3, 6, tex_map);
            SET_REG_FIELD (0x127, __GXData-&gt;iref, 3, 9, tex_coord);
            break;
        case GX_INDTEXSTAGE2:
            SET_REG_FIELD (0x12A, __GXData-&gt;iref, 3, 12, tex_map);
            SET_REG_FIELD (0x12B, __GXData-&gt;iref, 3, 15, tex_coord);
            break;
        case GX_INDTEXSTAGE3:
            SET_REG_FIELD (0x12E, __GXData-&gt;iref, 3, 18, tex_map);
            SET_REG_FIELD (0x12F, __GXData-&gt;iref, 3, 21, tex_coord);
            break;
        default:
            ASSERTMSGLINE (0x132, 0, &quot;GXSetIndTexOrder: Invalid Indirect Stage Id&quot;);
            break;
    }
    GX_WRITE_SOME_REG5 (0x61, __GXData-&gt;iref);
    __GXData-&gt;dirtyState |= 3;
    __GXData-&gt;bpSent      = 1;
}

void
GXSetNumIndStages (u8 nIndStages)
{
    CHECK_GXBEGIN (0x144, &quot;GXSetNumIndStages&quot;);
    ASSERTMSGLINE (0x146,
                   nIndStages &lt;= 4,
                   &quot;GXSetNumIndStages: Exceeds max. number of indirect texture stages&quot;);
    SET_REG_FIELD (0x147, __GXData-&gt;genMode, 3, 16, nIndStages);
    __GXData-&gt;dirtyState |= 6;
}

void
GXSetTevDirect (GXTevStageID tev_stage)
{
    CHECK_GXBEGIN (0x158, &quot;GXSetTevDirect&quot;);
    GXSetTevIndirect (tev_stage,
                      GX_INDTEXSTAGE0,
                      GX_ITF_8,
                      GX_ITB_NONE,
                      GX_ITM_OFF,
                      GX_ITW_OFF,
                      GX_ITW_OFF,
                      GX_FALSE,
                      GX_FALSE,
                      GX_ITBA_OFF);
}

void
GXSetTevIndWarp (GXTevStageID    tev_stage,
                 GXIndTexStageID ind_stage,
                 u8              signed_offset,
                 u8              replace_mode,
                 GXIndTexMtxID   matrix_sel)
{
    GXIndTexWrap wrap = (replace_mode != 0) ? GX_ITW_0 : GX_ITW_OFF;

    CHECK_GXBEGIN (0x16E, &quot;GXSetTevIndWarp&quot;);
    GXSetTevIndirect (tev_stage,
                      ind_stage,
                      GX_ITF_8,
                      (signed_offset != 0) ? GX_ITB_STU : GX_ITB_NONE,
                      matrix_sel,
                      wrap,
                      wrap,
                      GX_FALSE,
                      GX_FALSE,
                      GX_ITBA_OFF);
}

void
GXSetTevIndTile (GXTevStageID     tev_stage,
                 GXIndTexStageID  ind_stage,
                 u16              tilesize_s,
                 u16              tilesize_t,
                 u16              tilespacing_s,
                 u16              tilespacing_t,
                 GXIndTexFormat   format,
                 GXIndTexMtxID    matrix_sel,
                 GXIndTexBiasSel  bias_sel,
                 GXIndTexAlphaSel alpha_sel)
{
    GXIndTexWrap wrap_s;
    GXIndTexWrap wrap_t;
    f32          mtx[2][3];

    CHECK_GXBEGIN (0x190, &quot;GXSetTevIndTile&quot;);
    ASSERTMSGLINE (0x191, tev_stage &lt; 16, &quot;GXSetTevIndTile: Invalid tev stage id&quot;);
    ASSERTMSGLINE (0x192, ind_stage &lt; 4, &quot;GXSetTevIndTile: Invalid indirect stage id&quot;);
    switch (tilesize_s)
    {
        case 256:
            wrap_s = GX_ITW_256;
            break;
        case 128:
            wrap_s = GX_ITW_128;
            break;
        case 64:
            wrap_s = GX_ITW_64;
            break;
        case 32:
            wrap_s = GX_ITW_32;
            break;
        case 16:
            wrap_s = GX_ITW_16;
            break;
        default:
            ASSERTMSGLINE (0x19B, 0, &quot;GXSetTevIndTile: Invalid tilesize for S coordinate&quot;);
            wrap_s = GX_ITW_OFF;
            break;
    }
    switch (tilesize_t)
    {
        case 256:
            wrap_t = GX_ITW_256;
            break;
        case 128:
            wrap_t = GX_ITW_128;
            break;
        case 64:
            wrap_t = GX_ITW_64;
            break;
        case 32:
            wrap_t = GX_ITW_32;
            break;
        case 16:
            wrap_t = GX_ITW_16;
            break;
        default:
            ASSERTMSGLINE (0x1A7, 0, &quot;GXSetTevIndTile: Invalid tilesize for T coordinate&quot;);
            wrap_t = GX_ITW_OFF;
            break;
    }
    mtx[0][0] = tilespacing_s / 1024.0f;
    mtx[0][1] = mtx[0][2] = 0.0f;
    mtx[1][1]             = tilespacing_t / 1024.0f;
    mtx[1][0] = mtx[1][2] = 0.0f;
    GXSetIndTexMtx (matrix_sel, mtx, 0xA);
    GXSetTevIndirect (tev_stage,
                      ind_stage,
                      format,
                      bias_sel,
                      matrix_sel,
                      wrap_s,
                      wrap_t,
                      0U,
                      1,
                      alpha_sel);
}

void
GXSetTevIndBumpST (GXTevStageID tev_stage, GXIndTexStageID ind_stage, GXIndTexMtxID matrix_sel)
{
    GXIndTexMtxID sm;
    GXIndTexMtxID tm;

    CHECK_GXBEGIN (0x1CF, &quot;GXSetTevIndBumpST&quot;);
    switch (matrix_sel)
    {
        case GX_ITM_0:
            sm = GX_ITM_S0;
            tm = GX_ITM_T0;
            break;
        case GX_ITM_1:
            sm = GX_ITM_S1;
            tm = GX_ITM_T1;
            break;
        case GX_ITM_2:
            sm = GX_ITM_S2;
            tm = GX_ITM_T2;
            break;
        default:
            ASSERTMSGLINE (0x1E0, 0, &quot;GXSetTevIndBumpST: Invalid matrix selection&quot;);
            break;
    }
    GXSetTevIndirect (tev_stage,
                      ind_stage,
                      GX_ITF_8,
                      GX_ITB_ST,
                      sm,
                      GX_ITW_0,
                      GX_ITW_0,
                      GX_FALSE,
                      GX_FALSE,
                      GX_ITBA_OFF);
    GXSetTevIndirect ((GXTevStageID)(tev_stage + 1),
                      ind_stage,
                      GX_ITF_8,
                      GX_ITB_ST,
                      tm,
                      GX_ITW_0,
                      GX_ITW_0,
                      GX_TRUE,
                      GX_FALSE,
                      GX_ITBA_OFF);
    GXSetTevIndirect ((GXTevStageID)(tev_stage + 2),
                      ind_stage,
                      GX_ITF_8,
                      GX_ITB_NONE,
                      GX_ITM_OFF,
                      GX_ITW_OFF,
                      GX_ITW_OFF,
                      GX_TRUE,
                      GX_FALSE,
                      GX_ITBA_OFF);
}

void
GXSetTevIndBumpXYZ (GXTevStageID tev_stage, GXIndTexStageID ind_stage, GXIndTexMtxID matrix_sel)
{
    CHECK_GXBEGIN (0x214, &quot;GXSetTevIndBumpXYZ&quot;);
    GXSetTevIndirect (tev_stage,
                      ind_stage,
                      GX_ITF_8,
                      GX_ITB_STU,
                      matrix_sel,
                      GX_ITW_OFF,
                      GX_ITW_OFF,
                      GX_FALSE,
                      GX_FALSE,
                      GX_ITBA_OFF);
}

void
GXSetTevIndRepeat (GXTevStageID tev_stage)
{
    CHECK_GXBEGIN (0x231, &quot;GXSetTevIndRepeat&quot;);
    GXSetTevIndirect (tev_stage,
                      GX_INDTEXSTAGE0,
                      GX_ITF_8,
                      GX_ITB_NONE,
                      GX_ITM_OFF,
                      GX_ITW_0,
                      GX_ITW_0,
                      GX_TRUE,
                      GX_FALSE,
                      GX_ITBA_OFF);
}

void
__GXUpdateBPMask (void)
{
    u32 nIndStages;
    u32 i;
    u32 tmap;
    u32 new_imask;
    u32 nStages;
    u32 new_dmask;
#pragma unused(nStages)

    new_imask  = 0;
    new_dmask  = 0;
    nIndStages = (u32)GET_REG_FIELD (__GXData-&gt;genMode, 3, 16);
    for (i = 0; i &lt; nIndStages; i++)
    {
        switch (i)
        {
            case 0:
                tmap = (u32)GET_REG_FIELD (__GXData-&gt;iref, 3, 0);
                break;
            case 1:
                tmap = (u32)GET_REG_FIELD (__GXData-&gt;iref, 3, 6);
                break;
            case 2:
                tmap = (u32)GET_REG_FIELD (__GXData-&gt;iref, 3, 12);
                break;
            case 3:
                tmap = (u32)GET_REG_FIELD (__GXData-&gt;iref, 3, 18);
                break;
        }
        new_imask |= 1 &lt;&lt; tmap;
    }

#if DEBUG
    nStages = GET_REG_FIELD (__GXData-&gt;genMode, 4, 10) + 1;
    for (i = 0; i &lt; nStages; i++)
    {
        tmap = __GXData-&gt;texmapId[i] &amp; 0xFFFFFEFF;
        if (tmap != 0xFF)
        {
            new_dmask |= 1 &lt;&lt; tmap;
        }
    }
    ASSERTMSGLINE (0x269,
                   !(new_imask &amp; new_dmask),
                   &quot;GXSetTevOrder/GXSetIndTexOrder: Same texture map cannot be &quot;
                   &quot;specified in both&quot;);
#endif

    if ((u8)__GXData-&gt;bpMask != new_imask)
    {
        SET_REG_FIELD (0x26E, __GXData-&gt;bpMask, 8, 0, new_imask);
        GX_WRITE_SOME_REG5 (0x61, __GXData-&gt;bpMask);
        __GXData-&gt;bpSent = 1;
    }
}

void
__GXFlushTextureState (void)
{
    GX_WRITE_SOME_REG5 (0x61, __GXData-&gt;bpMask);
    __GXData-&gt;bpSent = 1;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>