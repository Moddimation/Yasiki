<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File mtx.h - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-mtxh">File mtx.h</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_9b186dc3f3e3b6d33b9081cb8e685142/"><strong>include</strong></a> <strong>&gt;</strong> <a href="../dir_47b271ade99b633966c54f819f725c3c/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../mtx_8h/"><strong>mtx.h</strong></a></p>
<p><a href="../mtx_8h/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#ifndef _DOLPHIN_MTX_H_
#define _DOLPHIN_MTX_H_

#include &lt;types.h&gt;

#ifdef __cplusplus
extern &quot;C&quot;
{
#endif
typedef struct
{
    f32 x, y, z;
} Vec, *VecPtr, Point3d, *Point3dPtr;

typedef struct
{
    s16 x, y, z;
} S16Vec, *S16VecPtr;

typedef struct
{
    f32 x, y, z, w;
} Quaternion, *QuaternionPtr, Qtrn, *QtrnPtr;

typedef f32 Mtx[3][4];
typedef f32 Mtx44[4][4];

typedef f32 (*MtxPtr)[4];
typedef f32 (*Mtx44Ptr)[4];

typedef f32 ROMtx[4][3];
typedef f32 (*ROMtxPtr)[3];

void MTXScale (Mtx m, f32 xS, f32 yS, f32 zS);
void MTXOrtho (Mtx44 m, f32 t, f32 b, f32 l, f32 r, f32 n, f32 f);

void C_MTXFrustum (Mtx44 m, f32 t, f32 b, f32 l, f32 r, f32 n, f32 f);
void C_MTXPerspective (Mtx44 m, f32 fovY, f32 aspect, f32 n, f32 f);
void C_MTXLookAt (Mtx m, Point3dPtr camPos, VecPtr camUp, Point3dPtr target);

#ifdef DEBUG
#define VECSquareMag      C_VECSquareMag
#define VECNormalize      C_VECNormalize
#define VECAdd            C_VECAdd
#define VECDotProduct     C_VECDotProduct
#define VECSquareDistance C_VECSquareDistance
#define VECCrossProduct   C_VECCrossProduct
#define MTXMultVec        C_MTXMultVec
#define MTXMultVecArray   C_MTXMultVecArray
#define MTXCopy           C_MTXCopy
#define MTXConcat         C_MTXConcat
#define MTXInverse        C_MTXInverse
#define MTXTranspose      C_MTXTranspose
#define MTXIdentity       C_MTXIdentity
#else
#define VECSquareMag      PSVECSquareMag
#define VECNormalize      PSVECNormalize
#define VECAdd            PSVECAdd
#define VECDotProduct     PSVECDotProduct
#define VECSquareDistance PSVECSquareDistance
#define VECCrossProduct   PSVECCrossProduct
#define MTXMultVec        PSMTXMultVec
#define MTXMultVecArray   PSMTXMultVecArray
#define MTXCopy           PSMTXCopy
#define MTXConcat         PSMTXConcat
#define MTXInverse        PSMTXInverse
#define MTXTranspose      PSMTXTranspose
#define MTXIdentity       PSMTXIdentity
#endif

// asm only
#define MTXReorder           PSMTXReorder
#define MTXROMultVecArray    PSMTXROMultVecArray
#define MTXROSkin2VecArray   PSMTXROSkin2VecArray
#define MTXROMultS16VecArray PSMTXROMultS16VecArray
#define MTXMultS16VecArray   PSMTXMultS16VecArray

// mtx.c
// functions
void MTXRotRad (Mtx m, s8 axis, f32 rad);
void MTXRotTrig (Mtx m, s8 axis, f32 sinA, f32 cosA);
void MTXRotAxisRad (Mtx m, Vec* axis, f32 rad);
void MTXTrans (Mtx m, f32 xT, f32 yT, f32 zT);
void MTXTransApply (Mtx src, Mtx dst, f32 xT, f32 yT, f32 zT);
void MTXScale (Mtx m, f32 xS, f32 yS, f32 zS);
void MTXScaleApply (Mtx src, Mtx dst, f32 xS, f32 yS, f32 zS);
void MTXQuat (Mtx m, QuaternionPtr q);
void MTXReflect (Mtx m, Vec* p, Vec* n);
void MTXLookAt (Mtx m, Vec* camPos, Vec* camUp, Vec* target);
void MTXLightFrustum (Mtx m,
                      f32 t,
                      f32 b,
                      f32 l,
                      f32 r,
                      f32 n,
                      f32 scaleS,
                      f32 scaleT,
                      f32 transS,
                      f32 transT);
void MTXLightPerspective (Mtx m,
                          f32 fovY,
                          f32 aspect,
                          f32 scaleS,
                          f32 scaleT,
                          f32 transS,
                          f32 transT);
void MTXLightOrtho (Mtx m,
                    f32 t,
                    f32 b,
                    f32 l,
                    f32 r,
                    f32 scaleS,
                    f32 scaleT,
                    f32 transS,
                    f32 transT);

// C functions
void C_MTXIdentity (Mtx m);
void C_MTXCopy (Mtx src, Mtx dst);
void C_MTXConcat (Mtx a, Mtx b, Mtx ab);
void C_MTXTranspose (Mtx src, Mtx xPose);
u32  C_MTXInverse (Mtx src, Mtx inv);
u32  C_MTXInvXpose (Mtx src, Mtx invX);

// asm functions
void PSMTXIdentity (Mtx m);
void PSMTXCopy (Mtx src, Mtx dst);
void PSMTXConcat (Mtx mA, Mtx mB, Mtx mAB);
void PSMTXTranspose (Mtx src, Mtx xPose);
u32  PSMTXInverse (Mtx src, Mtx inv);
u32  PSMTXInvXpose (Mtx src, Mtx invX);

// mtxstack.c
typedef struct
{
    u32  numMtx;
    Mtx* stackBase;
    Mtx* stackPtr;
} MTXStack;

void MTXInitStack (MTXStack* sPtr, u32 numMtx);
Mtx* MTXPush (MTXStack* sPtr, Mtx m);
Mtx* MTXPushFwd (MTXStack* sPtr, Mtx m);
Mtx* MTXPushInv (MTXStack* sPtr, Mtx m);
Mtx* MTXPushInvXpose (MTXStack* sPtr, Mtx m);
Mtx* MTXPop (MTXStack* sPtr);
Mtx* MTXGetStackPtr (MTXStack* sPtr);

// mtxvec.c
void MTXMultVecSR (Mtx44 m, Vec* src, Vec* dst);
void MTXMultVecArraySR (Mtx44 m, Vec* srcBase, Vec* dstBase, u32 count);

// C functions
void C_MTXMultVec (Mtx44 m, Vec* src, Vec* dst);
void C_MTXMultVecArray (Mtx m, Vec* srcBase, Vec* dstBase, u32 count);

// asm functions
void PSMTXMultVec (Mtx44 m, Vec* src, Vec* dst);
void PSMTXMultVecArray (Mtx m, Vec* srcBase, Vec* dstBase, u32 count);

// psmtx.c
void PSMTXReorder (Mtx src, ROMtx dest);
void PSMTXROMultVecArray (ROMtx* m, Vec* srcBase, Vec* dstBase, u32 count);
void PSMTXROSkin2VecArray (ROMtx* m0,
                           ROMtx* m1,
                           f32*   wtBase,
                           Vec*   srcBase,
                           Vec*   dstBase,
                           u32    count);
void PSMTXROMultS16VecArray (ROMtx* m, S16Vec* srcBase, Vec* dstBase, u32 count);
void PSMTXMultS16VecArray (Mtx44* m, S16Vec* srcBase, Vec* dstBase, u32 count);

// vec.c
f32  VECMag (Vec* v);
void VECHalfAngle (Vec* a, Vec* b, Vec* half);
void VECReflect (Vec* src, Vec* normal, Vec* dst);
f32  VECDistance (Vec* a, Vec* b);

// C functions
void C_VECAdd (Vec* a, Vec* b, Vec* c);
void C_VECSubtract (Vec* a, Vec* b, Vec* c);
void C_VECScale (Vec* src, Vec* dst, f32 scale);
void C_VECNormalize (Vec* src, Vec* unit);
f32  C_VECSquareMag (Vec* v);
f32  C_VECDotProduct (Vec* a, Vec* b);
void C_VECCrossProduct (Vec* a, Vec* b, Vec* axb);
f32  C_VECSquareDistance (Vec* a, Vec* b);

// Asm functions
void PSVECAdd (Vec* a, Vec* b, Vec* c);
void PSVECSubtract (Vec* a, Vec* b, Vec* c);
void PSVECScale (Vec* src, Vec* dst, f32 scale);
void PSVECNormalize (Vec* vec1, Vec* dst);
f32  PSVECSquareMag (Vec* vec1);
f32  PSVECDotProduct (Vec* vec1, Vec* vec2);
void PSVECCrossProduct (Vec* vec1, Vec* vec2, Vec* dst);
f32  PSVECSquareDistance (Vec* vec1, Vec* vec2);

#ifdef __cplusplus
}
#endif

#endif
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>