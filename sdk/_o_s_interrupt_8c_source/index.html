<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File OSInterrupt.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-osinterruptc">File OSInterrupt.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_c85f9e83f0f4b4374578811cecebda65/"><strong>os</strong></a> <strong>&gt;</strong> <a href="../_o_s_interrupt_8c/"><strong>OSInterrupt.c</strong></a></p>
<p><a href="../_o_s_interrupt_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/os.h&gt;

#include &lt;string.h&gt;

#include &quot;OSPrivate.h&quot;

static asm void ExternalInterruptHandler (register __OSException exception,
                                          register OSContext*    context);

extern void __RAS_OSDisableInterrupts_begin (void);
extern void __RAS_OSDisableInterrupts_end (void);

#if DEBUG
u64 __OSSpuriousInterrupts = 0;
#endif
static __OSInterruptHandler* InterruptHandlerTable;

static OSInterruptMask InterruptPrioTable[] = {
    OS_INTERRUPTMASK_PI_ERROR,
    OS_INTERRUPTMASK_PI_DEBUG,
    OS_INTERRUPTMASK_MEM,
    OS_INTERRUPTMASK_PI_RSW,
    OS_INTERRUPTMASK_PI_VI,
    OS_INTERRUPTMASK_PI_PE,
    OS_INTERRUPTMASK_PI_HSP,
    OS_INTERRUPTMASK_DSP_ARAM | OS_INTERRUPTMASK_DSP_DSP | OS_INTERRUPTMASK_AI |
        OS_INTERRUPTMASK_EXI | OS_INTERRUPTMASK_PI_SI | OS_INTERRUPTMASK_PI_DI,
    OS_INTERRUPTMASK_DSP_AI,
    OS_INTERRUPTMASK_PI_CP,
    0xFFFFFFFF,
};

#if DEBUG
char* __OSInterruptNames[33] = {
    &quot;MEM_0&quot;,       &quot;MEM_1&quot;,        &quot;MEM_2&quot;,     &quot;MEM_3&quot;,     &quot;MEM_ADDRESS&quot;, &quot;DSP_AI&quot;,
    &quot;DSP_ARAM&quot;,    &quot;DSP_DSP&quot;,      &quot;AI_AI&quot;,     &quot;EXI_0_EXI&quot;, &quot;EXI_0_TC&quot;,    &quot;EXI_0_EXT&quot;,
    &quot;EXI_1_EXI&quot;,   &quot;EXI_1_TC&quot;,     &quot;EXI_1_EXT&quot;, &quot;EXI_2_EXI&quot;, &quot;EXI_2_TC&quot;,    &quot;PI_CP&quot;,
    &quot;PI_PE_TOKEN&quot;, &quot;PI_PE_FINISH&quot;, &quot;PI_SI&quot;,     &quot;PI_DI&quot;,     &quot;PI_RSW&quot;,      &quot;PI_ERROR&quot;,
    &quot;PI_VI&quot;,       &quot;PI_DEBUG&quot;,     &quot;PI_HSP&quot;,    &quot;unknown&quot;,   &quot;unknown&quot;,     &quot;unknown&quot;,
    &quot;unknown&quot;,     &quot;unknown&quot;,      &quot;unknown&quot;
};

char* __OSPIErrors[8] = {
    &quot;No Error&quot;,
    &quot;Misaligned address for CPU request&quot;,
    &quot;Incorrect transfer type (tt) from CPU&quot;,
    &quot;Unsupported transfer size&quot;,
    &quot;Address out of range&quot;,
    &quot;Write to ROM address space&quot;,
    &quot;Read from GX Fifo&quot;,
    &quot;Reserved error code&quot;,
};
#endif
asm BOOL
OSDisableInterrupts (void)
{
#ifdef __MWERKS__
    nofralloc;
    entry  __RAS_OSDisableInterrupts_begin;
    mfmsr  r3;
    rlwinm r4, r3, 0, 17, 15;
    mtmsr  r4;
    rlwinm r3, r3, 17, 31, 31;
    entry  __RAS_OSDisableInterrupts_end;
    blr;
#else
    return FALSE;
#endif
}

asm BOOL
OSEnableInterrupts (void)
{
#ifdef __MWERKS__
    nofralloc;

    mfmsr  r3;
    ori    r4, r3, 0x8000;
    mtmsr  r4;
    rlwinm r3, r3, 17, 31, 31;
    blr;
#else
    return FALSE;
#endif
}

asm BOOL
OSRestoreInterrupts (register BOOL level)
{
#ifdef __MWERKS__
    nofralloc;

    cmpwi level, 0;
    mfmsr r4;
    beq   _disable;
    ori   r5, r4, 0x8000;
    b     _restore;

_disable:
    rlwinm r5, r4, 0, 17, 15;

_restore:
    mtmsr  r5;
    rlwinm r4, r4, 17, 31, 31;
    blr;
#else
    return FALSE;
#endif
}

__OSInterruptHandler
__OSSetInterruptHandler (__OSInterrupt interrupt, __OSInterruptHandler handler)
{
    __OSInterruptHandler oldHandler;

    ASSERTMSGLINE (0x188,
                   InterruptHandlerTable,
                   &quot;__OSSetInterruptHandler(): OSInit() must be called in advance.&quot;);
    ASSERTMSGLINE (0x18A, interrupt &lt; 0x20, &quot;__OSSetInterruptHandler(): unknown interrupt.&quot;);

    oldHandler = InterruptHandlerTable[interrupt];
    InterruptHandlerTable[interrupt] = handler;
    return oldHandler;
}

__OSInterruptHandler
__OSGetInterruptHandler (__OSInterrupt interrupt)
{
    ASSERTMSGLINE (0x19E,
                   InterruptHandlerTable,
                   &quot;__OSGetInterruptHandler(): OSInit() must be called in advance.&quot;);
    ASSERTMSGLINE (0x1A0, interrupt &lt; 0x20, &quot;__OSGetInterruptHandler(): unknown interrupt.&quot;);
    return InterruptHandlerTable[interrupt];
}

void
__OSInterruptInit (void)
{
    InterruptHandlerTable = (void*)OSPhysicalToCached (0x3040);

    memset (InterruptHandlerTable, 0, __OS_INTERRUPT_MAX * sizeof (__OSInterruptHandler));

    *(OSInterruptMask*)OSPhysicalToCached (0x00C4) = 0;
    *(OSInterruptMask*)OSPhysicalToCached (0x00C8) = 0;

    __PIRegs[1] = 0xf0;

    __OSMaskInterrupts (OS_INTERRUPTMASK_MEM | OS_INTERRUPTMASK_DSP | OS_INTERRUPTMASK_AI |
                        OS_INTERRUPTMASK_EXI | OS_INTERRUPTMASK_PI);

    __OSSetExceptionHandler (4, ExternalInterruptHandler);
#if DEBUG
    __PIRegs[0] = 1;
    __OSUnmaskInterrupts (0x100);
#endif
}

static u32
SetInterruptMask (OSInterruptMask mask, OSInterruptMask current)
{
    u32 reg;

    switch (__cntlzw (mask))
    {
        case __OS_INTERRUPT_MEM_0:
        case __OS_INTERRUPT_MEM_1:
        case __OS_INTERRUPT_MEM_2:
        case __OS_INTERRUPT_MEM_3:
            reg = 0;
            if (!(current &amp; OS_INTERRUPTMASK_MEM_0))
            {
                reg |= 0x1;
            }
            if (!(current &amp; OS_INTERRUPTMASK_MEM_1))
            {
                reg |= 0x2;
            }
            if (!(current &amp; OS_INTERRUPTMASK_MEM_2))
            {
                reg |= 0x4;
            }
            if (!(current &amp; OS_INTERRUPTMASK_MEM_3))
            {
                reg |= 0x8;
            }
            if (!(current &amp; OS_INTERRUPTMASK_MEM_ADDRESS))
            {
                reg |= 0x10;
            }
            __MIRegs[0x0000000e] = (u16)reg;
            mask &amp;= ~OS_INTERRUPTMASK_MEM;
            break;
        case __OS_INTERRUPT_DSP_AI:
        case __OS_INTERRUPT_DSP_ARAM:
        case __OS_INTERRUPT_DSP_DSP:
            reg = __DSPRegs[0x00000005];
            reg &amp;= ~0x1F8;
            if (!(current &amp; OS_INTERRUPTMASK_DSP_AI))
            {
                reg |= 0x10;
            }
            if (!(current &amp; OS_INTERRUPTMASK_DSP_ARAM))
            {
                reg |= 0x40;
            }
            if (!(current &amp; OS_INTERRUPTMASK_DSP_DSP))
            {
                reg |= 0x100;
            }
            __DSPRegs[0x00000005] = (u16)reg;
            mask &amp;= ~OS_INTERRUPTMASK_DSP;
            break;
        case __OS_INTERRUPT_AI_AI:
            reg = __AIRegs[0];
            reg &amp;= ~0x2C;
            if (!(current &amp; OS_INTERRUPTMASK_AI_AI))
            {
                reg |= 0x4;
            }
            __AIRegs[0] = reg;
            mask &amp;= ~OS_INTERRUPTMASK_AI;
            break;
        case __OS_INTERRUPT_EXI_0_EXI:
        case __OS_INTERRUPT_EXI_0_TC:
        case __OS_INTERRUPT_EXI_0_EXT:
            reg = __EXIRegs[0];
            reg &amp;= ~0x2C0F;
            if (!(current &amp; OS_INTERRUPTMASK_EXI_0_EXI))
            {
                reg |= 0x1;
            }
            if (!(current &amp; OS_INTERRUPTMASK_EXI_0_TC))
            {
                reg |= 0x4;
            }
            if (!(current &amp; OS_INTERRUPTMASK_EXI_0_EXT))
            {
                reg |= 0x400;
            }
            __EXIRegs[0] = reg;
            mask &amp;= ~OS_INTERRUPTMASK_EXI_0;
            break;
        case __OS_INTERRUPT_EXI_1_EXI:
        case __OS_INTERRUPT_EXI_1_TC:
        case __OS_INTERRUPT_EXI_1_EXT:
            reg = __EXIRegs[5];
            reg &amp;= ~0xC0F;

            if (!(current &amp; OS_INTERRUPTMASK_EXI_1_EXI))
            {
                reg |= 0x1;
            }
            if (!(current &amp; OS_INTERRUPTMASK_EXI_1_TC))
            {
                reg |= 0x4;
            }
            if (!(current &amp; OS_INTERRUPTMASK_EXI_1_EXT))
            {
                reg |= 0x400;
            }
            __EXIRegs[5] = reg;
            mask &amp;= ~OS_INTERRUPTMASK_EXI_1;
            break;
        case __OS_INTERRUPT_EXI_2_EXI:
        case __OS_INTERRUPT_EXI_2_TC:
            reg = __EXIRegs[10];
            reg &amp;= ~0xF;
            if (!(current &amp; OS_INTERRUPTMASK_EXI_2_EXI))
            {
                reg |= 0x1;
            }
            if (!(current &amp; OS_INTERRUPTMASK_EXI_2_TC))
            {
                reg |= 0x4;
            }

            __EXIRegs[10] = reg;
            mask &amp;= ~OS_INTERRUPTMASK_EXI_2;
            break;
        case __OS_INTERRUPT_PI_CP:
        case __OS_INTERRUPT_PI_PE_TOKEN:
        case __OS_INTERRUPT_PI_PE_FINISH:
        case __OS_INTERRUPT_PI_SI:
        case __OS_INTERRUPT_PI_DI:
        case __OS_INTERRUPT_PI_RSW:
        case __OS_INTERRUPT_PI_ERROR:
        case __OS_INTERRUPT_PI_VI:
        case __OS_INTERRUPT_PI_DEBUG:
        case __OS_INTERRUPT_PI_HSP:
            reg = 0xF0;

            if (!(current &amp; OS_INTERRUPTMASK_PI_CP))
            {
                reg |= 0x800;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_SI))
            {
                reg |= 0x8;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_DI))
            {
                reg |= 0x4;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_RSW))
            {
                reg |= 0x2;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_ERROR))
            {
                reg |= 0x1;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_VI))
            {
                reg |= 0x100;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_DEBUG))
            {
                reg |= 0x1000;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_PE_TOKEN))
            {
                reg |= 0x200;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_PE_FINISH))
            {
                reg |= 0x400;
            }
            if (!(current &amp; OS_INTERRUPTMASK_PI_HSP))
            {
                reg |= 0x2000;
            }
            __PIRegs[1] = reg;
            mask &amp;= ~OS_INTERRUPTMASK_PI;
            break;
        default:
            break;
    }
    return mask;
}

OSInterruptMask
OSGetInterruptMask (void)
{
    return *(OSInterruptMask*)OSPhysicalToCached (0x00C8);
}

OSInterruptMask
OSSetInterruptMask (OSInterruptMask local)
{
    BOOL            enabled;
    OSInterruptMask global;
    OSInterruptMask prev;
    OSInterruptMask mask;

    enabled = OSDisableInterrupts();
    global = *(OSInterruptMask*)OSPhysicalToCached (0x00C4);
    prev = *(OSInterruptMask*)OSPhysicalToCached (0x00C8);
    mask = (global | prev) ^ local;
    *(OSInterruptMask*)OSPhysicalToCached (0x00C8) = local;
    while (mask) { mask = SetInterruptMask (mask, global | local); }
    OSRestoreInterrupts (enabled);
    return prev;
}

OSInterruptMask
__OSMaskInterrupts (OSInterruptMask global)
{
    BOOL            enabled;
    OSInterruptMask prev;
    OSInterruptMask local;
    OSInterruptMask mask;

    enabled = OSDisableInterrupts();
    prev = *(OSInterruptMask*)OSPhysicalToCached (0x00C4);
    local = *(OSInterruptMask*)OSPhysicalToCached (0x00C8);
    mask = ~(prev | local) &amp; global;
    global |= prev;
    *(OSInterruptMask*)OSPhysicalToCached (0x00C4) = global;
    while (mask) { mask = SetInterruptMask (mask, global | local); }
    OSRestoreInterrupts (enabled);
    return prev;
}

OSInterruptMask
__OSUnmaskInterrupts (OSInterruptMask global)
{
    BOOL            enabled;
    OSInterruptMask prev;
    OSInterruptMask local;
    OSInterruptMask mask;

    enabled = OSDisableInterrupts();
    prev = *(OSInterruptMask*)OSPhysicalToCached (0x00C4);
    local = *(OSInterruptMask*)OSPhysicalToCached (0x00C8);
    mask = (prev | local) &amp; global;
    global = prev &amp; ~global;
    *(OSInterruptMask*)OSPhysicalToCached (0x00C4) = global;
    while (mask) { mask = SetInterruptMask (mask, global | local); }
    OSRestoreInterrupts (enabled);
    return prev;
}

void
__OSDispatchInterrupt (__OSException exception, OSContext* context)
{
#pragma unused(exception)

    u32                  intsr;
    u32                  reg;
    OSInterruptMask      cause;
    OSInterruptMask      unmasked;
    OSInterruptMask*     prio;
    __OSInterrupt        interrupt;
    __OSInterruptHandler handler;

    intsr = __PIRegs[0];
    intsr &amp;= ~0x00010000;

    if (intsr == 0 || (intsr &amp; __PIRegs[1]) == 0)
    {
#if DEBUG
        __OSSpuriousInterrupts++;
#endif
        OSLoadContext (context);
    }

    cause = 0;

    if (intsr &amp; 0x00000080)
    {
        reg = __MIRegs[15];
        if (reg &amp; 0x1)
        {
            cause |= OS_INTERRUPTMASK_MEM_0;
        }
        if (reg &amp; 0x2)
        {
            cause |= OS_INTERRUPTMASK_MEM_1;
        }
        if (reg &amp; 0x4)
        {
            cause |= OS_INTERRUPTMASK_MEM_2;
        }
        if (reg &amp; 0x8)
        {
            cause |= OS_INTERRUPTMASK_MEM_3;
        }
        if (reg &amp; 0x10)
        {
            cause |= OS_INTERRUPTMASK_MEM_ADDRESS;
        }
    }

    if (intsr &amp; 0x00000040)
    {
        reg = __DSPRegs[5];
        if (reg &amp; 0x8)
        {
            cause |= OS_INTERRUPTMASK_DSP_AI;
        }
        if (reg &amp; 0x20)
        {
            cause |= OS_INTERRUPTMASK_DSP_ARAM;
        }
        if (reg &amp; 0x80)
        {
            cause |= OS_INTERRUPTMASK_DSP_DSP;
        }
    }

    if (intsr &amp; 0x00000020)
    {
        reg = __AIRegs[0];
        if (reg &amp; 0x8)
        {
            cause |= OS_INTERRUPTMASK_AI_AI;
        }
    }

    if (intsr &amp; 0x00000010)
    {
        reg = __EXIRegs[0];
        if (reg &amp; 0x2)
        {
            cause |= OS_INTERRUPTMASK_EXI_0_EXI;
        }
        if (reg &amp; 0x8)
        {
            cause |= OS_INTERRUPTMASK_EXI_0_TC;
        }
        if (reg &amp; 0x800)
        {
            cause |= OS_INTERRUPTMASK_EXI_0_EXT;
        }
        reg = __EXIRegs[5];
        if (reg &amp; 0x2)
        {
            cause |= OS_INTERRUPTMASK_EXI_1_EXI;
        }
        if (reg &amp; 0x8)
        {
            cause |= OS_INTERRUPTMASK_EXI_1_TC;
        }
        if (reg &amp; 0x800)
        {
            cause |= OS_INTERRUPTMASK_EXI_1_EXT;
        }
        reg = __EXIRegs[10];
        if (reg &amp; 0x2)
        {
            cause |= OS_INTERRUPTMASK_EXI_2_EXI;
        }
        if (reg &amp; 0x8)
        {
            cause |= OS_INTERRUPTMASK_EXI_2_TC;
        }
    }

    if (intsr &amp; 0x00002000)
    {
        cause |= OS_INTERRUPTMASK_PI_HSP;
    }
    if (intsr &amp; 0x00001000)
    {
        cause |= OS_INTERRUPTMASK_PI_DEBUG;
    }
    if (intsr &amp; 0x00000400)
    {
        cause |= OS_INTERRUPTMASK_PI_PE_FINISH;
    }
    if (intsr &amp; 0x00000200)
    {
        cause |= OS_INTERRUPTMASK_PI_PE_TOKEN;
    }
    if (intsr &amp; 0x00000100)
    {
        cause |= OS_INTERRUPTMASK_PI_VI;
    }
    if (intsr &amp; 0x00000008)
    {
        cause |= OS_INTERRUPTMASK_PI_SI;
    }
    if (intsr &amp; 0x00000004)
    {
        cause |= OS_INTERRUPTMASK_PI_DI;
    }
    if (intsr &amp; 0x00000002)
    {
        cause |= OS_INTERRUPTMASK_PI_RSW;
    }
    if (intsr &amp; 0x00000800)
    {
        cause |= OS_INTERRUPTMASK_PI_CP;
    }
    if (intsr &amp; 0x00000001)
    {
        cause |= OS_INTERRUPTMASK_PI_ERROR;
    }

#if DEBUG
    if (cause &amp; OS_INTERRUPTMASK_PI_ERROR)
    {
        OSReport (&quot;PI ERROR\n&quot;);
        OSDumpContext (context);
        OSReport (&quot;\nPIESR = 0x%08x                  PIEAR  = 0x%08x\n&quot;,
                  __PIRegs[7],
                  __PIRegs[8]);
        __PIRegs[0] = 1;
        OSReport (&quot;PI Error = %s\n&quot;, __OSPIErrors[__PIRegs[7]]);
        OSReport (&quot;Offending address = 0x%x (from PIEAR)\n&quot;, __PIRegs[8]);
    }
#endif

    unmasked = cause &amp; ~(*(OSInterruptMask*)OSPhysicalToCached (0x00C4) |
                         *(OSInterruptMask*)OSPhysicalToCached (0x00C8));
    if (unmasked)
    {
        for (prio = InterruptPrioTable;; ++prio)
        {
            if (unmasked &amp; *prio)
            {
                interrupt = (__OSInterrupt)__cntlzw (unmasked &amp; *prio);
                break;
            }
        }

        handler = __OSGetInterruptHandler (interrupt);
        if (handler)
        {
            OSDisableScheduler();
            handler (interrupt, context);
            OSEnableScheduler();
            __OSReschedule();
            OSLoadContext (context);
        }
    }

#if DEBUG
    OSReport (&quot;Unhandled Interrupt(s): cause %08x  intsr %08x\n&quot;, cause, intsr);
    while (cause)
    {
        interrupt = __cntlzw (cause);
        cause &amp;= ~(1 &lt;&lt; (0x1F - __cntlzw (cause)));
        OSReport (&quot;    %s\n&quot;, __OSInterruptNames[interrupt]);
    }
#endif

    OSLoadContext (context);
}

static asm void
ExternalInterruptHandler (register __OSException exception, register OSContext* context)
{
#pragma unused(exception)

#ifdef __MWERKS__
    nofralloc;
    OS_EXCEPTION_SAVE_GPRS (context);

    b __OSDispatchInterrupt;
#endif
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>