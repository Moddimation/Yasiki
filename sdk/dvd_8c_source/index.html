<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File dvd.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-dvdc">File dvd.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_6809de60dbef2d995cf7d874d1fa5b65/"><strong>dvd</strong></a> <strong>&gt;</strong> <a href="../dvd_8c/"><strong>dvd.c</strong></a></p>
<p><a href="../dvd_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;string.h&gt;

#include &quot;../os/OSPrivate.h&quot;
#include &quot;dvd_private.h&quot;

#define ERROR_FATAL            1
#define ERROR_RETRY            2
#define ERROR_RETRY_INTERNALLY 3

static u16*            tmpBuffer[32] ALIGN (32);
static DVDCommandBlock DummyCommandBlock;
static OSAlarm         ResetAlarm;

static BOOL autoInvalidation = 1;

static DVDCommandBlock* executing;
static void*            tmp;
static DVDDiskID*       currID;
static OSBootInfo*      bootInfo;
static volatile BOOL    PauseFlag;
static volatile BOOL    PausingFlag;
static BOOL             AutoFinishing;
static volatile BOOL    FatalErrorFlag;
static vu32             CurrCommand;
static vu32             Canceling;
static DVDCommandBlock* CancelingCommandBlock;
static void             (*CancelCallback) (s32, DVDCommandBlock*);
static vu32             ResumeFromHere;
static vu32             CancelLastError;
static u32              LastError;
static vs32             NumInternalRetry;
static BOOL             ResetRequired;
static BOOL             CancelAllSyncComplete;
static vu32             ResetCount;
static BOOL             FirstTimeInBootrom;
static s32              ResultForSyncCommand;
static BOOL             DVDInitialized;
void                    (*LastState) (DVDCommandBlock*);

static void stateReadingFST ();
static void cbForStateReadingFST (u32 intType);
static void cbForStateError (u32 intType);
static void stateError (u32 error);
static void stateTimeout ();
static void stateGettingError ();
static u32  CategorizeError (u32 error);
static BOOL CheckCancel (u32 resume);
static void cbForStateGettingError (u32 intType);
static void cbForUnrecoveredError (u32 intType);
static void cbForUnrecoveredErrorRetry (u32 intType);
static void stateGoToRetry ();
static void cbForStateGoToRetry (u32 intType);
static void stateCheckID ();
static void stateCheckID3 (DVDCommandBlock* block);
static void stateCheckID2 (DVDCommandBlock* block);
static void cbForStateCheckID1 (u32 intType);
static void cbForStateCheckID2 (u32 intType);
static void cbForStateCheckID3 (u32 intType);
static void stateCoverClosed ();
static void stateCoverClosed_CMD (DVDCommandBlock* block);
static void cbForStateCoverClosed (u32 intType);
static void stateMotorStopped ();
static void cbForStateMotorStopped (u32 intType);
static void stateReady ();
static void stateBusy (DVDCommandBlock* block);
static void cbForStateBusy (u32 intType);
static BOOL issueCommand (s32 prio, DVDCommandBlock* block);
static void cbForCancelStreamSync (s32 result, DVDCommandBlock* block);
static void cbForStopStreamAtEndSync (s32 result, DVDCommandBlock* block);
static void cbForGetStreamErrorStatusSync (s32 result, DVDCommandBlock* block);
static void cbForGetStreamPlayAddrSync (s32 result, DVDCommandBlock* block);
static void cbForGetStreamStartAddrSync (s32 result, DVDCommandBlock* block);
static void cbForGetStreamLengthSync (s32 result, DVDCommandBlock* block);
static void cbForChangeDiskSync ();
static void cbForInquirySync (s32 result, DVDCommandBlock* block);
static void cbForCancelSync ();
static void cbForCancelAllSync ();

void
DVDInit ()
{
    if (!DVDInitialized)
    {
        OSInitAlarm();
        DVDInitialized = 1;
        __DVDFSInit();
        __DVDClearWaitingQueue();
        __DVDInitWA();
        bootInfo = (void*)OSPhysicalToCached (0);
        currID   = &amp;bootInfo-&gt;DVDDiskID;
        __OSSetInterruptHandler (0x15, __DVDInterruptHandler);
        __OSUnmaskInterrupts (0x400U);
        OSInitThreadQueue (&amp;__DVDThreadQueue);
        __DIRegs[DI_SR]  = 0x2A;
        __DIRegs[DI_CVR] = 0;
        if (bootInfo-&gt;magic == OS_BOOTINFO_MAGIC_JTAG)
        {
            OSReport (&quot;app booted via JTAG\n&quot;);
            OSReport (&quot;load fst\n&quot;);
            __fstLoad();
            return;
        }
        if (bootInfo-&gt;magic == OS_BOOTINFO_MAGIC)
        {
            OSReport (&quot;app booted from bootrom\n&quot;);
            return;
        }
        FirstTimeInBootrom = 1;
        OSReport (&quot;bootrom\n&quot;);
    }
}

static void
stateReadingFST ()
{
    LastState = stateReadingFST;
    ASSERTLINE (0x219, ((u32)(bootInfo-&gt;FSTLocation) &amp; (32 - 1)) == 0);
    DVDLowRead (bootInfo-&gt;FSTLocation,
                OSRoundUp32B ((tmpBuffer[2])),
                (u32)tmpBuffer[1],
                cbForStateReadingFST);
}

static void
cbForStateReadingFST (u32 intType)
{
    DVDCommandBlock* finished;

    ASSERTLINE (0x229, (intType &amp; DVD_INTTYPE_CVR) == 0);

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        stateTimeout();
        return;
    }

    if (intType &amp; 1)
    {
        ASSERTLINE (0x22E, (intType &amp; DVD_INTTYPE_DE) == 0);
        NumInternalRetry = 0;
        finished         = executing;
        executing        = &amp;DummyCommandBlock;
        finished-&gt;state  = DVD_STATE_END;
        if (finished-&gt;callback)
        {
            finished-&gt;callback (0, finished);
        }
        stateReady();
        return;
    }
    ASSERTLINE (0x246, intType == DVD_INTTYPE_DE);
    stateGettingError();
}

static void
cbForStateError (u32 intType)
{
    DVDCommandBlock* finished;

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        stateTimeout();
        return;
    }

    FatalErrorFlag = TRUE;
    finished       = executing;
    executing      = &amp;DummyCommandBlock;
    if (finished-&gt;callback)
    {
        (finished-&gt;callback) (-1, finished);
    }
    if (Canceling)
    {
        Canceling = FALSE;
        if (CancelCallback)
            (CancelCallback) (0, finished);
    }

    FORCE_DONT_INLINE

    stateReady();
}

static void
stateError (u32 error)
{
    __DVDStoreErrorCode (error);
    DVDLowStopMotor (cbForStateError);
}

static void
stateTimeout ()
{
    DVDCommandBlock* finishing;

    __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
    DVDReset();

    FatalErrorFlag = TRUE;
    finishing      = executing;
    executing      = &amp;DummyCommandBlock;

    if (finishing-&gt;callback)
    {
        (finishing-&gt;callback) (-1, finishing);
    }

    if (Canceling)
    {
        Canceling = 0;
        if (CancelCallback)
            (CancelCallback) (0, finishing);
    }

    stateReady();
}

static void
stateGettingError ()
{
    DVDLowRequestError (cbForStateGettingError);
}

static u32
CategorizeError (u32 error)
{
    if (error == 0x20400)
    {
        LastError = error;
        return 1;
    }
    error &amp;= 0xFFFFFF;
    if ((error == 0x62800) || (error == 0x23A00) || (error == 0xB5A01))
    {
        return 0;
    }
    NumInternalRetry += 1;
    if (NumInternalRetry == 2)
    {
        if (error == LastError)
        {
            LastError = error;
            return 1;
        }
        LastError = error;
        return 2;
    }
    LastError = error;
    if ((error == 0x31100) || (executing-&gt;command == 5))
    {
        return 2;
    }

    return 3;
}

static BOOL
CheckCancel (u32 resume)
{
    DVDCommandBlock* finishing;
    if (Canceling)
    {
        ResumeFromHere   = resume;
        finishing        = executing;
        Canceling        = FALSE;
        executing        = &amp;DummyCommandBlock;
        finishing-&gt;state = 10;
        if (finishing-&gt;callback)
        {
            (finishing-&gt;callback) (-3, finishing);
        }
        if (CancelCallback)
        {
            (CancelCallback) (0, finishing);
        }
        stateReady();
        return TRUE;
    }

    return FALSE;
}

static void
cbForStateGettingError (u32 intType)
{
    u32 error;
    u32 status;
    u32 errorCategory;
    u32 resume;

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }
    if (intType &amp; DVD_INTTYPE_DE)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        stateError (DVD_DE_INT_ERROR_CODE);
        return;
    }

    ASSERTLINE (0x30F, intType == DVD_INTTYPE_TC);

    error         = __DIRegs[DI_IMMBUF];
    status        = error &amp; 0xFF000000;

    errorCategory = CategorizeError (error);
    if (errorCategory == ERROR_FATAL)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        stateError (error);
        return;
    }

    if ((errorCategory == ERROR_RETRY) || (errorCategory == ERROR_RETRY_INTERNALLY))
    {
        resume = 0;
    }
    else
    {
        if (status == 0x1000000)
            resume = 4;
        else if (status == 0x2000000)
            resume = 6;
        else if (status == 0x3000000)
            resume = 3;
        else
            resume = 5;
    }
    if (CheckCancel (resume))
        return;

    if (errorCategory == ERROR_RETRY)
    {
        __DVDStoreErrorCode (error);
        stateGoToRetry();
        return;
    }

    else if (errorCategory == ERROR_RETRY_INTERNALLY)
    {
        if ((error &amp; 0xFFFFFF) == 0x31100)
        {
            DVDLowSeek (executing-&gt;offset, cbForUnrecoveredError);
        }
        else
        {
            (*LastState) (executing);
        }
        return;
    }

    if (status == 0x1000000)
    {
        executing-&gt;state = 5;
        stateMotorStopped();
    }
    else if (status == 0x2000000)
    {
        executing-&gt;state = 3;
        stateCoverClosed();
    }
    else if (status == 0x3000000)
    {
        executing-&gt;state = 4;
        stateMotorStopped();
    }
    else
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        stateError (DVD_DE_INT_ERROR_CODE);
        return;
    }
}

static void
cbForUnrecoveredError (u32 intType)
{
    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }

    if ((intType &amp; 1))
    {
        stateGoToRetry();
        return;
    }

    DVDLowRequestError (cbForUnrecoveredErrorRetry);
}

static void
cbForUnrecoveredErrorRetry (u32 intType)
{
    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }

    executing-&gt;state = DVD_STATE_FATAL_ERROR;

    if (intType &amp; 2)
        stateError (0x1234567);
    else
        stateError (__DIRegs[DI_IMMBUF]);
}

static void
stateGoToRetry ()
{
    DVDLowStopMotor (cbForStateGoToRetry);
}

static void
cbForStateGoToRetry (u32 intType)
{
    DVDCommandBlock* finished;
#pragma unused(finished)

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }

    if (intType &amp; 2)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        stateError (DVD_DE_INT_ERROR_CODE);
        return;
    }

    ASSERTLINE (0x3D9, intType == DVD_INTTYPE_TC);

    NumInternalRetry = FALSE;

    if ((CurrCommand == DVD_COMMAND_BSREAD) || (CurrCommand == DVD_COMMAND_READID) ||
        (CurrCommand == DVD_COMMAND_AUDIO_BUFFER_CONFIG) ||
        (CurrCommand == DVD_COMMAND_BS_CHANGE_DISK))
    {
        ResetRequired = TRUE;
    }

    if (!CheckCancel (2))
    {
        executing-&gt;state = DVD_STATE_RETRY;
        stateMotorStopped();
    }
}

static void
stateCheckID ()
{
    switch (CurrCommand)
    {
        case DVD_COMMAND_CHANGE_DISK:
            if ((s32)memcmp (&amp;tmpBuffer, executing-&gt;id, 0x1C))
            {
                DVDLowStopMotor (cbForStateCheckID1);
                return;
            }
            memcpy (currID, &amp;tmpBuffer, sizeof (DVDDiskID));
            executing-&gt;state = DVD_STATE_BUSY;
            DCInvalidateRange (&amp;tmpBuffer, sizeof (DVDDiskID));
            LastState = stateCheckID2;
            stateCheckID2 (executing);
            break;
        default:
            if ((s32)memcmp (&amp;tmpBuffer, currID, sizeof (DVDDiskID)))
            {
                DVDLowStopMotor (cbForStateCheckID1);
                return;
            }
            LastState = stateCheckID3;
            stateCheckID3 (executing);
            ASSERTLINE (0x452, FALSE);
            return;
    }
}

static void
stateCheckID3 (DVDCommandBlock* block)
{
#pragma unused(block)

    DVDLowAudioBufferConfig (currID-&gt;streaming, 0xAU, cbForStateCheckID3);
}

static void
stateCheckID2 (DVDCommandBlock* block)
{
#pragma unused(block)

    DVDLowRead (&amp;tmpBuffer, 0x20U, 0x420, cbForStateCheckID2);
}

static void
cbForStateCheckID1 (u32 intType)
{
    DVDCommandBlock* finishing;
#pragma unused(finishing)

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }

    if ((intType &amp; DVD_INTTYPE_DE))
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (0x1234567);
        DVDLowStopMotor (cbForStateError);
        return;
    }

    ASSERTLINE (0x478, intType == DVD_INTTYPE_TC);
    NumInternalRetry = 0;
    if (!CheckCancel (TRUE))
    {
        executing-&gt;state = DVD_STATE_WRONG_DISK;
        stateMotorStopped();
    }
}

static void
cbForStateCheckID2 (u32 intType)
{
    ASSERTLINE (0x494, (intType &amp; DVD_INTTYPE_CVR) == 0);

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }

    if (intType &amp; DVD_INTTYPE_TC)
    {
        ASSERTLINE (0x499, (intType &amp; DVD_INTTYPE_DE) == 0);
        NumInternalRetry = 0;
        stateReadingFST();
        return;
    }
    ASSERTLINE (0x4AA, intType == DVD_INTTYPE_DE);

    stateGettingError();
}

static void
cbForStateCheckID3 (u32 intType)
{
    DVDCommandBlock* finishing;
#pragma unused(finishing)

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }
    ASSERTLINE (0x478, intType == DVD_INTTYPE_TC);

    if ((intType &amp; 1))
    {
        NumInternalRetry = 0;
        if (!CheckCancel (FALSE))
        {
            executing-&gt;state = 1;
            stateBusy (executing);
        }
        return;
    }

    DVDLowRequestError (cbForStateGettingError);
}

static void
AlarmHandler ()
{
    DVDReset();
    DCInvalidateRange (&amp;tmpBuffer, 0x20);
    LastState = stateCoverClosed_CMD;
    stateCoverClosed_CMD (executing);
}

static void
stateCoverClosed ()
{
    DVDCommandBlock* finished;

    switch (CurrCommand)
    {
        case DVD_COMMAND_BSREAD:
        case DVD_COMMAND_READID:
        case DVD_COMMAND_AUDIO_BUFFER_CONFIG:
        case DVD_COMMAND_BS_CHANGE_DISK:
            __DVDClearWaitingQueue();
            finished  = executing;
            executing = &amp;DummyCommandBlock;
            if (finished-&gt;callback)
            {
                finished-&gt;callback (-4, finished);
            }
            stateReady();
            return;
        default:
            DVDReset();
            OSCreateAlarm (&amp;ResetAlarm);
            OSSetAlarm (&amp;ResetAlarm, OSMillisecondsToTicks (1150), AlarmHandler);
    }
}

static void
stateCoverClosed_CMD (DVDCommandBlock* block)
{
#pragma unused(block)

    DVDLowReadDiskID ((void*)&amp;tmpBuffer, cbForStateCoverClosed);
}

static void
cbForStateCoverClosed (u32 intType)
{
    ASSERTLINE (0x510, (intType &amp; DVD_INTTYPE_CVR) == 0);

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }

    if (intType &amp; DVD_INTTYPE_TC)
    {
        ASSERTLINE (0x515, (intType &amp; DVD_INTTYPE_DE) == 0);
        ASSERTLINE (0x519,
                    (CurrCommand == DVD_COMMAND_READ) || (CurrCommand == DVD_COMMAND_SEEK) ||
                        (CurrCommand == DVD_COMMAND_CHANGE_DISK));
        NumInternalRetry = 0;
        stateCheckID();
        return;
    }
    ASSERTLINE (0x523, intType == DVD_INTTYPE_DE);
    stateGettingError();
}

static void
stateMotorStopped ()
{
    DVDLowWaitCoverClose (cbForStateMotorStopped);
}

static void
cbForStateMotorStopped (u32 intType)
{
#pragma unused(intType)

    ASSERTLINE (0x540, intType == DVD_INTTYPE_CVR);
    __DIRegs[DI_CVR] = 0;
    executing-&gt;state = DVD_STATE_COVER_CLOSED;
    stateCoverClosed();
}

static void
stateReady ()
{
    DVDCommandBlock* finished;

    if (!__DVDCheckWaitingQueue())
    {
        executing = NULL;
        return;
    }
    if (PauseFlag)
    {
        PausingFlag = TRUE;
        executing   = NULL;
        return;
    }
    executing = __DVDPopWaitingQueue();

    if (FatalErrorFlag)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        finished         = executing;
        executing        = &amp;DummyCommandBlock;

        if (finished-&gt;callback)
        {
            (finished-&gt;callback) (-1, finished);
        }

        stateReady();
        return;
    }

    CurrCommand = executing-&gt;command;
    if (ResumeFromHere)
    {
        switch (ResumeFromHere)
        {
            case 1:
                executing-&gt;state = DVD_STATE_WRONG_DISK;
                stateMotorStopped();
                break;
            case 2:
                executing-&gt;state = DVD_STATE_RETRY;
                stateMotorStopped();
                break;
            case 3:
                executing-&gt;state = DVD_STATE_NO_DISK;
                stateMotorStopped();
                break;
            case 7:
                executing-&gt;state = DVD_STATE_MOTOR_STOPPED;
                stateMotorStopped();
                break;
            case 4:
                executing-&gt;state = DVD_STATE_COVER_OPEN;
                stateMotorStopped();
                break;
            case 6:
                executing-&gt;state = DVD_STATE_COVER_CLOSED;
                stateCoverClosed();
                break;
            case 5:
                executing-&gt;state = DVD_STATE_FATAL_ERROR;
                stateError (CancelLastError);
                break;
        }
        ResumeFromHere = 0;
    }
    else
    {
        executing-&gt;state = DVD_STATE_BUSY;
        stateBusy (executing);
    }
}

static void
stateBusy (DVDCommandBlock* block)
{
    LastState = stateBusy;
    switch (block-&gt;command)
    {
        case DVD_COMMAND_READID:
            __DIRegs[DI_CVR]        = __DIRegs[DI_CVR];
            block-&gt;currTransferSize = 0x20;
            DVDLowReadDiskID (block-&gt;addr, cbForStateBusy);
            return;
        case DVD_COMMAND_READ:
        case DVD_COMMAND_BSREAD:
            __DIRegs[DI_CVR]        = __DIRegs[DI_CVR];
            block-&gt;currTransferSize = (block-&gt;length - block-&gt;transferredSize &gt; 0x600000)
                                          ? 0x600000
                                          : (block-&gt;length - block-&gt;transferredSize);
            DVDLowRead ((char*)block-&gt;addr + block-&gt;transferredSize,
                        block-&gt;currTransferSize,
                        block-&gt;offset + block-&gt;transferredSize,
                        cbForStateBusy);
            return;
        case DVD_COMMAND_SEEK:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            DVDLowSeek (block-&gt;offset, cbForStateBusy);
            return;
        case DVD_COMMAND_CHANGE_DISK:
            DVDLowStopMotor (cbForStateBusy);
            return;
        case DVD_COMMAND_BS_CHANGE_DISK:
            DVDLowStopMotor (cbForStateBusy);
            return;
        case DVD_COMMAND_INITSTREAM:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            if (AutoFinishing != 0)
            {
                executing-&gt;currTransferSize = 0;
                DVDLowRequestAudioStatus (0, cbForStateBusy);
                return;
            }
            executing-&gt;currTransferSize = 1;
            DVDLowAudioStream (0, block-&gt;length, block-&gt;offset, cbForStateBusy);
            return;
        case DVD_COMMAND_CANCELSTREAM:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            DVDLowAudioStream (0x10000, 0U, 0U, cbForStateBusy);
            return;
        case DVD_COMMAND_STOP_STREAM_AT_END:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            AutoFinishing    = 1;
            DVDLowAudioStream (0, 0U, 0U, cbForStateBusy);
            return;
        case DVD_COMMAND_REQUEST_AUDIO_ERROR:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            DVDLowRequestAudioStatus (0, cbForStateBusy);
            return;
        case DVD_COMMAND_REQUEST_PLAY_ADDR:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            DVDLowRequestAudioStatus (0x10000, cbForStateBusy);
            return;
        case DVD_COMMAND_REQUEST_START_ADDR:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            DVDLowRequestAudioStatus (0x20000, cbForStateBusy);
            return;
        case DVD_COMMAND_REQUEST_LENGTH:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            DVDLowRequestAudioStatus (0x30000, cbForStateBusy);
            return;
        case DVD_COMMAND_AUDIO_BUFFER_CONFIG:
            __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
            DVDLowAudioBufferConfig ((int)block-&gt;offset, block-&gt;length, cbForStateBusy);
            return;
        case DVD_COMMAND_INQUIRY:
            __DIRegs[DI_CVR]        = __DIRegs[DI_CVR];
            block-&gt;currTransferSize = 0x20;
            DVDLowInquiry (block-&gt;addr, cbForStateBusy);
            return;
    }
}

static void
cbForStateBusy (u32 intType)
{
    DVDCommandBlock* finished;
    s32              result;

    if (intType == DVD_INTTYPE_TIMEOUT)
    {
        executing-&gt;state = DVD_STATE_FATAL_ERROR;
        __DVDStoreErrorCode (DVD_TIMEOUT_ERROR_CODE);
        DVDReset();
        cbForStateError (0);
        return;
    }

    if ((CurrCommand == DVD_COMMAND_CHANGE_DISK) || (CurrCommand == DVD_COMMAND_BS_CHANGE_DISK))
    {
        if (intType &amp; DVD_INTTYPE_DE)
        {
            executing-&gt;state = DVD_STATE_FATAL_ERROR;
            stateError (DVD_DE_INT_ERROR_CODE);
            return;
        }
        ASSERTLINE (0x64B, intType == DVD_INTTYPE_TC);
        NumInternalRetry = 0;
        if (CurrCommand == DVD_COMMAND_BS_CHANGE_DISK)
        {
            ResetRequired = 1;
        }
        if (!CheckCancel (7))
        {
            executing-&gt;state = DVD_STATE_MOTOR_STOPPED;
            stateMotorStopped();
        }
        return;
    }
    ASSERTLINE (0x671, (intType &amp; DVD_INTTYPE_CVR) == 0);
    if ((CurrCommand == DVD_COMMAND_READ) || (CurrCommand == DVD_COMMAND_BSREAD) ||
        (CurrCommand == DVD_COMMAND_READID) || (CurrCommand == DVD_COMMAND_INQUIRY))
    {
        executing-&gt;transferredSize += executing-&gt;currTransferSize - __DIRegs[DI_LENGTH];
    }
    if (intType &amp; 8)
    {
        Canceling       = 0;
        finished        = executing;
        executing       = &amp;DummyCommandBlock;
        finished-&gt;state = DVD_STATE_CANCELED;
        if (finished-&gt;callback)
        {
            finished-&gt;callback (-3, finished);
        }
        if (CancelCallback)
        {
            CancelCallback (0, finished);
        }
        stateReady();
        return;
    }
    if (intType &amp; 1)
    {
        ASSERTLINE (0x697, (intType &amp; DVD_INTTYPE_DE) == 0);
        NumInternalRetry = 0;
        if (CheckCancel (0))
            return;

        if (CurrCommand == DVD_COMMAND_READ || CurrCommand == DVD_COMMAND_BSREAD ||
            CurrCommand == DVD_COMMAND_READID || CurrCommand == DVD_COMMAND_INQUIRY)
        {
            if (executing-&gt;transferredSize != executing-&gt;length)
            {
                stateBusy (executing);
                return;
            }
            finished        = executing;
            executing       = &amp;DummyCommandBlock;
            finished-&gt;state = DVD_STATE_END;
            if (finished-&gt;callback)
            {
                finished-&gt;callback ((s32)finished-&gt;transferredSize, finished);
            }
            stateReady();
            return;
        }
        else if (CurrCommand == DVD_COMMAND_REQUEST_AUDIO_ERROR ||
                 CurrCommand == DVD_COMMAND_REQUEST_PLAY_ADDR ||
                 CurrCommand == DVD_COMMAND_REQUEST_START_ADDR ||
                 CurrCommand == DVD_COMMAND_REQUEST_LENGTH)
        {
            if (CurrCommand == DVD_COMMAND_REQUEST_START_ADDR ||
                CurrCommand == DVD_COMMAND_REQUEST_PLAY_ADDR)
            {
                result = (s32)__DIRegs[DI_IMMBUF] * 4;
            }
            else
            {
                result = (s32)__DIRegs[DI_IMMBUF];
            }

            finished        = executing;
            executing       = &amp;DummyCommandBlock;
            finished-&gt;state = DVD_STATE_END;
            if (finished-&gt;callback)
            {
                finished-&gt;callback (result, finished);
            }
            stateReady();
            return;
        }
        else if (CurrCommand == DVD_COMMAND_INITSTREAM)
        {
            if (executing-&gt;currTransferSize == 0)
            {
                if (__DIRegs[DI_IMMBUF] &amp; 1)
                {
                    finished        = executing;
                    executing       = &amp;DummyCommandBlock;
                    finished-&gt;state = DVD_STATE_IGNORED;
                    if (finished-&gt;callback)
                    {
                        finished-&gt;callback (-2, finished);
                    }
                    stateReady();
                    return;
                }
                AutoFinishing               = 0;
                executing-&gt;currTransferSize = 1;
                DVDLowAudioStream (0, executing-&gt;length, executing-&gt;offset, cbForStateBusy);
                return;
            }
            finished        = executing;
            executing       = &amp;DummyCommandBlock;
            finished-&gt;state = DVD_STATE_END;
            if (finished-&gt;callback)
            {
                finished-&gt;callback (0, finished);
            }
            stateReady();
            return;
        }
        else
        {
            finished        = executing;
            executing       = &amp;DummyCommandBlock;
            finished-&gt;state = DVD_STATE_END;
            if (finished-&gt;callback)
            {
                finished-&gt;callback (0, finished);
            }
            stateReady();
            return;
        }
    }
    else
    {
        if (CurrCommand == 14)
        {
            executing-&gt;state = DVD_STATE_FATAL_ERROR;
            stateError (DVD_DE_INT_ERROR_CODE);
            return;
        }
        if ((CurrCommand == DVD_COMMAND_READ || CurrCommand == DVD_COMMAND_BSREAD ||
             CurrCommand == DVD_COMMAND_READID || CurrCommand == DVD_COMMAND_INQUIRY) &amp;&amp;
            executing-&gt;transferredSize == executing-&gt;length)
        {
            if (CheckCancel (0))
            {
                return;
            }
            finished        = executing;
            executing       = &amp;DummyCommandBlock;

            finished-&gt;state = 0;
            if (finished-&gt;callback)
            {
                (finished-&gt;callback) ((s32)finished-&gt;transferredSize, finished);
            }
            stateReady();
            return;
        }

        ASSERTLINE (0x728, intType == DVD_INTTYPE_DE);
        stateGettingError();
    }
}

static BOOL
issueCommand (s32 prio, DVDCommandBlock* block)
{
    BOOL level;
    BOOL result;

    if (autoInvalidation != 0 &amp;&amp;
        (block-&gt;command == DVD_COMMAND_READ || block-&gt;command == DVD_COMMAND_BSREAD ||
         block-&gt;command == DVD_COMMAND_READID || block-&gt;command == DVD_COMMAND_INQUIRY))
    {
        DCInvalidateRange (block-&gt;addr, block-&gt;length);
    }
    level = OSDisableInterrupts();
#if DEBUG
    if (executing == block ||
        block-&gt;state == DVD_STATE_WAITING &amp;&amp; __DVDIsBlockInWaitingQueue (block))
    {
        ASSERTMSGLINE (0x758,
                       FALSE,
                       &quot;DVD library: Specified command block (or file info) &quot;
                       &quot;is already in use\n&quot;);
    }
#endif
    block-&gt;state = DVD_STATE_WAITING;
    result       = __DVDPushWaitingQueue (prio, block);
    if (executing == NULL &amp;&amp; PauseFlag == 0)
    {
        stateReady();
    }
    OSRestoreInterrupts (level);

    return result;
}

BOOL
DVDReadAbsAsyncPrio (DVDCommandBlock* block,
                     void*            addr,
                     s32              length,
                     s32              offset,
                     void             (*callback) (s32, DVDCommandBlock*),
                     s32              prio)
{
    BOOL idle;

    ASSERTMSGLINE (0x780,
                   block,
                   &quot;DVDReadAbsAsync(): null pointer is specified to command &quot;
                   &quot;block address.&quot;);
    ASSERTMSGLINE (0x781, addr, &quot;DVDReadAbsAsync(): null pointer is specified to addr.&quot;);
    ASSERTMSGLINE (0x783,
                   !OFFSET (addr, 32),
                   &quot;DVDReadAbsAsync(): address must be aligned with 32 byte &quot;
                   &quot;boundary.&quot;);
    ASSERTMSGLINE (0x785,
                   !(length &amp; (32 - 1)),
                   &quot;DVDReadAbsAsync(): length must be a multiple of 32.&quot;);
    ASSERTMSGLINE (0x787,
                   !(offset &amp; (4 - 1)),
                   &quot;DVDReadAbsAsync(): offset must be a multiple of 4.&quot;);
    ASSERTMSGLINE (0x789,
                   length &gt; 0,
                   &quot;DVD read: 0 or negative value was specified to length of &quot;
                   &quot;the read\n&quot;);

    block-&gt;command         = DVD_COMMAND_READ;
    block-&gt;addr            = addr;
    block-&gt;length          = (u32)length;
    block-&gt;offset          = (u32)offset;
    block-&gt;transferredSize = 0;
    block-&gt;callback        = callback;
    idle                   = issueCommand (prio, block);

    ASSERTMSGLINE (0x793,
                   idle,
                   &quot;DVDReadAbsAsync(): command block is used for processing &quot;
                   &quot;previous request.&quot;);

    return idle;
}

BOOL
DVDSeekAbsAsyncPrio (DVDCommandBlock* block,
                     s32              offset,
                     void             (*callback) (long, DVDCommandBlock*),
                     s32              prio)
{
    BOOL idle;

    ASSERTMSGLINE (0x7AA,
                   block,
                   &quot;DVDSeekAbs(): null pointer is specified to command &quot;
                   &quot;block address.&quot;);
    ASSERTMSGLINE (0x7AC, !(offset &amp; (4 - 1)), &quot;DVDSeekAbs(): offset must be a multiple of 4.&quot;);

    block-&gt;command  = DVD_COMMAND_SEEK;
    block-&gt;offset   = (u32)offset;
    block-&gt;callback = callback;
    idle            = issueCommand (prio, block);

    ASSERTMSGLINE (0x7B3,
                   idle,
                   &quot;DVDSeekAbs(): command block is used for processing &quot;
                   &quot;previous request.&quot;);

    return idle;
}

BOOL
DVDReadAbsAsyncForBS (DVDCommandBlock* block,
                      void*            addr,
                      s32              length,
                      s32              offset,
                      void             (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    ASSERTMSGLINE (0x7D1,
                   block,
                   &quot;DVDReadAbsAsyncForBS(): null pointer is specified to &quot;
                   &quot;command block address.&quot;);
    ASSERTMSGLINE (0x7D2, addr, &quot;DVDReadAbsAsyncForBS(): null pointer is specified to addr.&quot;);
    ASSERTMSGLINE (0x7D4,
                   !OFFSET (addr, 32),
                   &quot;DVDReadAbsAsyncForBS(): address must be aligned with 32 &quot;
                   &quot;byte boundary.&quot;);
    ASSERTMSGLINE (0x7D6,
                   !(length &amp; (32 - 1)),
                   &quot;DVDReadAbsAsyncForBS(): length must be a multiple of 32.&quot;);
    ASSERTMSGLINE (0x7D8,
                   !(offset &amp; (4 - 1)),
                   &quot;DVDReadAbsAsyncForBS(): offset must be a multiple of 4.&quot;);

    block-&gt;command         = DVD_COMMAND_BSREAD;
    block-&gt;addr            = addr;
    block-&gt;length          = (u32)length;
    block-&gt;offset          = (u32)offset;
    block-&gt;transferredSize = 0;
    block-&gt;callback        = callback;
    idle                   = issueCommand (2, block);

    ASSERTMSGLINE (0x7E2,
                   idle,
                   &quot;DVDReadAbsAsyncForBS(): command block is used for &quot;
                   &quot;processing previous request.&quot;);

    return idle;
}

BOOL
DVDReadDiskID (DVDCommandBlock* block,
               DVDDiskID*       diskID,
               void             (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    ASSERTMSGLINE (0x7F9,
                   block,
                   &quot;DVDReadDiskID(): null pointer is specified to command &quot;
                   &quot;block address.&quot;);
    ASSERTMSGLINE (0x7FA, diskID, &quot;DVDReadDiskID(): null pointer is specified to id address.&quot;);
    ASSERTMSGLINE (0x7FC,
                   !OFFSET (diskID, 32),
                   &quot;DVDReadDiskID(): id must be aligned with 32 byte boundary.&quot;);

    block-&gt;command         = DVD_COMMAND_READID;
    block-&gt;addr            = diskID;
    block-&gt;length          = 0x20;
    block-&gt;offset          = 0;
    block-&gt;transferredSize = 0;
    block-&gt;callback        = callback;
    idle                   = issueCommand (2, block);

    ASSERTMSGLINE (0x806,
                   idle,
                   &quot;DVDReadDiskID(): command block is used for processing &quot;
                   &quot;previous request.&quot;);

    return idle;
}

BOOL
DVDPrepareStreamAbsAsync (DVDCommandBlock* block,
                          u32              length,
                          u32              offset,
                          void             (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    block-&gt;command  = DVD_COMMAND_INITSTREAM;
    block-&gt;length   = length;
    block-&gt;offset   = offset;
    block-&gt;callback = callback;
    idle            = issueCommand (1, block);

    return idle;
}

BOOL
DVDCancelStreamAsync (DVDCommandBlock* block, void (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    block-&gt;command  = DVD_COMMAND_CANCELSTREAM;
    block-&gt;callback = callback;
    idle            = issueCommand (1, block);

    return idle;
}

s32
DVDCancelStream (DVDCommandBlock* block)
{
    BOOL result;
    s32  state;
    BOOL enabled;
    s32  retVal;

    result = DVDCancelStreamAsync (block, cbForCancelStreamSync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (TRUE)
    {
        state = ((volatile DVDCommandBlock*)block)-&gt;state;
        if (state == DVD_STATE_END || state == DVD_STATE_FATAL_ERROR ||
            state == DVD_STATE_CANCELED)
        {
            retVal = (s32)block-&gt;transferredSize;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForCancelStreamSync (s32 result, DVDCommandBlock* block)
{
    block-&gt;transferredSize = (u32)result;
    OSWakeupThread (&amp;__DVDThreadQueue);
}

BOOL
DVDStopStreamAtEndAsync (DVDCommandBlock* block, void (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    block-&gt;command  = DVD_COMMAND_STOP_STREAM_AT_END;
    block-&gt;callback = callback;
    idle            = issueCommand (1, block);

    return idle;
}

s32
DVDStopStreamAtEnd (DVDCommandBlock* block)
{
    BOOL result;
    s32  state;
    BOOL enabled;
    s32  retVal;

    result = DVDStopStreamAtEndAsync (block, cbForStopStreamAtEndSync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (1)
    {
        state = block-&gt;state;
        if (state != DVD_STATE_BUSY &amp;&amp; state != DVD_STATE_WAITING)
        {
            retVal = ResultForSyncCommand;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForStopStreamAtEndSync (s32 result, DVDCommandBlock* block)
{
#pragma unused(block)

    ResultForSyncCommand = result;
    OSWakeupThread (&amp;__DVDThreadQueue);
}

BOOL
DVDGetStreamErrorStatusAsync (DVDCommandBlock* block, void (*callback) (s32, DVDCommandBlock*))
{
#pragma unused(block)

    BOOL idle;

    block-&gt;command  = DVD_COMMAND_REQUEST_AUDIO_ERROR;
    block-&gt;callback = callback;
    idle            = issueCommand (1, block);

    return idle;
}

s32
DVDGetStreamErrorStatus (DVDCommandBlock* block)
{
    BOOL result;
    s32  state;
    BOOL enabled;
    s32  retVal;

    result = DVDGetStreamErrorStatusAsync (block, cbForGetStreamErrorStatusSync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (1)
    {
        state = block-&gt;state;
        if (state != DVD_STATE_BUSY &amp;&amp; state != DVD_STATE_WAITING)
        {
            retVal = ResultForSyncCommand;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForGetStreamErrorStatusSync (s32 result, DVDCommandBlock* block)
{
#pragma unused(block)

    ResultForSyncCommand = result;
    OSWakeupThread (&amp;__DVDThreadQueue);
}

BOOL
DVDGetStreamPlayAddrAsync (DVDCommandBlock* block, void (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    block-&gt;command  = DVD_COMMAND_REQUEST_PLAY_ADDR;
    block-&gt;callback = callback;
    idle            = issueCommand (1, block);

    return idle;
}

s32
DVDGetStreamPlayAddr (DVDCommandBlock* block)
{
    BOOL result;
    s32  state;
    BOOL enabled;
    s32  retVal;

    result = DVDGetStreamPlayAddrAsync (block, cbForGetStreamPlayAddrSync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (1)
    {
        state = block-&gt;state;
        if (state != DVD_STATE_BUSY &amp;&amp; state != DVD_STATE_WAITING)
        {
            retVal = ResultForSyncCommand;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForGetStreamPlayAddrSync (s32 result, DVDCommandBlock* block)
{
#pragma unused(block)

    ResultForSyncCommand = result;
    OSWakeupThread (&amp;__DVDThreadQueue);
}

BOOL
DVDGetStreamStartAddrAsync (DVDCommandBlock* block, void (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    block-&gt;command  = DVD_COMMAND_REQUEST_START_ADDR;
    block-&gt;callback = callback;
    idle            = issueCommand (1, block);

    return idle;
}

s32
DVDGetStreamStartAddr (DVDCommandBlock* block)
{
    BOOL result;
    s32  state;
    BOOL enabled;
    s32  retVal;

    result = DVDGetStreamStartAddrAsync (block, cbForGetStreamStartAddrSync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (1)
    {
        state = block-&gt;state;
        if (state != DVD_STATE_BUSY &amp;&amp; state != DVD_STATE_WAITING)
        {
            retVal = ResultForSyncCommand;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForGetStreamStartAddrSync (s32 result, DVDCommandBlock* block)
{
#pragma unused(block)

    ResultForSyncCommand = result;
    OSWakeupThread (&amp;__DVDThreadQueue);
}

BOOL
DVDGetStreamLengthAsync (DVDCommandBlock* block, void (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    block-&gt;command  = DVD_COMMAND_REQUEST_LENGTH;
    block-&gt;callback = callback;
    idle            = issueCommand (1, block);

    return idle;
}

s32
DVDGetStreamLength (DVDCommandBlock* block)
{
    BOOL result;
    s32  state;
    BOOL enabled;
    s32  retVal;

    result = DVDGetStreamLengthAsync (block, cbForGetStreamLengthSync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (1)
    {
        state = block-&gt;state;
        if (state != DVD_STATE_BUSY &amp;&amp; state != DVD_STATE_WAITING)
        {
            retVal = ResultForSyncCommand;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForGetStreamLengthSync (s32 result, DVDCommandBlock* block)
{
    block-&gt;transferredSize = (u32)result;
    OSWakeupThread (&amp;__DVDThreadQueue);
}

void
__DVDAudioBufferConfig (DVDCommandBlock* block,
                        u32              enable,
                        u32              size,
                        void             (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    block-&gt;command  = DVD_COMMAND_AUDIO_BUFFER_CONFIG;
    block-&gt;offset   = enable;
    block-&gt;length   = size;
    block-&gt;callback = callback;
    idle            = issueCommand (2, block);
}

BOOL
DVDChangeDiskAsyncForBS (DVDCommandBlock* block, void (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    ASSERTMSGLINE (0xA1F,
                   block,
                   &quot;DVDChangeDiskAsyncForBS(): null pointer is specified to &quot;
                   &quot;command block address.&quot;);

    block-&gt;command  = DVD_COMMAND_BS_CHANGE_DISK;
    block-&gt;callback = callback;
    idle            = issueCommand (2, block);

    ASSERTMSGLINE (0xA25,
                   idle,
                   &quot;DVDChangeDiskAsyncForBS(): command block is used for &quot;
                   &quot;processing previous request.&quot;);

    return idle;
}

BOOL
DVDChangeDiskAsync (DVDCommandBlock* block,
                    DVDDiskID*       id,
                    void             (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    ASSERTMSGLINE (0xA3A,
                   block,
                   &quot;DVDChangeDisk(): null pointer is specified to command &quot;
                   &quot;block address.&quot;);
    ASSERTMSGLINE (0xA3B, id, &quot;DVDChangeDisk(): null pointer is specified to id address.&quot;);

    block-&gt;command  = DVD_COMMAND_CHANGE_DISK;
    block-&gt;id       = id;
    block-&gt;callback = callback;
    DCInvalidateRange (bootInfo-&gt;FSTLocation, bootInfo-&gt;FSTMaxLength);
    idle = issueCommand (2, block);

    ASSERTMSGLINE (0xA44,
                   idle,
                   &quot;DVDChangeDisk(): command block is used for processing &quot;
                   &quot;previous request.&quot;);

    return idle;
}

s32
DVDChangeDisk (DVDCommandBlock* block, DVDDiskID* id)
{
    BOOL result;
    s32  state;
    BOOL enabled;
    s32  retVal;

    result = DVDChangeDiskAsync (block, id, cbForChangeDiskSync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (1)
    {
        state = block-&gt;state;
        if (state == DVD_STATE_END)
        {
            retVal = 0;
            break;
        }
        else if (state == DVD_STATE_FATAL_ERROR)
        {
            retVal = -1;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForChangeDiskSync ()
{
    OSWakeupThread (&amp;__DVDThreadQueue);
}

BOOL
DVDInquiryAsync (DVDCommandBlock*     block,
                 struct DVDDriveInfo* info,
                 void                 (*callback) (s32, DVDCommandBlock*))
{
    BOOL idle;

    ASSERTMSGLINE (0xA94, block, &quot;DVDInquiry(): Null address was specified for block&quot;);
    ASSERTMSGLINE (0xA95, info, &quot;DVDInquiry(): Null address was specified for info&quot;);
    ASSERTMSGLINE (0xA97,
                   !OFFSET (info, 32),
                   &quot;DVDInquiry(): Address for info is not 32 bytes aligned&quot;);

    block-&gt;command         = 0xE;
    block-&gt;addr            = info;
    block-&gt;length          = 0x20;
    block-&gt;transferredSize = 0;
    block-&gt;callback        = callback;
    idle                   = issueCommand (2, block);

    return idle;
}

s32
DVDInquiry (DVDCommandBlock* block, struct DVDDriveInfo* info)
{
    BOOL result;
    s32  state;
    BOOL enabled;
    s32  retVal;

    result = DVDInquiryAsync (block, info, cbForInquirySync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();
    while (1)
    {
        state = block-&gt;state;
        if (state != DVD_STATE_BUSY &amp;&amp; state != DVD_STATE_WAITING)
        {
            retVal = ResultForSyncCommand;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForInquirySync (s32 result, DVDCommandBlock* block)
{
#pragma unused(block)

    ResultForSyncCommand = result;
    OSWakeupThread (&amp;__DVDThreadQueue);
}

void
DVDReset ()
{
    DVDLowReset();
    __DIRegs[DI_SR]  = 0x2A;
    __DIRegs[DI_CVR] = __DIRegs[DI_CVR];
    ResetRequired    = 0;
    ResumeFromHere   = 0;
}

BOOL
DVDResetRequired ()
{
    return ResetRequired;
}

s32
DVDGetCommandBlockStatus (DVDCommandBlock* block)
{
    BOOL enabled;
    s32  retVal;
    s32  status;

    enabled = OSDisableInterrupts();

    ASSERTMSGLINE (0xAF9,
                   block,
                   &quot;DVDGetCommandBlockStatus(): null pointer is specified to &quot;
                   &quot;command block address.&quot;);

    status = block-&gt;state;
    if (status == DVD_STATE_COVER_CLOSED)
    {
        retVal = DVD_STATE_BUSY;
    }
    else
    {
        retVal = status;
    }

    OSRestoreInterrupts (enabled);

    return retVal;
}

s32
DVDGetDriveStatus ()
{
    BOOL enabled;
    s32  retVal;

    enabled = OSDisableInterrupts();

    if (FatalErrorFlag != FALSE)
    {
        retVal = DVD_STATE_FATAL_ERROR;
    }
    else if (PausingFlag != FALSE)
    {
        retVal = DVD_STATE_PAUSING;
    }
    else
    {
        if (executing == (DVDCommandBlock*)NULL)
        {
            retVal = DVD_STATE_END;
        }
        else if (executing == &amp;DummyCommandBlock)
        {
            retVal = DVD_STATE_END;
        }
        else
        {
            retVal = DVDGetCommandBlockStatus (executing);
        }
    }

    OSRestoreInterrupts (enabled);

    return retVal;
}

int
DVDSetAutoInvalidation (BOOL autoInval)
{
    BOOL prev;

    prev             = autoInvalidation;
    autoInvalidation = autoInval;

    return prev;
}

void
DVDPause ()
{
    BOOL level;

    level     = OSDisableInterrupts();
    PauseFlag = 1;
    if (executing == NULL)
    {
        PausingFlag = 1;
    }

    OSRestoreInterrupts (level);
}

void
DVDResume ()
{
    BOOL level;

    level     = OSDisableInterrupts();
    PauseFlag = 0;
    if (PausingFlag != 0)
    {
        PausingFlag = 0;
        stateReady();
    }

    OSRestoreInterrupts (level);
}

BOOL
DVDCancelAsync (DVDCommandBlock* block, void (*callback) (s32, DVDCommandBlock*))
{
    BOOL enabled;
    void (*old) (u32);

    enabled = OSDisableInterrupts();

    switch (block-&gt;state)
    {
        case DVD_STATE_FATAL_ERROR:
        case DVD_STATE_END:
        case DVD_STATE_CANCELED:
            if (callback)
            {
                callback (0, block);
            }
            break;
        case DVD_STATE_BUSY:
            if (Canceling != 0)
            {
                OSRestoreInterrupts (enabled);
                return FALSE;
            }
            Canceling      = TRUE;
            CancelCallback = callback;
            if (block-&gt;command == DVD_COMMAND_BSREAD || block-&gt;command == DVD_COMMAND_READ)
            {
                DVDLowBreak();
            }
            break;
        case DVD_STATE_WAITING:
            __DVDDequeueWaitingQueue (block);
            block-&gt;state = DVD_STATE_CANCELED;
            if (block-&gt;callback)
            {
                block-&gt;callback (-3, block);
            }
            if (callback)
            {
                callback (0, block);
            }
            break;
        case DVD_STATE_COVER_CLOSED:
            switch (block-&gt;command)
            {
                case DVD_COMMAND_READID:
                case DVD_COMMAND_BSREAD:
                case DVD_COMMAND_AUDIO_BUFFER_CONFIG:
                case DVD_COMMAND_BS_CHANGE_DISK:
                    if (callback)
                    {
                        callback (0, block);
                    }
                    break;
                default:
                    if (Canceling)
                    {
                        OSRestoreInterrupts (enabled);
                        return FALSE;
                    }
                    Canceling      = TRUE;
                    CancelCallback = callback;
                    break;
            }
            break;
        case DVD_STATE_NO_DISK:
        case DVD_STATE_COVER_OPEN:
        case DVD_STATE_WRONG_DISK:
        case DVD_STATE_MOTOR_STOPPED:
        case DVD_STATE_RETRY:
            old = DVDLowClearCallback();
            ASSERTLINE (0xBDB, old == cbForStateMotorStopped);
            if (old != cbForStateMotorStopped)
            {
                OSRestoreInterrupts (enabled);
                return 0;
            }
            if (block-&gt;state == DVD_STATE_NO_DISK)
            {
                ResumeFromHere = 3;
            }
            if (block-&gt;state == DVD_STATE_COVER_OPEN)
            {
                ResumeFromHere = 4;
            }
            if (block-&gt;state == DVD_STATE_WRONG_DISK)
            {
                ResumeFromHere = 1;
            }
            if (block-&gt;state == DVD_STATE_RETRY)
            {
                ResumeFromHere = 2;
            }
            if (block-&gt;state == DVD_STATE_MOTOR_STOPPED)
            {
                ResumeFromHere = 7;
            }
            block-&gt;state = DVD_STATE_CANCELED;
            if (block-&gt;callback)
            {
                block-&gt;callback (-3, block);
            }
            if (callback)
            {
                callback (0, block);
            }
            stateReady();
            break;
    }
    OSRestoreInterrupts (enabled);

    return TRUE;
}

s32
DVDCancel (volatile DVDCommandBlock* block)
{
    BOOL result;
    s32  state;
    u32  command;
    BOOL enabled;

    result = DVDCancelAsync ((void*)block, cbForCancelSync);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();
    while (1)
    {
        state = block-&gt;state;
        if (state == DVD_STATE_END || state == DVD_STATE_FATAL_ERROR ||
            state == DVD_STATE_CANCELED)
        {
            break;
        }
        if (state == DVD_STATE_COVER_CLOSED)
        {
            command = block-&gt;command;
            if ((command == DVD_COMMAND_BSREAD) || (command == DVD_COMMAND_READID) ||
                (command == DVD_COMMAND_AUDIO_BUFFER_CONFIG) ||
                (command == DVD_COMMAND_BS_CHANGE_DISK))
            {
                break;
            }
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return 0;
}

static void
cbForCancelSync ()
{
    OSWakeupThread (&amp;__DVDThreadQueue);
}

int
DVDCancelAllAsync (void (*callback) (s32, DVDCommandBlock*))
{
    BOOL             enabled;
    DVDCommandBlock* p;
    BOOL             retVal;

    enabled = OSDisableInterrupts();
    DVDPause();
    while ((p = __DVDPopWaitingQueue())) { DVDCancelAsync (p, NULL); }
    if (executing)
    {
        retVal = DVDCancelAsync (executing, callback);
    }
    else
    {
        retVal = 1;
        if (callback)
        {
            callback (0, NULL);
        }
    }
    DVDResume();

    OSRestoreInterrupts (enabled);

    return retVal;
}

s32
DVDCancelAll ()
{
    BOOL result;
    BOOL enabled;

    enabled               = OSDisableInterrupts();
    CancelAllSyncComplete = 0;
    result                = DVDCancelAllAsync (cbForCancelAllSync);
    if (result == 0)
    {
        OSRestoreInterrupts (enabled);
        return -1;
    }
    while (1)
    {
        if (CancelAllSyncComplete == 0)
        {
            OSSleepThread (&amp;__DVDThreadQueue);
        }
        else
        {
            break;
        }
    }
    OSRestoreInterrupts (enabled);

    return 0;
}

static void
cbForCancelAllSync ()
{
    CancelAllSyncComplete = 1;
    OSWakeupThread (&amp;__DVDThreadQueue);
}

DVDDiskID*
DVDGetCurrentDiskID ()
{
    return (void*)OSPhysicalToCached (0);
}

BOOL
DVDCheckDisk ()
{
    BOOL enabled;
    s32  retVal;
    s32  state;
    s32  coverReg;

    enabled = OSDisableInterrupts();

    if (FatalErrorFlag != FALSE)
    {
        state = DVD_STATE_FATAL_ERROR;
    }
    else if (PausingFlag != FALSE)
    {
        state = DVD_STATE_PAUSING;
    }
    else
    {
        if (executing == (DVDCommandBlock*)NULL)
        {
            state = DVD_STATE_END;
        }
        else if (executing == &amp;DummyCommandBlock)
        {
            state = DVD_STATE_END;
        }
        else
        {
            state = executing-&gt;state;
        }
    }

    switch (state)
    {
        case 1:
        case 9:
        case 10:
        case 2:
            retVal = TRUE;
            break;
        case -1:
        case 11:
        case 7:
        case 3:
        case 4:
        case 5:
        case 6:
            retVal = FALSE;
            break;
        case 0:
        case 8:
            coverReg = (s32)__DIRegs[DI_CVR];
            if (((coverReg &gt;&gt; 2) &amp; 1) || (coverReg &amp; 1))
            {
                retVal = FALSE;
            }
            else
            {
                retVal = TRUE;
            }
    }

    OSRestoreInterrupts (enabled);

    return retVal;
}

void
__DVDPrepareResetAsync (DVDCBCallback cb)
{
    BOOL enabled;

    enabled = OSDisableInterrupts();

    __DVDClearWaitingQueue();

    if (Canceling)
    {
        CancelCallback = cb;
    }
    else
    {
        if (executing)
        {
            executing-&gt;callback = NULL;
        }

        DVDCancelAllAsync (cb);
    }

    OSRestoreInterrupts (enabled);
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>