<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File dtk.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-dtkc">File dtk.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_1d471b1f96371d391f50bf9f8bbe7b25/"><strong>dtk</strong></a> <strong>&gt;</strong> <a href="../dtk_8c/"><strong>dtk.c</strong></a></p>
<p><a href="../dtk_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;macros.h&gt;

#include &lt;dolphin/ai.h&gt;
#include &lt;dolphin/dtk.h&gt;
#include &lt;dolphin/dvd.h&gt;
#include &lt;dolphin/os.h&gt;

static DTKTrack*        __DTKCurrentTrack;
static DTKTrack*        __DTKPlayListHead;
static DTKTrack*        __DTKPlayListTail;
static volatile u32     __DTKState;
static volatile u32     __DTKTempState;
static volatile u32     __DTKRepeatMode;
static volatile u32     __DTKPosition;
static volatile u32     __DTKInterruptFrequency;
static volatile u8      __DTKVolumeL;
static volatile u8      __DTKVolumeR;
static volatile u32     __DTKShutdownFlag;
static volatile u32     __DTKTrackEnded;
static DTKFlushCallback __DTKFlushCallback;

static DVDCommandBlock __block_for_run_callback;
static DVDCommandBlock __block_for_prep_callback;
static DVDCommandBlock __block_for_stream_status;
static DVDCommandBlock __block_for_ais_isr;
static DVDCommandBlock __block_for_flushtracks;
static DVDCommandBlock __block_for_repeatmode;
static DVDCommandBlock __block_for_set_state;
static DVDCommandBlock __block_for_next_track;
static DVDCommandBlock __block_for_prev_track;

static void
__DTKStartAi (void)
{
    AISetStreamVolLeft (__DTKVolumeL);
    AISetStreamVolRight (__DTKVolumeR);
    AIResetStreamSampleCount();
    AISetStreamTrigger (__DTKInterruptFrequency);
    AISetStreamPlayState (1);
}

static void
__DTKStopAi (void)
{
    AISetStreamVolLeft (0);
    AISetStreamVolRight (0);
    AISetStreamPlayState (0);
}

static void
__DTKCheckUserCallback (struct DTKTrack* track, u32 event)
{
    ASSERTLINE (0x53, track);
    if (track &amp;&amp; track-&gt;callback &amp;&amp; (track-&gt;eventMask &amp; event))
    {
        track-&gt;callback (track-&gt;eventMask &amp; event);
    }
}

static void
__DTKForward (void)
{
    BOOL old = OSDisableInterrupts();
    if (__DTKCurrentTrack &amp;&amp; __DTKCurrentTrack-&gt;next)
    {
        __DTKCurrentTrack = __DTKCurrentTrack-&gt;next;
    }
    OSRestoreInterrupts (old);
}

static void
__DTKBackward (void)
{
    BOOL old = OSDisableInterrupts();
    if (__DTKCurrentTrack &amp;&amp; __DTKCurrentTrack-&gt;prev)
    {
        __DTKCurrentTrack = __DTKCurrentTrack-&gt;prev;
    }
    OSRestoreInterrupts (old);
}

static void
__DTKCallbackForStreamStatus (s32 result, DVDCommandBlock* block)
{
    if ((result &amp; 0xFF) == 0)
    {
        __DTKTrackEnded = 1;
        __DTKPosition = 0;
    }
}

static void
__DTKCallbackForRun (s32 result, DVDFileInfo* fileInfo)
{
    __DTKStartAi();
    DVDStopStreamAtEndAsync (&amp;__block_for_run_callback, 0);
    __DTKState = DTK_STATE_RUN;
    __DTKCheckUserCallback (__DTKCurrentTrack, 1);
}

static void
__DTKCallbackForPreparePaused (s32 result, DVDFileInfo* fileInfo)
{
    __DTKStopAi();
    DVDStopStreamAtEndAsync (&amp;__block_for_prep_callback, 0);
    __DTKState = DTK_STATE_PAUSE;
    __DTKCheckUserCallback (__DTKCurrentTrack, 32);
}

static void
__DTKPrepareCurrentTrack (void)
{
    DVDPrepareStreamAsync (&amp;__DTKCurrentTrack-&gt;dvdFileInfo, 0, 0, __DTKCallbackForRun);
}

static void
__DTKPrepareCurrentTrackPaused (void)
{
    DVDPrepareStreamAsync (&amp;__DTKCurrentTrack-&gt;dvdFileInfo, 0, 0, __DTKCallbackForPreparePaused);
}

static void
__DTKCallbackForPlaylist (s32 result, DVDCommandBlock* block)
{
    __DTKPosition = result;
    if (__DTKTrackEnded)
    {
        __DTKTrackEnded = 0;
        __DTKCheckUserCallback (__DTKCurrentTrack, 16);
        __DTKState = DTK_STATE_BUSY;
        switch (__DTKRepeatMode)
        {
            case DTK_MODE_NOREPEAT:
                if (__DTKCurrentTrack)
                {
                    if (__DTKCurrentTrack-&gt;next)
                    {
                        __DTKCurrentTrack = __DTKCurrentTrack-&gt;next;
                        __DTKStopAi();
                        __DTKPrepareCurrentTrack();
                    }
                    else
                    {
                        __DTKCurrentTrack = __DTKPlayListHead;
                        __DTKStopAi();
                        __DTKState = DTK_STATE_STOP;
                    }
                }
                break;
            case DTK_MODE_ALLREPEAT:
                if (__DTKCurrentTrack)
                {
                    if (__DTKCurrentTrack-&gt;next)
                    {
                        __DTKCurrentTrack = __DTKCurrentTrack-&gt;next;
                        __DTKStopAi();
                        __DTKPrepareCurrentTrack();
                    }
                    else
                    {
                        __DTKCurrentTrack = __DTKPlayListHead;
                        __DTKStopAi();
                        __DTKPrepareCurrentTrack();
                    }
                }
                break;
            case DTK_MODE_REPEAT1:
                if (__DTKCurrentTrack)
                {
                    __DTKStopAi();
                    __DTKPrepareCurrentTrack();
                }
                break;
        }
    }
    else
    {
        DVDGetStreamErrorStatusAsync (&amp;__block_for_stream_status, __DTKCallbackForStreamStatus);
    }
}

static void
__DTKCallbackForAIInterrupt (u32 count)
{
    AISetStreamTrigger (count + __DTKInterruptFrequency);
    if (__DTKCurrentTrack)
    {
        DVDGetStreamPlayAddrAsync (&amp;__block_for_ais_isr, __DTKCallbackForPlaylist);
    }
}

static void
__DTKCallbackForFlush (s32 result, DVDCommandBlock* block)
{
    struct DTKTrack* track;

    AISetStreamPlayState (0);
    track = __DTKPlayListHead;
    while (track)
    {
        DVDClose (&amp;track-&gt;dvdFileInfo);
        track = track-&gt;next;
    }
    __DTKPlayListHead = NULL;
    __DTKPlayListTail = NULL;
    __DTKCurrentTrack = NULL;
    __DTKState = DTK_STATE_STOP;
    if (__DTKFlushCallback)
    {
        __DTKFlushCallback();
        __DTKFlushCallback = NULL;
    }
    __DTKState = DTK_STATE_STOP;
    __DTKShutdownFlag = 0;
}

static void
__DTKCallbackForStop (s32 result, DVDCommandBlock* block)
{
    __DTKCheckUserCallback (__DTKCurrentTrack, 2);
    __DTKState = DTK_STATE_STOP;
}

static void
__DTKCallbackForNextTrack (s32 result, DVDCommandBlock* block)
{
    AISetStreamPlayState (0);
    __DTKForward();
    __DTKState = DTK_STATE_STOP;
    DTKSetState (__DTKTempState);
}

static void
__DTKCallbackForPrevTrack (s32 result, DVDCommandBlock* block)
{
    AISetStreamPlayState (0);
    __DTKBackward();
    __DTKState = DTK_STATE_STOP;
    DTKSetState (__DTKTempState);
}

void
DTKInit (void)
{
    __DTKCurrentTrack = NULL;
    __DTKPlayListHead = NULL;
    __DTKPlayListTail = NULL;
    __DTKState = DTK_STATE_STOP;
    __DTKRepeatMode = DTK_MODE_NOREPEAT;
    __DTKPosition = 0;
    __DTKInterruptFrequency = 48000;
    __DTKVolumeL = 255;
    __DTKVolumeR = 255;
    AISetStreamVolLeft (0);
    AISetStreamVolRight (0);
    AIRegisterStreamCallback (__DTKCallbackForAIInterrupt);
    AIResetStreamSampleCount();
    AISetStreamPlayState (0);
}

void
DTKShutdown (void)
{
    __DTKState = DTK_STATE_STOP;
    AISetStreamVolLeft (0);
    AISetStreamVolRight (0);
    AIRegisterStreamCallback (NULL);
    AIResetStreamSampleCount();
    AISetStreamPlayState (0);
    __DTKShutdownFlag = 1;
    DTKFlushTracks (NULL);
    while (__DTKShutdownFlag)
    {
    }
}

u32
DTKQueueTrack (char* fileName, DTKTrack* track, u32 eventMask, DTKCallback callback)
{
    u32  startTrack;
    BOOL old;

    startTrack = 0;
    if (!DVDOpen (fileName, &amp;track-&gt;dvdFileInfo))
    {
        return 1;
    }
    old = OSDisableInterrupts();
    track-&gt;fileName = fileName;
    track-&gt;eventMask = eventMask;
    track-&gt;callback = callback;
    if (__DTKPlayListHead == NULL)
    {
        __DTKPlayListHead = track;
        __DTKPlayListTail = track;
        track-&gt;prev = NULL;
        track-&gt;next = NULL;
        if (__DTKState == DTK_STATE_RUN)
        {
            startTrack = 1;
        }
    }
    else
    {
        __DTKPlayListTail-&gt;next = track;
        track-&gt;prev = __DTKPlayListTail;
        __DTKPlayListTail = track;
        track-&gt;next = NULL;
    }
    if (__DTKCurrentTrack == NULL)
    {
        __DTKCurrentTrack = track;
    }
    OSRestoreInterrupts (old);
    __DTKCheckUserCallback (track, 8);
    if (startTrack != 0)
    {
        __DTKState = DTK_STATE_BUSY;
        __DTKPrepareCurrentTrack();
    }
    return 0;
}

u32
DTKRemoveTrack (struct DTKTrack* track)
{
    BOOL old;

    if (track == __DTKCurrentTrack)
    {
        return 2;
    }
    old = OSDisableInterrupts();
    DVDClose (&amp;track-&gt;dvdFileInfo);
    if (track == __DTKPlayListHead &amp;&amp; track == __DTKPlayListTail)
    {
        __DTKPlayListHead = NULL;
        __DTKPlayListTail = NULL;
        OSRestoreInterrupts (old);
        return 0;
    }
    if (track == __DTKPlayListHead)
    {
        __DTKPlayListHead = track-&gt;next;
        __DTKPlayListHead-&gt;prev = NULL;
        if (__DTKRepeatMode == DTK_MODE_ALLREPEAT)
        {
            __DTKPlayListTail-&gt;next = __DTKPlayListHead;
        }
        OSRestoreInterrupts (old);
        return 0;
    }
    if (track == __DTKPlayListTail)
    {
        __DTKPlayListTail = track-&gt;prev;
        __DTKPlayListTail-&gt;next = NULL;
        if (__DTKRepeatMode == DTK_MODE_ALLREPEAT)
        {
            __DTKPlayListTail-&gt;next = __DTKPlayListHead;
        }
        OSRestoreInterrupts (old);
        return 0;
    }
    track-&gt;prev-&gt;next = track-&gt;next;
    track-&gt;next-&gt;prev = track-&gt;prev;
    OSRestoreInterrupts (old);
    return 0;
}

void
DTKFlushTracks (DTKFlushCallback callback)
{
    u32 temp;

    if (__DTKState != DTK_STATE_BUSY)
    {
        temp = __DTKState;
        __DTKState = DTK_STATE_BUSY;
        __DTKFlushCallback = callback;
        if (temp == DTK_STATE_RUN)
        {
            DVDCancelStreamAsync (&amp;__block_for_flushtracks, __DTKCallbackForFlush);
        }
        else
        {
            __DTKCallbackForFlush (0, 0);
        }
    }
}

void
DTKSetSampleRate (u32 samplerate)
{
    // obsolete
}

void
DTKSetInterruptFrequency (u32 samples)
{
    __DTKInterruptFrequency = samples;
    AIResetStreamSampleCount();
    AISetStreamTrigger (__DTKInterruptFrequency);
}

void
DTKSetRepeatMode (u32 repeat)
{
    __DTKRepeatMode = repeat;
}

void
DTKSetState (u32 state)
{
    if (__DTKState == state || __DTKState == DTK_STATE_BUSY)
    {
        return;
    }
    switch (state)
    {
        case DTK_STATE_STOP:
            if (__DTKCurrentTrack)
            {
                __DTKState = DTK_STATE_BUSY;
                AISetStreamVolLeft (0);
                AISetStreamVolRight (0);
                AISetStreamPlayState (0);
                DVDCancelStreamAsync (&amp;__block_for_set_state, __DTKCallbackForStop);
            }
            break;
        case DTK_STATE_RUN:
            if (__DTKState == DTK_STATE_PAUSE)
            {
                __DTKStartAi();
                __DTKState = DTK_STATE_RUN;
                if (__DTKCurrentTrack)
                {
                    __DTKCheckUserCallback (__DTKCurrentTrack, 1);
                }
            }
            else if (__DTKCurrentTrack)
            {
                __DTKState = DTK_STATE_BUSY;
                __DTKPrepareCurrentTrack();
            }
            else
            {
                __DTKState = DTK_STATE_RUN;
            }
            __DTKTrackEnded = 0;
            break;
        case DTK_STATE_PREPARE:
            if (__DTKState == DTK_STATE_STOP)
            {
                if (__DTKCurrentTrack)
                {
                    __DTKState = DTK_STATE_BUSY;
                    __DTKPrepareCurrentTrackPaused();
                }
                __DTKTrackEnded = 0;
            }
            break;
        case DTK_STATE_PAUSE:
            AISetStreamPlayState (0);
            if (__DTKState == DTK_STATE_RUN)
            {
                __DTKState = DTK_STATE_PAUSE;
            }
            __DTKCheckUserCallback (__DTKCurrentTrack, 4);
            break;
    }
}

void
DTKNextTrack (void)
{
    if (__DTKState != DTK_STATE_BUSY &amp;&amp; __DTKCurrentTrack)
    {
        __DTKTempState = __DTKState;
        __DTKState = DTK_STATE_BUSY;
        if (__DTKTempState == DTK_STATE_RUN)
        {
            AISetStreamVolLeft (0);
            AISetStreamVolRight (0);
            DVDCancelStreamAsync (&amp;__block_for_next_track, __DTKCallbackForNextTrack);
        }
        else
        {
            __DTKForward();
            __DTKState = __DTKTempState;
        }
    }
}

void
DTKPrevTrack (void)
{
    if (__DTKState != DTK_STATE_BUSY &amp;&amp; __DTKCurrentTrack)
    {
        __DTKTempState = __DTKState;
        __DTKState = DTK_STATE_BUSY;
        if (__DTKTempState == DTK_STATE_RUN)
        {
            AISetStreamVolLeft (0);
            AISetStreamVolRight (0);
            DVDCancelStreamAsync (&amp;__block_for_prev_track, __DTKCallbackForPrevTrack);
        }
        else
        {
            __DTKBackward();
            __DTKState = __DTKTempState;
        }
    }
}

u32
DTKGetSampleRate (void)
{
    return 1; // obsolete
}

u32
DTKGetRepeatMode (void)
{
    return __DTKRepeatMode;
}

u32
DTKGetState (void)
{
    return __DTKState;
}

u32
DTKGetPosition (void)
{
    return __DTKPosition;
}

u32
DTKGetInterruptFrequency (void)
{
    return __DTKInterruptFrequency;
}

DTKTrack*
DTKGetCurrentTrack (void)
{
    return __DTKCurrentTrack;
}

void
DTKSetVolume (u8 left, u8 right)
{
    __DTKVolumeL = left;
    __DTKVolumeR = right;
    if (__DTKState == DTK_STATE_RUN)
    {
        AISetStreamVolLeft (left);
        AISetStreamVolRight (right);
    }
}

u16
DTKGetVolume (void)
{
    return (__DTKVolumeL &lt;&lt; 8) | __DTKVolumeR;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>