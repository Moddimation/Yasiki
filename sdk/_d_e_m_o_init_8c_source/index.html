<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File DEMOInit.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-demoinitc">File DEMOInit.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_12b9b9f3614a19f67fa121459aa56b48/"><strong>demo</strong></a> <strong>&gt;</strong> <a href="../_d_e_m_o_init_8c/"><strong>DEMOInit.c</strong></a></p>
<p><a href="../_d_e_m_o_init_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/demo.h&gt;
#include &lt;dolphin/gx.h&gt;
#include &lt;dolphin/pad.h&gt;
#include &lt;dolphin/vi.h&gt;

#include &lt;dolphin.h&gt;

#include &quot;DEMOPrivate.h&quot;

extern u16 DemoStatEnable; // size: 0x1, address: 0x0

// .bss
static struct _GXRenderModeObj rmodeobj; // size: 0x3C, address: 0x0

// .sdata
static u16 DemoFirstFrame = 1; // size: 0x1, address: 0x0

// .sbss
static void*                    DefaultFifo = NULL;    // size: 0x4, address: 0x0
static GXFifoObj*               DefaultFifoObj = NULL; // size: 0x4, address: 0x4
static struct _GXRenderModeObj* rmode;                 // size: 0x4, address: 0x8
static int                      BypassWorkaround;      // size: 0x4, address: 0xC
static u32                      FrameCount;            // size: 0x4, address: 0x10
static u32                      FrameMissThreshold;    // size: 0x4, address: 0x14
void*                           DemoFrameBuffer1;      // size: 0x4, address: 0x20
void*                           DemoFrameBuffer2;      // size: 0x4, address: 0x1C
void*                           DemoCurrentBuffer;     // size: 0x4, address: 0x18

// functions
static void __DEMOInitRenderMode (struct _GXRenderModeObj* mode);
static void __DEMOInitMem ();
static void __DEMOInitGX ();
static void __DEMOInitVI ();
static void __DEMOInitForEmu ();
static void __BypassRetraceCallback ();
static void __BypassDoneRender ();
static void LoadMemInfo ();

void
DEMOInit (struct _GXRenderModeObj* mode)
{
    OSInit();
    DVDInit();
    VIInit();
    DEMOPadInit();
    __DEMOInitRenderMode (mode);
    __DEMOInitMem();
    VIConfigure (rmode);
    DefaultFifo = OSAllocFromHeap (__OSCurrHeap, 0x40000);
    DefaultFifoObj = GXInit (DefaultFifo, 0x40000);
    __DEMOInitGX();
    __DEMOInitVI();
}

static void
__DEMOInitRenderMode (struct _GXRenderModeObj* mode)
{
    if (mode != NULL)
    {
        rmode = mode;
        return;
    }
    switch (VIGetTvFormat())
    {
        case VI_NTSC:
            rmode = &amp;GXNtsc480IntDf;
            break;
        case VI_PAL:
            rmode = &amp;GXPal528IntDf;
            break;
        case VI_MPAL:
            rmode = &amp;GXMpal480IntDf;
            break;
        default:
            OSPanic (__FILE__, 0x1A6, &quot;DEMOInit: invalid TV format\n&quot;);
            break;
    }
    GXAdjustForOverscan (rmode, &amp;rmodeobj, 0, 0x10);
    rmode = &amp;rmodeobj;
}

static void
__DEMOInitMem ()
{
    void* arenaLo = OSGetArenaLo();
    void* arenaHi = OSGetArenaHi();
    u32   fbSize = ((u16)(rmode-&gt;fbWidth + 15) &amp; 0xFFF0) * rmode-&gt;xfbHeight * 2;

    DemoFrameBuffer1 = (void*)(((u32)arenaLo + 0x1F) &amp; 0xFFFFFFE0);
    DemoFrameBuffer2 = (void*)(((u32)DemoFrameBuffer1 + fbSize + 0x1F) &amp; 0xFFFFFFE0);
    DemoCurrentBuffer = DemoFrameBuffer2;
    arenaLo = (void*)(((u32)DemoFrameBuffer2 + fbSize + 0x1F) &amp; 0xFFFFFFE0);
    OSSetArenaLo (arenaLo);
    if (((OSGetConsoleType() + 0xF0000000) == 4U) &amp;&amp;
        ((OSGetPhysicalMemSize() + 0xFFC00000) != 0U) &amp;&amp;
        (OSGetConsoleSimulatedMemSize() &lt; 0x01800000U))
    {
        LoadMemInfo();
        return;
    }
    arenaLo = OSGetArenaLo();
    arenaHi = OSGetArenaHi();
    arenaLo = OSInitAlloc (arenaLo, arenaHi, 1);
    OSSetArenaLo (arenaLo);
    arenaLo = (void*)(((u32)arenaLo + 0x1F) &amp; 0xFFFFFFE0);
    arenaHi = (void*)((u32)arenaHi &amp; 0xFFFFFFE0);
    OSSetCurrentHeap (OSCreateHeap ((void*)(((u32)arenaLo)), arenaHi));
    OSSetArenaLo ((arenaLo = arenaHi));
}

static void
__DEMOInitGX ()
{
    GXSetViewport (0.0f, 0.0f, rmode-&gt;fbWidth, rmode-&gt;xfbHeight, 0.0f, 1.0f);
    GXSetScissor (0, 0, rmode-&gt;fbWidth, rmode-&gt;efbHeight);
    GXSetDispCopySrc (0, 0, rmode-&gt;fbWidth, rmode-&gt;efbHeight);
    GXSetDispCopyDst (rmode-&gt;fbWidth, rmode-&gt;xfbHeight);
    GXSetDispCopyYScale (((f32)rmode-&gt;xfbHeight / (f32)rmode-&gt;efbHeight));
    GXSetCopyFilter (rmode-&gt;aa, rmode-&gt;sample_pattern, 1, rmode-&gt;vfilter);
    if (rmode-&gt;aa != 0)
    {
        GXSetPixelFmt (2, 0);
    }
    else
    {
        GXSetPixelFmt (0, 0);
    }
    GXCopyDisp (DemoCurrentBuffer, 1);
#if DEBUG
    GXSetVerifyLevel (0);
#endif
    GXSetDispCopyGamma (0);
}

static void
__DEMOInitVI ()
{
    u32 nin;

    VISetNextFrameBuffer (DemoFrameBuffer1);
    DemoCurrentBuffer = DemoFrameBuffer2;
    VIFlush();
    VIWaitForRetrace();
    nin = rmode-&gt;viTVmode &amp; 1;
    if (nin != 0)
    {
        VIWaitForRetrace();
    }
}

static void
__DEMOInitForEmu ()
{
}

void
DEMOBeforeRender ()
{
    if (BypassWorkaround != 0)
    {
        GXSetDrawSync (0xFEEB);
    }
    if (rmode-&gt;field_rendering != 0)
    {
        GXSetViewportJitter (0.0f,
                             0.0f,
                             rmode-&gt;fbWidth,
                             rmode-&gt;xfbHeight,
                             0.0f,
                             1.0f,
                             VIGetNextField());
    }
    else
    {
        GXSetViewport (0.0f, 0.0f, rmode-&gt;fbWidth, rmode-&gt;xfbHeight, 0.0f, 1.0f);
    }
    GXInvalidateVtxCache();
    GXInvalidateTexAll();
}

void
DEMODoneRender ()
{
    if (BypassWorkaround != 0)
    {
        __BypassDoneRender();
        return;
    }
    if (DemoStatEnable != 0)
    {
        GXDrawDone();
        DEMOUpdateStats (1);
        DEMOPrintStats();
        GXDrawDone();
        DEMOUpdateStats (0);
    }
    GXSetZMode (1, 3, 1);
    GXSetColorUpdate (1);
    GXCopyDisp (DemoCurrentBuffer, 1);
    GXDrawDone();
    DEMOSwapBuffers();
}

void
DEMOSwapBuffers ()
{
    VISetNextFrameBuffer (DemoCurrentBuffer);
    if (DemoFirstFrame != 0)
    {
        VISetBlack (0);
        DemoFirstFrame = 0;
    }
    VIFlush();
    VIWaitForRetrace();
    if ((u32)DemoCurrentBuffer == (u32)DemoFrameBuffer1)
    {
        DemoCurrentBuffer = DemoFrameBuffer2;
        return;
    }
    DemoCurrentBuffer = DemoFrameBuffer1;
}

void
DEMOSetTevColorIn (enum _GXTevStageID  stage,
                   enum _GXTevColorArg a,
                   enum _GXTevColorArg b,
                   enum _GXTevColorArg c,
                   enum _GXTevColorArg d)
{
    u32 swap;

    swap = 0;
    if (a == GX_CC_TEXC)
    {
        swap = 0xF;
    }
    else if (a &gt;= GX_CC_TEXRRR)
    {
        swap = a;
        a = GX_CC_TEXC;
    }
    if (b == GX_CC_TEXC)
    {
        swap = 0xF;
    }
    else if (b &gt;= GX_CC_TEXRRR)
    {
        swap = b;
        b = GX_CC_TEXC;
    }
    if (c == GX_CC_TEXC)
    {
        swap = 0xF;
    }
    else if (c &gt;= GX_CC_TEXRRR)
    {
        swap = c;
        c = GX_CC_TEXC;
    }
    if (d == GX_CC_TEXC)
    {
        swap = 0xF;
    }
    else if (d &gt;= GX_CC_TEXRRR)
    {
        swap = d;
        d = GX_CC_TEXC;
    }
    GXSetTevColorIn (stage, a, b, c, d);
    if (swap != 0U)
    {
        GXSetTevSwapMode (stage, 0, swap - 0xF);
    }
}

void
DEMOSetTevOp (enum _GXTevStageID id, enum _GXTevMode mode)
{
    enum _GXTevColorArg carg;
    enum _GXTevAlphaArg aarg;

    carg = GX_CC_RASC;
    aarg = GX_TEVSTAGE5;
    if (id != 0)
    {
        carg = 0;
        aarg = 0;
    }
    switch (mode)
    {
        case 0:
            DEMOSetTevColorIn (id, 0xF, 8, carg, 0xF);
            GXSetTevAlphaIn (id, 7, 4, aarg, 7);
            break;
        case 1:
            DEMOSetTevColorIn (id, carg, 8, 9, 0xF);
            GXSetTevAlphaIn (id, 7, 7, 7, aarg);
            break;
        case 2:
            DEMOSetTevColorIn (id, carg, 0xC, 8, 0xF);
            GXSetTevAlphaIn (id, 7, 4, aarg, 7);
            break;
        case 3:
            DEMOSetTevColorIn (id, 0xF, 0xF, 0xF, 8);
            GXSetTevAlphaIn (id, 7, 7, 7, 4);
            break;
        case 4:
            GXSetTevColorIn (id, 0xF, 0xF, 0xF, carg);
            GXSetTevAlphaIn (id, 7, 7, 7, aarg);
            break;
        default:
            ASSERTMSGLINE (0x367, FALSE, &quot;DEMOSetTevOp: Invalid Tev Mode&quot;);
            break;
    }
    GXSetTevColorOp (id, 0, 0, 0, 1, 0);
    GXSetTevAlphaOp (id, 0, 0, 0, 1, 0);
}

struct _GXRenderModeObj*
DEMOGetRenderModeObj ()
{
    return rmode;
}

u32
DEMOGetCurrentBuffer (void)
{
    return (u32)DemoCurrentBuffer;
}

void
DEMOEnableBypassWorkaround (u32 timeoutFrames)
{
    BypassWorkaround = 1;
    FrameMissThreshold = timeoutFrames;
    VISetPreRetraceCallback (__BypassRetraceCallback);
}

static void
__BypassRetraceCallback ()
{
    FrameCount += 1;
}

static void
__BypassDoneRender ()
{
    int abort;

    abort = 0;
    GXCopyDisp (DemoCurrentBuffer, 1);
    GXSetDrawSync (0xB00B);
    FrameCount = 0U;
    while ((GXReadDrawSync() != 0xB00B) &amp;&amp; (abort == 0))
    {
        if (FrameCount &gt;= FrameMissThreshold)
        {
            OSReport (&quot;---------WARNING : ABORTING FRAME----------\n&quot;);
            abort = 1;
            DEMOReInit (rmode);
        }
    }
    DEMOSwapBuffers();
}

void
DEMOReInit (struct _GXRenderModeObj* mode)
{
    GXFifoObj  tmpobj;
    void*      tmpFifo;
    GXFifoObj* realFifoObj;
    void*      realFifoBase;
    u32        realFifoSize;

    tmpFifo = OSAllocFromHeap (__OSCurrHeap, 0x10000);
    realFifoObj = GXGetCPUFifo();
    realFifoBase = GXGetFifoBase (realFifoObj);
    realFifoSize = GXGetFifoSize (realFifoObj);
    GXAbortFrame();
    GXInitFifoBase (&amp;tmpobj, tmpFifo, 0x10000);
    GXSetCPUFifo (&amp;tmpobj);
    GXSetGPFifo (&amp;tmpobj);
    __DEMOInitRenderMode (mode);
    DefaultFifoObj = GXInit (realFifoBase, realFifoSize);
    __DEMOInitGX();
    VIConfigure (rmode);
    __DEMOInitVI();
    OSFreeToHeap (__OSCurrHeap, tmpFifo);
}

static void
LoadMemInfo ()
{
    void*              arenaHiOld;
    void*              arenaLo;
    void*              arenaHi;
    void*              simMemEnd;
    struct DVDFileInfo fileInfo;
    u32                length;
    u32                transferLength;
    s32                offset;
    u32                i;
    u32                indexMax;
    char*              buf[63];

    struct
    {
        void* start;
        void* end;
    }* memEntry;

    OSReport (&quot;\nNow, try to find memory info file...\n\n&quot;);
    if (!DVDOpen (&quot;/meminfo.bin&quot;, &amp;fileInfo))
    {
        OSReport (
            &quot;\nCan't find memory info file. Use /XXX toolname/ to maximize &quot;
            &quot;available\n&quot;);
        OSReport (&quot;memory space. For now, we only use the first %dMB.\n&quot;,
                  OSGetConsoleSimulatedMemSize() &gt;&gt; 0x14);
        arenaLo = OSGetArenaLo();
        arenaHi = OSGetArenaHi();
        arenaLo = OSInitAlloc (arenaLo, arenaHi, 1);
        OSSetArenaLo (arenaLo);
        arenaLo = (void*)(((u32)arenaLo + 0x1F) &amp; 0xFFFFFFE0);
        arenaHi = (void*)((u32)arenaHi &amp; 0xFFFFFFE0);
        OSSetCurrentHeap (OSCreateHeap ((void*)(((u32)arenaLo)), arenaHi));
        OSSetArenaLo ((arenaLo = arenaHi));
        return;
    }
    memEntry = (void*)((u32)buf + 0x1F &amp; 0xFFFFFFE0);
    arenaHiOld = OSGetArenaHi();
    simMemEnd = OSPhysicalToCached (OSGetConsoleSimulatedMemSize());
    OSSetArenaHi (OSPhysicalToCached (OSGetPhysicalMemSize()));
    arenaLo = OSGetArenaLo();
    arenaHi = OSGetArenaHi();
    arenaLo = OSInitAlloc (arenaLo, arenaHi, 1);
    OSSetArenaLo (arenaLo);
    arenaLo = (void*)(((u32)arenaLo + 0x1F) &amp; 0xFFFFFFE0);
    arenaHi = (void*)((u32)arenaHi &amp; 0xFFFFFFE0);
    OSSetCurrentHeap (OSCreateHeap ((void*)(arenaLo), arenaHi));
    OSSetArenaLo ((arenaLo = arenaHi));
    OSAllocFixed (&amp;arenaHiOld, &amp;simMemEnd);
    length = fileInfo.length;
    offset = 0;
    while (length)
    {
        OSReport (&quot;loop\n&quot;);
        transferLength = (length &lt; 0x20) ? length : 0x20;
        if (DVDReadPrio (&amp;fileInfo, memEntry, (transferLength + 0x1F) &amp; 0xFFFFFFE0, offset, 2) &lt; 0)
        {
            OSPanic (__FILE__, 0x49F, &quot;An error occurred when issuing read to /meminfo.bin\n&quot;);
        }
        indexMax = (transferLength / 8);
        for (i = 0; i &lt; indexMax; i++)
        {
            OSReport (&quot;start: 0x%08x, end: 0x%08x\n&quot;, memEntry[i].start, memEntry[i].end);
            OSAllocFixed (&amp;memEntry[i].start, &amp;memEntry[i].end);
            OSReport (&quot;Removed 0x%08x - 0x%08x from the current heap\n&quot;,
                      memEntry[i].start,
                      (char*)memEntry[i].end - 1);
        }
        length -= transferLength;
        offset += transferLength;
    }
    DVDClose (&amp;fileInfo);
    OSDumpHeap (__OSCurrHeap);
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>