<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File dvdlow.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-dvdlowc">File dvdlow.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_6809de60dbef2d995cf7d874d1fa5b65/"><strong>dvd</strong></a> <strong>&gt;</strong> <a href="../dvdlow_8c/"><strong>dvdlow.c</strong></a></p>
<p><a href="../dvdlow_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/dvd.h&gt;
#include &lt;dolphin/os.h&gt;

#include &quot;../os/OSPrivate.h&quot;
#include &quot;dvd_private.h&quot;

static BOOL            FirstRead              = TRUE;
static u32             LastLength             = 0;
static DVDLowCallback  Callback               = NULL;
static DVDLowCallback  ResetCoverCallback     = NULL;
static volatile OSTime LastResetEnd           = 0;
static vu32            ResetOccurred          = FALSE;
static volatile BOOL   WaitingCoverClose      = FALSE;
static volatile BOOL   Breaking               = FALSE;
static vu32            WorkAroundType         = 0;
static u32             WorkAroundSeekLocation = 0;
static volatile OSTime LastReadFinished       = 0;
static OSTime          LastReadIssued         = 0;
static volatile BOOL   LastCommandWasRead     = FALSE;
static vu32            NextCommandNumber      = 0;

typedef struct
{
    void* addr;
    u32   length;
    u32   offset;
} DVDBuffer;

typedef struct
{
    s32            command;
    void*          address;
    u32            length;
    u32            offset;
    DVDLowCallback callback;
} DVDCommand;

static DVDCommand CommandList[3];
static OSAlarm    AlarmForWA;
static OSAlarm    AlarmForTimeout;
static OSAlarm    AlarmForBreak;
static DVDBuffer  Prev;
static DVDBuffer  Curr;

// prototypes
static void Read (void* address, u32 length, u32 offset, DVDLowCallback callback);
static void SetBreakAlarm (OSTime timeout);

void
__DVDInitWA (void)
{
    NextCommandNumber      = 0;
    CommandList[0].command = -1;
    __DVDLowSetWAType (0, 0);
    OSInitAlarm();
}

static BOOL
ProcessNextCommand (void)
{
    s32 n = (s32)NextCommandNumber;

    ASSERTLINE (310, n &lt; 3);

    if (CommandList[n].command == 1)
    {
        ++NextCommandNumber;
        Read (CommandList[n].address,
              CommandList[n].length,
              CommandList[n].offset,
              CommandList[n].callback);
        return TRUE;
    }
    else if (CommandList[n].command == 2)
    {
        ++NextCommandNumber;
        DVDLowSeek (CommandList[n].offset, CommandList[n].callback);
        return TRUE;
    }

    return FALSE;
}

void
__DVDInterruptHandler (__OSInterrupt interrupt, OSContext* context)
{
#pragma unused(interrupt)
#pragma unused(interrupt)

    DVDLowCallback cb;
    OSContext      exceptionContext;
    u32            cause = 0;
    u32            reg;
    u32            intr;
    u32            mask;

    OSCancelAlarm (&amp;AlarmForTimeout);
    OSCancelAlarm (&amp;AlarmForBreak);
    if (LastCommandWasRead)
    {
        LastReadFinished = __OSGetSystemTime();
        FirstRead        = FALSE;
        Prev.addr        = Curr.addr;
        Prev.length      = Curr.length;
        Prev.offset      = Curr.offset;
    }

    LastCommandWasRead = FALSE;

    reg                = __DIRegs[0];
    mask               = reg &amp; 0x2a;
    intr               = (reg &amp; 0x54) &amp; (mask &lt;&lt; 1);

    if (intr &amp; 0x40)
    {
        cause |= 8;
    }

    if (intr &amp; 0x10)
    {
        cause |= 1;
    }

    if (intr &amp; 4)
    {
        cause |= 2;
    }

    if (cause)
    {
        ResetOccurred = FALSE;
    }

    __DIRegs[0] = intr | mask;

    if (ResetOccurred &amp;&amp; (__OSGetSystemTime() - LastResetEnd) &lt; OSMillisecondsToTicks (200))
    {
        reg  = __DIRegs[1];
        mask = reg &amp; 0x2;
        intr = (reg &amp; 4) &amp; (mask &lt;&lt; 1);
        if (intr &amp; 4)
        {
            if (ResetCoverCallback)
            {
                ResetCoverCallback (4);
            }
            ResetCoverCallback = NULL;
        }

        __DIRegs[1] = __DIRegs[1];
    }
    else if (WaitingCoverClose)
    {
        reg  = __DIRegs[1];
        mask = reg &amp; 2;
        intr = (reg &amp; 4) &amp; (mask &lt;&lt; 1);

        if (intr &amp; 4)
        {
            cause |= 4;
        }

        __DIRegs[1]       = intr | mask;
        WaitingCoverClose = FALSE;
    }
    else
    {
        __DIRegs[1] = 0;
    }

    if ((cause &amp; 8) &amp;&amp; !Breaking)
    {
        cause &amp;= ~8;
    }

    if (cause &amp; 1)
    {
        if (ProcessNextCommand())
        {
            return;
        }
    }
    else
    {
        CommandList[0].command = -1;
        NextCommandNumber      = 0;
    }

    OSClearContext (&amp;exceptionContext);
    OSSetCurrentContext (&amp;exceptionContext);

    if (cause)
    {
        cb       = Callback;
        Callback = NULL;
        if (cb)
        {
            cb (cause);
        }

        Breaking = FALSE;
    }

    OSClearContext (&amp;exceptionContext);
    OSSetCurrentContext (context);
}

static void
AlarmHandler (OSAlarm* alarm, OSContext* context)
{
#pragma unused(alarm)
#pragma unused(context)

    BOOL processed = ProcessNextCommand();

    ASSERTLINE (652, processed);
}

static void
AlarmHandlerForTimeout (OSAlarm* alarm, OSContext* context)
{
#pragma unused(alarm)

    DVDLowCallback cb;
    OSContext      exceptionContext;

    __OSMaskInterrupts (0x400);
    OSClearContext (&amp;exceptionContext);
    OSSetCurrentContext (&amp;exceptionContext);
    cb       = Callback;
    Callback = NULL;
    if (cb)
    {
        cb (0x10);
    }

    OSClearContext (&amp;exceptionContext);
    OSSetCurrentContext (context);
}

static void
SetTimeoutAlarm (OSTime timeout)
{
    OSCreateAlarm (&amp;AlarmForTimeout);
    OSSetAlarm (&amp;AlarmForTimeout, timeout, AlarmHandlerForTimeout);
}

static void
Read (void* address, u32 length, u32 offset, DVDLowCallback callback)
{
    Callback           = callback;

    LastCommandWasRead = TRUE;
    LastReadIssued     = __OSGetSystemTime();

    __DIRegs[2]        = 0xa8000000;
    __DIRegs[3]        = offset / 4;
    __DIRegs[4]        = length;
    __DIRegs[5]        = (u32)address;
    __DIRegs[6]        = length;
    LastLength         = length;
    __DIRegs[7]        = 3;

    if (length &gt; 0xa00000)
    {
        SetTimeoutAlarm (OSSecondsToTicks (20));
    }
    else
    {
        SetTimeoutAlarm (OSSecondsToTicks (10));
    }
}

static BOOL
AudioBufferOn (void)
{
    DVDDiskID* id;

    id = DVDGetCurrentDiskID();
    if (id-&gt;streaming)
    {
        return TRUE;
    }

    return FALSE;
}

static BOOL
HitCache (DVDBuffer* curr, DVDBuffer* prev)
{
    u32 blockNumOfPrevEnd   = (prev-&gt;offset + prev-&gt;length - 1) &gt;&gt; 15;
    u32 blockNumOfCurrStart = (curr-&gt;offset &gt;&gt; 15);
    u32 cacheBlockSize      = (u32)(AudioBufferOn() ? 5 : 15);

    if ((blockNumOfCurrStart &gt; blockNumOfPrevEnd - 2) ||
        (blockNumOfCurrStart &lt; blockNumOfPrevEnd + cacheBlockSize + 3))
    {
        return TRUE;
    }

    return FALSE;
}

static void
DoJustRead (void* addr, u32 length, u32 offset, DVDLowCallback callback)
{
    CommandList[0].command = -1;
    NextCommandNumber      = 0;
    Read (addr, length, offset, callback);
}

static void
SeekTwiceBeforeRead (void* addr, u32 length, u32 offset, DVDLowCallback callback)
{
    u32 newOffset;

    if ((offset &amp; ~0x7FFF) == 0)
    {
        newOffset = 0;
    }
    else
    {
        newOffset = (offset &amp; ~0x7FFF) + WorkAroundSeekLocation;
    }

    CommandList[0].command  = 2;
    CommandList[0].offset   = newOffset;
    CommandList[0].callback = callback;
    CommandList[1].command  = 1;
    CommandList[1].address  = addr;
    CommandList[1].length   = length;
    CommandList[1].offset   = offset;
    CommandList[1].callback = callback;
    CommandList[2].command  = -1;
    NextCommandNumber       = 0;
    DVDLowSeek (newOffset, callback);
}

static void
WaitBeforeRead (void* addr, u32 length, u32 offset, DVDLowCallback callback, OSTime wait)
{
    CommandList[0].command  = 1;
    CommandList[0].address  = addr;
    CommandList[0].length   = length;
    CommandList[0].offset   = offset;
    CommandList[0].callback = callback;
    CommandList[1].command  = -1;
    NextCommandNumber       = 0;
    OSCreateAlarm (&amp;AlarmForWA);
    OSSetAlarm (&amp;AlarmForWA, wait, AlarmHandler);
}

BOOL
DVDLowRead (void* addr, u32 length, u32 offset, DVDLowCallback callback)
{
    u32    blockNumOfPrevEnd;
    u32    blockNumOfCurrStart;
    OSTime diff;

    ASSERTMSGLINE (837,
                   (((u32)addr) &amp; 31) == 0,
                   &quot;DVDLowRead(): address must be aligned with 32 byte boundary.&quot;);
    ASSERTMSGLINE (838, (length &amp; 31) == 0, &quot;DVDLowRead(): length must be a multiple of 32.&quot;);
    ASSERTMSGLINE (839, (offset &amp; 3) == 0, &quot;DVDLowRead(): offset must be a multiple of 4.&quot;);
    ASSERTMSGLINE (841, length != 0, &quot;DVD read: 0 was specified to length of the readÂ¥n&quot;);

    __DIRegs[6] = length;
    Curr.addr   = addr;
    Curr.length = length;
    Curr.offset = offset;

    if (WorkAroundType == 0)
    {
        DoJustRead (addr, length, offset, callback);
    }
    else if (WorkAroundType == 1)
    {
        if (FirstRead)
        {
            SeekTwiceBeforeRead (addr, length, offset, callback);
        }
        else
        {
            if (!HitCache (&amp;Curr, &amp;Prev))
            {
                DoJustRead (addr, length, offset, callback);
            }
            else
            {
                blockNumOfPrevEnd   = (u32)((Prev.offset + Prev.length - 1) &gt;&gt; 15) &amp; 0x1FFFF;
                blockNumOfCurrStart = (u32)((Curr.offset &gt;&gt; 15) &amp; 0x1FFFF);
                if (blockNumOfPrevEnd == blockNumOfCurrStart ||
                    blockNumOfPrevEnd + 1 == blockNumOfCurrStart)
                {
                    diff = __OSGetSystemTime() - LastReadFinished;
                    if (OSMillisecondsToTicks (5) &lt; diff)
                    {
                        DoJustRead (addr, length, offset, callback);
                    }
                    else
                    {
                        WaitBeforeRead (addr,
                                        length,
                                        offset,
                                        callback,
                                        OSMillisecondsToTicks (5) - diff +
                                            OSMicrosecondsToTicks (500));
                    }
                }
                else
                {
                    SeekTwiceBeforeRead (addr, length, offset, callback);
                }
            }
        }
    }
    else
    {
        ASSERTLINE (900, FALSE);
    }

    return TRUE;
}

BOOL
DVDLowSeek (u32 offset, DVDLowCallback callback)
{
    ASSERTMSGLINE (920, (offset &amp; 3) == 0, &quot;DVDLowSeek(): offset must be a multiple of 4.&quot;);

    Callback    = callback;

    __DIRegs[2] = 0xab000000;
    __DIRegs[3] = offset / 4;
    __DIRegs[7] = 1;
    SetTimeoutAlarm (OSSecondsToTicks (10));
    return TRUE;
}

BOOL
DVDLowWaitCoverClose (DVDLowCallback callback)
{
    Callback          = callback;
    WaitingCoverClose = TRUE;

    __DIRegs[1]       = 2;

    return TRUE;
}

BOOL
DVDLowReadDiskID (DVDDiskID* diskID, DVDLowCallback callback)
{
    ASSERTMSGLINE (986,
                   (((u32)diskID) &amp; 31) == 0,
                   &quot;DVDLowReadID(): id must be aligned with 32 byte boundary.&quot;);

    Callback    = callback;

    __DIRegs[2] = 0xa8000040;
    __DIRegs[3] = 0;
    __DIRegs[4] = sizeof (DVDDiskID);
    __DIRegs[5] = (u32)diskID;
    __DIRegs[6] = sizeof (DVDDiskID);
    __DIRegs[7] = 3;
    SetTimeoutAlarm (OSSecondsToTicks (10));

    return TRUE;
}

BOOL
DVDLowStopMotor (DVDLowCallback callback)
{
    Callback    = callback;

    __DIRegs[2] = 0xe3000000;
    __DIRegs[7] = 1;
    SetTimeoutAlarm (OSSecondsToTicks (10));

    return TRUE;
}

BOOL
DVDLowRequestError (DVDLowCallback callback)
{
    Callback    = callback;

    __DIRegs[2] = 0xe0000000;
    __DIRegs[7] = 1;
    SetTimeoutAlarm (OSSecondsToTicks (10));

    return TRUE;
}

BOOL
DVDLowInquiry (DVDDriveInfo* info, DVDLowCallback callback)
{
    Callback    = callback;
    __DIRegs[2] = 0x12000000;
    __DIRegs[4] = sizeof (DVDDriveInfo);
    __DIRegs[5] = (u32)info;
    __DIRegs[6] = sizeof (DVDDriveInfo);
    __DIRegs[7] = 3;
    SetTimeoutAlarm (OSSecondsToTicks (10));

    return TRUE;
}

BOOL
DVDLowAudioStream (u32 subcmd, u32 length, u32 offset, DVDLowCallback callback)
{
    Callback    = callback;
    __DIRegs[2] = subcmd | 0xe1000000;
    __DIRegs[3] = offset &gt;&gt; 2;
    __DIRegs[4] = length;
    __DIRegs[7] = 1;
    SetTimeoutAlarm (OSSecondsToTicks (10));

    return TRUE;
}

BOOL
DVDLowRequestAudioStatus (u32 subcmd, DVDLowCallback callback)
{
    Callback    = callback;
    __DIRegs[2] = subcmd | 0xe2000000;
    __DIRegs[7] = 1;
    SetTimeoutAlarm (OSSecondsToTicks (10));

    return TRUE;
}

BOOL
DVDLowAudioBufferConfig (BOOL enable, u32 size, DVDLowCallback callback)
{
#ifdef DEBUG
    u32 bufSize;
    u32 trigger;
#endif

    Callback = callback;

#ifdef DEBUG
    bufSize = size &amp; 0xF;
    trigger = (size &gt;&gt; 4) &amp; 0xF;
    ASSERTLINE (1242, bufSize &lt; 16);
    ASSERTLINE (1243, trigger &lt;= 2);
#endif

    __DIRegs[2] = 0xe4000000 | (enable != 0 ? 0x10000 : 0) | size;
    __DIRegs[7] = 1;
    SetTimeoutAlarm (OSSecondsToTicks (10));

    return TRUE;
}

void
DVDLowReset (void)
{
    u32    reg;
    OSTime resetStart;

    __DIRegs[1] = 2;
    reg         = __PIRegs[9];
    __PIRegs[9] = (reg &amp; ~4) | 1;

    resetStart  = __OSGetSystemTime();
    while ((__OSGetSystemTime() - resetStart) &lt; OSMicrosecondsToTicks (12)) {}

    __PIRegs[9]   = reg | 4 | 1;
    ResetOccurred = TRUE;
    LastResetEnd  = __OSGetSystemTime();
}

DVDLowCallback
DVDLowSetResetCoverCallback (DVDLowCallback callback)
{
    DVDLowCallback old;
    BOOL           enabled;

    enabled            = OSDisableInterrupts();
    old                = ResetCoverCallback;
    ResetCoverCallback = callback;
    OSRestoreInterrupts (enabled);

    return old;
}

static void
DoBreak (void)
{
    u32 statusReg;

    statusReg    = __DIRegs[0];
    statusReg   |= 0x40 | 1;
    __DIRegs[0]  = statusReg;
    Breaking     = TRUE;
}

static void
AlarmHandlerForBreak (OSAlarm* alarm, OSContext* context)
{
#pragma unused(alarm)
#pragma unused(context)

    if (__DIRegs[6] &lt; LastLength)
    {
        DoBreak();
    }
    else
    {
        SetBreakAlarm (OSMillisecondsToTicks (20));
    }
}

static void
SetBreakAlarm (OSTime timeout)
{
    OSCreateAlarm (&amp;AlarmForBreak);
    OSSetAlarm (&amp;AlarmForBreak, timeout, AlarmHandlerForBreak);
}

BOOL
DVDLowBreak (void)
{
    AlarmHandlerForBreak ((OSAlarm*)NULL, (OSContext*)NULL);

    return TRUE;
}

DVDLowCallback
DVDLowClearCallback (void)
{
    DVDLowCallback old;

    __DIRegs[1] = 0;
    old         = Callback;
    Callback    = NULL;

    return old;
}

u32
DVDLowGetCoverStatus (void)
{
    if ((__OSGetSystemTime() - LastResetEnd) &lt; OSMillisecondsToTicks (100))
    {
        return FALSE;
    }

    if (__DIRegs[1] &amp; 1)
    {
        return TRUE;
    }

    return 2;
}

void
__DVDLowSetWAType (u32 type, s32 seekLoc)
{
    BOOL enabled;

    enabled = OSDisableInterrupts();
    ASSERTLINE (1491, type &lt; DVD_WATYPE_MAX);
    WorkAroundType         = type;
    WorkAroundSeekLocation = (u32)seekLoc;
    OSRestoreInterrupts (enabled);
}

BOOL
__DVDLowTestAlarm (const OSAlarm* alarm)
{
    if (alarm == &amp;AlarmForBreak)
    {
        return TRUE;
    }
    if (alarm == &amp;AlarmForTimeout)
    {
        return TRUE;
    }

    return FALSE;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>