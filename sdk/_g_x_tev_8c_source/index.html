<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File GXTev.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-gxtevc">File GXTev.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_b80c028b3e970eff7f2a07684ffcf104/"><strong>gx</strong></a> <strong>&gt;</strong> <a href="../_g_x_tev_8c/"><strong>GXTev.c</strong></a></p>
<p><a href="../_g_x_tev_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/gx.h&gt;
#include &lt;dolphin/os.h&gt;
#include &lt;macros.h&gt;

#include &quot;GXPrivate.h&quot;

void
GXSetTevOp (GXTevStageID id, GXTevMode mode)
{
    GXTevColorArg carg = GX_CC_RASC;
    GXTevAlphaArg aarg = GX_CA_RASA;

    CHECK_GXBEGIN (0x72, &quot;GXSetTevOp&quot;);

    if (id != GX_TEVSTAGE0)
    {
        carg = GX_CC_CPREV;
        aarg = GX_CA_APREV;
    }

    switch (mode)
    {
        case GX_MODULATE:
            GXSetTevColorIn (id, GX_CC_ZERO, GX_CC_TEXC, carg, GX_CC_ZERO);
            GXSetTevAlphaIn (id, GX_CA_ZERO, GX_CA_TEXA, aarg, GX_CA_ZERO);
            break;
        case GX_DECAL:
            GXSetTevColorIn (id, carg, GX_CC_TEXC, GX_CC_TEXA, GX_CC_ZERO);
            GXSetTevAlphaIn (id, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, aarg);
            break;
        case GX_BLEND:
            GXSetTevColorIn (id, carg, GX_CC_ONE, GX_CC_TEXC, GX_CC_ZERO);
            GXSetTevAlphaIn (id, GX_CA_ZERO, GX_CA_TEXA, aarg, GX_CA_ZERO);
            break;
        case GX_REPLACE:
            GXSetTevColorIn (id, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_TEXC);
            GXSetTevAlphaIn (id, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_TEXA);
            break;
        case GX_PASSCLR:
            GXSetTevColorIn (id, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, carg);
            GXSetTevAlphaIn (id, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, aarg);
            break;
        default:
            ASSERTMSGLINE (0x8F, 0, &quot;GXSetTevOp: Invalid Tev Mode&quot;);
    }
    GXSetTevColorOp (id, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaOp (id, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
}

void
GXSetTevColorIn (GXTevStageID  stage,
                 GXTevColorArg a,
                 GXTevColorArg b,
                 GXTevColorArg c,
                 GXTevColorArg d)
{
    u32* pTevReg;

    CHECK_GXBEGIN (0xE5, &quot;GXSetTevColorIn&quot;);
    ASSERTMSGLINE (0xE6, stage &lt; 16, &quot;GXSetTevColor: Invalid Tev Stage Index&quot;);
    ASSERTMSGLINE (0xE7, a &lt;= 15, &quot;GXSetTev*In: A/B/C/D argument out of range&quot;);
    ASSERTMSGLINE (0xE8, b &lt;= 15, &quot;GXSetTev*In: A/B/C/D argument out of range&quot;);
    ASSERTMSGLINE (0xE9, c &lt;= 15, &quot;GXSetTev*In: A/B/C/D argument out of range&quot;);
    ASSERTMSGLINE (0xEA, d &lt;= 15, &quot;GXSetTev*In: A/B/C/D argument out of range&quot;);

    pTevReg = &amp;__GXData-&gt;tevc[stage];
    SET_REG_FIELD (0xED, *pTevReg, 4, 12, a);
    SET_REG_FIELD (0xEE, *pTevReg, 4, 8, b);
    SET_REG_FIELD (0xEF, *pTevReg, 4, 4, c);
    SET_REG_FIELD (0xF0, *pTevReg, 4, 0, d);

    GX_WRITE_RAS_REG (*pTevReg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevAlphaIn (GXTevStageID  stage,
                 GXTevAlphaArg a,
                 GXTevAlphaArg b,
                 GXTevAlphaArg c,
                 GXTevAlphaArg d)
{
    u32* pTevReg;

    CHECK_GXBEGIN (0x108, &quot;GXSetTevAlphaIn&quot;);
    ASSERTMSGLINE (0x109, stage &lt; 16, &quot;GXSetTevAlpha: Invalid Tev Stage Index&quot;);
    ASSERTMSGLINE (0x10A, a &lt;= 7, &quot;GXSetTev*In: A/B/C/D argument out of range&quot;);
    ASSERTMSGLINE (0x10B, b &lt;= 7, &quot;GXSetTev*In: A/B/C/D argument out of range&quot;);
    ASSERTMSGLINE (0x10C, c &lt;= 7, &quot;GXSetTev*In: A/B/C/D argument out of range&quot;);
    ASSERTMSGLINE (0x10D, d &lt;= 7, &quot;GXSetTev*In: A/B/C/D argument out of range&quot;);

    pTevReg = &amp;__GXData-&gt;teva[stage];
    SET_REG_FIELD (0x110, *pTevReg, 3, 13, a);
    SET_REG_FIELD (0x111, *pTevReg, 3, 10, b);
    SET_REG_FIELD (0x112, *pTevReg, 3, 7, c);
    SET_REG_FIELD (0x113, *pTevReg, 3, 4, d);

    GX_WRITE_RAS_REG (*pTevReg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevColorOp (GXTevStageID stage,
                 GXTevOp      op,
                 GXTevBias    bias,
                 GXTevScale   scale,
                 GXBool       clamp,
                 GXTevRegID   out_reg)
{
    u32* pTevReg;

    CHECK_GXBEGIN (0x12E, &quot;GXSetTevColorOp&quot;);
    ASSERTMSGLINE (0x12F, stage &lt; 16, &quot;GXSetTevColor: Invalid Tev Stage Index&quot;);

    pTevReg = &amp;__GXData-&gt;tevc[stage];
    SET_REG_FIELD (0x137, *pTevReg, 1, 18, op &amp; 1);
    if (op &lt;= 1)
    {
        SET_REG_FIELD (0x139, *pTevReg, 2, 20, scale);
        SET_REG_FIELD (0x13A, *pTevReg, 2, 16, bias);
    }
    else
    {
        SET_REG_FIELD (0x13C, *pTevReg, 2, 20, (op &gt;&gt; 1) &amp; 3);
        SET_REG_FIELD (0x13D, *pTevReg, 2, 16, 3);
    }
    SET_REG_FIELD (0x140, *pTevReg, 1, 19, clamp &amp; 0xFF);
    SET_REG_FIELD (0x141, *pTevReg, 2, 22, out_reg);

    GX_WRITE_RAS_REG (*pTevReg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevAlphaOp (GXTevStageID stage,
                 GXTevOp      op,
                 GXTevBias    bias,
                 GXTevScale   scale,
                 GXBool       clamp,
                 GXTevRegID   out_reg)
{
    u32* pTevReg;

    CHECK_GXBEGIN (0x15A, &quot;GXSetTevAlphaOp&quot;);
    ASSERTMSGLINE (0x15B, stage &lt; 16, &quot;GXSetTevAlpha: Invalid Tev Stage Index&quot;);

    pTevReg = &amp;__GXData-&gt;teva[stage];
    SET_REG_FIELD (0x163, *pTevReg, 1, 18, op &amp; 1);
    if (op &lt;= 1)
    {
        SET_REG_FIELD (0x165, *pTevReg, 2, 20, scale);
        SET_REG_FIELD (0x166, *pTevReg, 2, 16, bias);
    }
    else
    {
        SET_REG_FIELD (0x168, *pTevReg, 2, 20, (op &gt;&gt; 1) &amp; 3);
        SET_REG_FIELD (0x169, *pTevReg, 2, 16, 3);
    }
    SET_REG_FIELD (0x16C, *pTevReg, 1, 19, clamp &amp; 0xFF);
    SET_REG_FIELD (0x16D, *pTevReg, 2, 22, out_reg);

    GX_WRITE_RAS_REG (*pTevReg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevColor (GXTevRegID id, GXColor color)
{
    u32 regRA;
    u32 regBG;

    CHECK_GXBEGIN (0x182, &quot;GXSetTevColor&quot;);

    regRA = 0;
    SET_REG_FIELD (0x185, regRA, 11, 0, color.r);
    SET_REG_FIELD (0x186, regRA, 11, 12, color.a);
    SET_REG_FIELD (0x187, regRA, 8, 24, 224 + id * 2);

    regBG = 0;
    SET_REG_FIELD (0x18A, regBG, 11, 0, color.b);
    SET_REG_FIELD (0x18B, regBG, 11, 12, color.g);
    SET_REG_FIELD (0x18C, regBG, 8, 24, 225 + id * 2);

    GX_WRITE_RAS_REG (regRA);
    GX_WRITE_RAS_REG (regBG);
    GX_WRITE_RAS_REG (regBG);
    GX_WRITE_RAS_REG (regBG);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevColorS10 (GXTevRegID id, GXColorS10 color)
{
    u32 regRA;
    u32 regBG;

    ASSERTMSGLINE (0x1A7,
                   color.r &gt;= -1024 &amp;&amp; color.r &lt; 1024,
                   &quot;GXSetTevColorS10: Color not in range -1024 to +1023&quot;);
    ASSERTMSGLINE (0x1A8,
                   color.g &gt;= -1024 &amp;&amp; color.g &lt; 1024,
                   &quot;GXSetTevColorS10: Color not in range -1024 to +1023&quot;);
    ASSERTMSGLINE (0x1A9,
                   color.b &gt;= -1024 &amp;&amp; color.b &lt; 1024,
                   &quot;GXSetTevColorS10: Color not in range -1024 to +1023&quot;);
    ASSERTMSGLINE (0x1AA,
                   color.a &gt;= -1024 &amp;&amp; color.a &lt; 1024,
                   &quot;GXSetTevColorS10: Color not in range -1024 to +1023&quot;);

    CHECK_GXBEGIN (0x1AC, &quot;GXSetTevColorS10&quot;);

    regRA = 0;
    SET_REG_FIELD (0x1AF, regRA, 11, 0, color.r &amp; 0x7FF);
    SET_REG_FIELD (0x1B0, regRA, 11, 12, color.a &amp; 0x7FF);
    SET_REG_FIELD (0x1B1, regRA, 8, 24, 224 + id * 2);

    regBG = 0;
    SET_REG_FIELD (0x1B4, regBG, 11, 0, color.b &amp; 0x7FF);
    SET_REG_FIELD (0x1B5, regBG, 11, 12, color.g &amp; 0x7FF);
    SET_REG_FIELD (0x1B6, regBG, 8, 24, 225 + id * 2);

    GX_WRITE_RAS_REG (regRA);
    GX_WRITE_RAS_REG (regBG);
    GX_WRITE_RAS_REG (regBG);
    GX_WRITE_RAS_REG (regBG);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevKColor (GXTevKColorID id, GXColor color)
{
    u32 regRA;
    u32 regBG;

    CHECK_GXBEGIN (0x1DD, &quot;GXSetTevKColor&quot;);

    regRA = 0;
    SET_REG_FIELD (0x1E0, regRA, 8, 0, color.r);
    SET_REG_FIELD (0x1E1, regRA, 8, 12, color.a);
    SET_REG_FIELD (0x1E2, regRA, 4, 20, 8);
    SET_REG_FIELD (0x1E3, regRA, 8, 24, 224 + id * 2);

    regBG = 0;
    SET_REG_FIELD (0x1E6, regBG, 8, 0, color.b);
    SET_REG_FIELD (0x1E7, regBG, 8, 12, color.g);
    SET_REG_FIELD (0x1E8, regBG, 4, 20, 8);
    SET_REG_FIELD (0x1E9, regBG, 8, 24, 225 + id * 2);

    GX_WRITE_RAS_REG (regRA);
    GX_WRITE_RAS_REG (regBG);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevKColorSel (GXTevStageID stage, GXTevKColorSel sel)
{
    u32* Kreg;

    CHECK_GXBEGIN (0x204, &quot;GXSetTevKColorSel&quot;);
    ASSERTMSGLINE (0x205, stage &lt; 16, &quot;GXSetTevKColor*: Invalid Tev Stage Index&quot;);

    Kreg = &amp;__GXData-&gt;tevKsel[stage &gt;&gt; 1];
    if (stage &amp; 1)
    {
        SET_REG_FIELD (0x20A, *Kreg, 5, 14, sel);
    }
    else
    {
        SET_REG_FIELD (0x20C, *Kreg, 5, 4, sel);
    }

    GX_WRITE_RAS_REG (*Kreg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevKAlphaSel (GXTevStageID stage, GXTevKAlphaSel sel)
{
    u32* Kreg;

    CHECK_GXBEGIN (0x225, &quot;GXSetTevKAlphaSel&quot;);
    ASSERTMSGLINE (0x226, stage &lt; 16, &quot;GXSetTevKColor*: Invalid Tev Stage Index&quot;);

    Kreg = &amp;__GXData-&gt;tevKsel[stage &gt;&gt; 1];
    if (stage &amp; 1)
    {
        SET_REG_FIELD (0x22B, *Kreg, 5, 19, sel);
    }
    else
    {
        SET_REG_FIELD (0x22D, *Kreg, 5, 9, sel);
    }

    GX_WRITE_RAS_REG (*Kreg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevSwapMode (GXTevStageID stage, GXTevSwapSel ras_sel, GXTevSwapSel tex_sel)
{
    u32* pTevReg;

    CHECK_GXBEGIN (0x24A, &quot;GXSetTevSwapMode&quot;);
    ASSERTMSGLINE (0x24B, stage &lt; 16, &quot;GXSetTevSwapMode: Invalid Tev Stage Index&quot;);

    pTevReg = &amp;__GXData-&gt;teva[stage];
    SET_REG_FIELD (0x24E, *pTevReg, 2, 0, ras_sel);
    SET_REG_FIELD (0x24F, *pTevReg, 2, 2, tex_sel);

    GX_WRITE_RAS_REG (*pTevReg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevSwapModeTable (GXTevSwapSel   table,
                       GXTevColorChan red,
                       GXTevColorChan green,
                       GXTevColorChan blue,
                       GXTevColorChan alpha)
{
    u32* Kreg;

    CHECK_GXBEGIN (0x26E, &quot;GXSetTevSwapModeTable&quot;);
    ASSERTMSGLINE (0x26F, table &lt; 4, &quot;GXSetTevSwapModeTable: Invalid Swap Selection Index&quot;);

    Kreg = &amp;__GXData-&gt;tevKsel[table &lt;&lt; 1];
    SET_REG_FIELD (0x272, *Kreg, 2, 0, red);
    SET_REG_FIELD (0x273, *Kreg, 2, 2, green);

    GX_WRITE_RAS_REG (*Kreg);

    Kreg = &amp;__GXData-&gt;tevKsel[(table &lt;&lt; 1) + 1];
    SET_REG_FIELD (0x277, *Kreg, 2, 0, blue);
    SET_REG_FIELD (0x278, *Kreg, 2, 2, alpha);

    GX_WRITE_RAS_REG (*Kreg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevClampMode (void)
{
    ASSERTMSGLINE (0x290, 0, &quot;GXSetTevClampMode: not available on this hardware&quot;);
}

void
GXSetAlphaCompare (GXCompare comp0, u8 ref0, GXAlphaOp op, GXCompare comp1, u8 ref1)
{
    u32 reg = 0;

    CHECK_GXBEGIN (0x2B2, &quot;GXSetAlphaCompare&quot;);

    SET_REG_FIELD (0x2B4, reg, 8, 0, ref0);
    SET_REG_FIELD (0x2B5, reg, 8, 8, ref1);
    SET_REG_FIELD (0x2B6, reg, 3, 16, comp0);
    SET_REG_FIELD (0x2B7, reg, 3, 19, comp1);
    SET_REG_FIELD (0x2B8, reg, 2, 22, op);
    SET_REG_FIELD (0x2B9, reg, 8, 24, 0xF3);

    GX_WRITE_RAS_REG (reg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetZTexture (GXZTexOp op, GXTexFmt fmt, u32 bias)
{
    u32 zenv0;
    u32 zenv1;
    u32 type;

    CHECK_GXBEGIN (0x2D1, &quot;GXSetZTexture&quot;);

    zenv0 = 0;
    SET_REG_FIELD (0x2D4, zenv0, 24, 0, bias);
    SET_REG_FIELD (0x2D5, zenv0, 8, 24, 0xF4);

    zenv1 = 0;
    switch (fmt)
    {
        case GX_TF_Z8:
            type = 0;
            break;
        case GX_TF_Z16:
            type = 1;
            break;
        case GX_TF_Z24X8:
            type = 2;
            break;
        default:
            ASSERTMSGLINE (0x2DD, 0, &quot;GXSetZTexture: Invalid z-texture format&quot;);
            type = 2;
            break;
    }
    SET_REG_FIELD (0x2E0, zenv1, 2, 0, type);
    SET_REG_FIELD (0x2E1, zenv1, 2, 2, op);
    SET_REG_FIELD (0x2E2, zenv1, 8, 24, 0xF5);

    GX_WRITE_RAS_REG (zenv0);
    GX_WRITE_RAS_REG (zenv1);
    __GXData-&gt;bpSent = 1;
}

void
GXSetTevOrder (GXTevStageID stage, GXTexCoordID coord, GXTexMapID map, GXChannelID color)
{
    u32*       ptref;
    u32        tmap;
    u32        tcoord;
    static int c2r[] = { 0, 1, 0, 1, 0, 1, 7, 5, 6 };

    CHECK_GXBEGIN (0x307, &quot;GXSetTevOrder&quot;);
    ASSERTMSGLINE (0x308, stage &lt; 16, &quot;GXSetTevColor: Invalid Tev Stage Index&quot;);

    ptref                     = &amp;__GXData-&gt;tref[stage / 2];
    __GXData-&gt;texmapId[stage] = map;

    tmap                      = (u32)(map &amp; ~0x100);
    tmap                      = (tmap &gt;= GX_MAX_TEXMAP) ? GX_TEXMAP0 : tmap;
    tcoord                    = (coord &gt;= GX_MAX_TEXCOORD) ? GX_TEXCOORD0 : coord;

    if (stage &amp; 1)
    {
        SET_REG_FIELD (0x314, *ptref, 3, 12, tmap);
        SET_REG_FIELD (0x315, *ptref, 3, 15, tcoord);
        SET_REG_FIELD (0x317, *ptref, 3, 19, (color == GX_COLOR_NULL) ? 7 : c2r[color]);
        SET_REG_FIELD (0x319, *ptref, 1, 18, (map != GX_TEXMAP_NULL &amp;&amp; !(map &amp; 0x100)));
    }
    else
    {
        SET_REG_FIELD (0x31C, *ptref, 3, 0, tmap);
        SET_REG_FIELD (0x31D, *ptref, 3, 3, tcoord);
        SET_REG_FIELD (0x31F, *ptref, 3, 7, (color == GX_COLOR_NULL) ? 7 : c2r[color]);
        SET_REG_FIELD (0x321, *ptref, 1, 6, (map != GX_TEXMAP_NULL &amp;&amp; !(map &amp; 0x100)));
    }

    GX_WRITE_RAS_REG (*ptref);
    __GXData-&gt;bpSent      = 1;
    __GXData-&gt;dirtyState |= 1;
}

void
GXSetNumTevStages (u8 nStages)
{
    CHECK_GXBEGIN (0x331, &quot;GXSetNumTevStages&quot;);

    ASSERTMSGLINE (0x333,
                   nStages != 0 &amp;&amp; nStages &lt;= 16,
                   &quot;GXSetNumTevStages: Exceed max number of tex stages&quot;);
    SET_REG_FIELD (0x334, __GXData-&gt;genMode, 4, 10, nStages - 1);
    __GXData-&gt;dirtyState |= 4;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>