<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File GXFifo.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-gxfifoc">File GXFifo.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_b80c028b3e970eff7f2a07684ffcf104/"><strong>gx</strong></a> <strong>&gt;</strong> <a href="../_g_x_fifo_8c/"><strong>GXFifo.c</strong></a></p>
<p><a href="../_g_x_fifo_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/base/PPCArch.h&gt;
#include &lt;dolphin/gx.h&gt;
#include &lt;dolphin/os.h&gt;

#include &lt;stddef.h&gt;

#include &quot;GXPrivate.h&quot;

static OSThread*         __GXCurrentThread;
static GXBool            CPGPLinked;
static BOOL              GXOverflowSuspendInProgress;
static GXBreakPtCallback BreakPointCB;
static u32               __GXOverflowCount;
#if DEBUG
static int IsWGPipeRedirected;
#endif

__GXFifoObj* CPUFifo;
__GXFifoObj* GPFifo;
void*        __GXCurrentBP;

static void __GXFifoReadEnable (void);
static void __GXFifoReadDisable (void);
static void __GXFifoLink (u8 arg0);
static void __GXWriteFifoIntEnable (u8 arg0, u8 arg1);
static void __GXWriteFifoIntReset (u8 arg0, u8 arg1);

#if DEBUG
static s8 __data_0[] = &quot;[GXOverflowHandler]&quot;;
#endif

static void
GXOverflowHandler (s16 interrupt, OSContext* context)
{
#pragma unused(interrupt)
#pragma unused(context)

#if DEBUG
    if (__gxVerif-&gt;verifyLevel &gt; 1)
    {
        OSReport (__data_0);
    }
#endif
    ASSERTLINE (0x15A, !GXOverflowSuspendInProgress);

    __GXOverflowCount++;
    __GXWriteFifoIntEnable (0, 1);
    __GXWriteFifoIntReset (1, 0);
    GXOverflowSuspendInProgress = TRUE;

#if DEBUG
    if (__gxVerif-&gt;verifyLevel &gt; 1)
    {
        OSReport (&quot;[GXOverflowHandler Sleeping]&quot;);
    }
#endif
    OSSuspendThread (__GXCurrentThread);
}

static void
GXUnderflowHandler (s16 interrupt, OSContext* context)
{
#pragma unused(interrupt)
#pragma unused(context)

#if DEBUG
    if (__gxVerif-&gt;verifyLevel &gt; 1)
    {
        OSReport (&quot;[GXUnderflowHandler]&quot;);
    }
#endif
    ASSERTLINE (0x184, GXOverflowSuspendInProgress);

    OSResumeThread (__GXCurrentThread);
    GXOverflowSuspendInProgress = FALSE;
    __GXWriteFifoIntReset (1U, 1U);
    __GXWriteFifoIntEnable (1U, 0U);
}

static void
GXBreakPointHandler (s16 interrupt, OSContext* context)
{
#pragma unused(interrupt)

    OSContext exceptionContext;

    __GXData-&gt;cpEnable = __GXData-&gt;cpEnable &amp; 0xFFFFFFDF;
    GX_SET_CP_REG (1, __GXData-&gt;cpEnable);
    if (BreakPointCB != NULL)
    {
        OSClearContext (&amp;exceptionContext);
        OSSetCurrentContext (&amp;exceptionContext);
        BreakPointCB();
        OSClearContext (&amp;exceptionContext);
        OSSetCurrentContext (context);
    }
}

static void
GXCPInterruptHandler (s16 interrupt, OSContext* context)
{
    __GXData-&gt;cpStatus = GX_GET_CP_REG (0);
    if (GET_REG_FIELD (__GXData-&gt;cpEnable, 1, 3) &amp;&amp; GET_REG_FIELD (__GXData-&gt;cpStatus, 1, 1))
    {
        GXUnderflowHandler (interrupt, context);
    }
    if (GET_REG_FIELD (__GXData-&gt;cpEnable, 1, 2) &amp;&amp; GET_REG_FIELD (__GXData-&gt;cpStatus, 1, 0))
    {
        GXOverflowHandler (interrupt, context);
    }
    if (GET_REG_FIELD (__GXData-&gt;cpEnable, 1, 5) &amp;&amp; GET_REG_FIELD (__GXData-&gt;cpStatus, 1, 4))
    {
        GXBreakPointHandler (interrupt, context);
    }
}

void
GXInitFifoBase (GXFifoObj* fifo, void* base, u32 size)
{
    __GXFifoObj* realFifo = (__GXFifoObj*)fifo;

    ASSERTMSGLINE (0x1FF, realFifo != CPUFifo, &quot;GXInitFifoBase: fifo is attached to CPU&quot;);
    ASSERTMSGLINE (0x201, realFifo != GPFifo, &quot;GXInitFifoBase: fifo is attached to GP&quot;);
    ASSERTMSGLINE (0x203, ((u32)base &amp; 0x1F) == 0, &quot;GXInitFifoBase: base must be 32B aligned&quot;);
    ASSERTMSGLINE (0x205, base != NULL, &quot;GXInitFifoBase: base pointer is NULL&quot;);
    ASSERTMSGLINE (0x207, (size &amp; 0x1F) == 0, &quot;GXInitFifoBase: size must be 32B aligned&quot;);
    ASSERTMSGLINE (0x209, size &gt;= 0x10000, &quot;GXInitFifoBase: fifo is not large enough&quot;);

    realFifo-&gt;base  = base;
    realFifo-&gt;top   = (u8*)base + size - 4;
    realFifo-&gt;size  = size;
    realFifo-&gt;count = 0;
    GXInitFifoLimits (fifo, size - 0x4000, (size &gt;&gt; 1) &amp; ~0x1F);
    GXInitFifoPtrs (fifo, base, base);
}

void
GXInitFifoPtrs (GXFifoObj* fifo, void* readPtr, void* writePtr)
{
    __GXFifoObj* realFifo = (__GXFifoObj*)fifo;
    BOOL         enabled;

    ASSERTMSGLINE (0x231, realFifo != CPUFifo, &quot;GXInitFifoPtrs: fifo is attached to CPU&quot;);
    ASSERTMSGLINE (0x233, realFifo != GPFifo, &quot;GXInitFifoPtrs: fifo is attached to GP&quot;);
    ASSERTMSGLINE (0x235,
                   ((u32)readPtr &amp; 0x1F) == 0,
                   &quot;GXInitFifoPtrs: readPtr not 32B aligned&quot;);
    ASSERTMSGLINE (0x237,
                   ((u32)writePtr &amp; 0x1F) == 0,
                   &quot;GXInitFifoPtrs: writePtr not 32B aligned&quot;);
    ASSERTMSGLINE (0x23A,
                   realFifo-&gt;base &lt;= readPtr &amp;&amp; readPtr &lt; realFifo-&gt;top,
                   &quot;GXInitFifoPtrs: readPtr not in fifo range&quot;);
    ASSERTMSGLINE (0x23D,
                   realFifo-&gt;base &lt;= writePtr &amp;&amp; writePtr &lt; realFifo-&gt;top,
                   &quot;GXInitFifoPtrs: writePtr not in fifo range&quot;);

    enabled         = OSDisableInterrupts();
    realFifo-&gt;rdPtr = readPtr;
    realFifo-&gt;wrPtr = writePtr;
    realFifo-&gt;count = (u8*)writePtr - (u8*)readPtr;
    if (realFifo-&gt;count &lt; 0)
    {
        realFifo-&gt;count += realFifo-&gt;size;
    }

    OSRestoreInterrupts (enabled);
}

void
GXInitFifoLimits (GXFifoObj* fifo, u32 hiWatermark, u32 loWatermark)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;

    ASSERTMSGLINE (0x262, realFifo != GPFifo, &quot;GXInitFifoLimits: fifo is attached to GP&quot;);
    ASSERTMSGLINE (0x264,
                   (hiWatermark &amp; 0x1F) == 0,
                   &quot;GXInitFifoLimits: hiWatermark not 32B aligned&quot;);
    ASSERTMSGLINE (0x266,
                   (loWatermark &amp; 0x1F) == 0,
                   &quot;GXInitFifoLimits: loWatermark not 32B aligned&quot;);
    ASSERTMSGLINE (0x268,
                   hiWatermark &lt; realFifo-&gt;top - realFifo-&gt;base,
                   &quot;GXInitFifoLimits: hiWatermark too large&quot;);
    ASSERTMSGLINE (0x26A,
                   loWatermark &lt; hiWatermark,
                   &quot;GXInitFifoLimits: hiWatermark below lo watermark&quot;);

    realFifo-&gt;hiWatermark = hiWatermark;
    realFifo-&gt;loWatermark = loWatermark;
}

void
GXSetCPUFifo (GXFifoObj* fifo)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;
    BOOL         enabled  = OSDisableInterrupts();

    CPUFifo               = realFifo;
    if (CPUFifo == GPFifo)
    {
        u32 reg = 0;

        GX_SET_PI_REG (3, (u32)realFifo-&gt;base &amp; 0x3FFFFFFF);
        GX_SET_PI_REG (4, (u32)realFifo-&gt;top &amp; 0x3FFFFFFF);
        SET_REG_FIELD (0x294, reg, 21, 5, ((u32)realFifo-&gt;wrPtr &amp; 0x3FFFFFFF) &gt;&gt; 5);
        SET_REG_FIELD (0x295, reg, 1, 26, 0);
        GX_SET_PI_REG (5, reg);
        CPGPLinked = GX_TRUE;
        __GXWriteFifoIntReset (1, 1);
        __GXWriteFifoIntEnable (1, 0);
        __GXFifoLink (1);
    }
    else
    {
        u32 reg;

        if (CPGPLinked)
        {
            __GXFifoLink (0);
            CPGPLinked = GX_FALSE;
        }
        __GXWriteFifoIntEnable (0, 0);
        reg = 0;
        GX_SET_PI_REG (3, (u32)realFifo-&gt;base &amp; 0x3FFFFFFF);
        GX_SET_PI_REG (4, (u32)realFifo-&gt;top &amp; 0x3FFFFFFF);
        SET_REG_FIELD (0x2B7, reg, 21, 5, ((u32)realFifo-&gt;wrPtr &amp; 0x3FFFFFFF) &gt;&gt; 5);
        SET_REG_FIELD (0x2B8, reg, 1, 26, 0);
        GX_SET_PI_REG (5, reg);
    }
    __sync();

    OSRestoreInterrupts (enabled);
}

void
GXSetGPFifo (GXFifoObj* fifo)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;
    BOOL         enabled  = OSDisableInterrupts();

    __GXFifoReadDisable();
    __GXWriteFifoIntEnable (0, 0);
    GPFifo = realFifo;

    GX_SET_CP_REG (16, (u32)realFifo-&gt;base &amp; 0xFFFF);
    GX_SET_CP_REG (18, (u32)realFifo-&gt;top &amp; 0xFFFF);
    GX_SET_CP_REG (24, realFifo-&gt;count &amp; 0xFFFF);
    GX_SET_CP_REG (26, (u32)realFifo-&gt;wrPtr &amp; 0xFFFF);
    GX_SET_CP_REG (28, (u32)realFifo-&gt;rdPtr &amp; 0xFFFF);
    GX_SET_CP_REG (20, (u32)realFifo-&gt;hiWatermark &amp; 0xFFFF);
    GX_SET_CP_REG (22, (u32)realFifo-&gt;loWatermark &amp; 0xFFFF);
    GX_SET_CP_REG (17, ((u32)realFifo-&gt;base &amp; 0x3FFFFFFF) &gt;&gt; 16);
    GX_SET_CP_REG (19, ((u32)realFifo-&gt;top &amp; 0x3FFFFFFF) &gt;&gt; 16);
    GX_SET_CP_REG (25, realFifo-&gt;count &gt;&gt; 16);
    GX_SET_CP_REG (27, ((u32)realFifo-&gt;wrPtr &amp; 0x3FFFFFFF) &gt;&gt; 16);
    GX_SET_CP_REG (29, ((u32)realFifo-&gt;rdPtr &amp; 0x3FFFFFFF) &gt;&gt; 16);
    GX_SET_CP_REG (21, (u32)realFifo-&gt;hiWatermark &gt;&gt; 16);
    GX_SET_CP_REG (23, (u32)realFifo-&gt;loWatermark &gt;&gt; 16);

    __sync();

    if (CPUFifo == GPFifo)
    {
        CPGPLinked = GX_TRUE;
        __GXWriteFifoIntEnable (1, 0);
        __GXFifoLink (1);
    }
    else
    {
        CPGPLinked = GX_FALSE;
        __GXWriteFifoIntEnable (0, 0);
        __GXFifoLink (0);
    }
    __GXWriteFifoIntReset (1, 1);
    __GXFifoReadEnable();

    OSRestoreInterrupts (enabled);
}

void
GXSaveCPUFifo (GXFifoObj* fifo)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;
    ASSERTMSGLINE (0x321, realFifo == CPUFifo, &quot;GXSaveCPUFifo: fifo is not attached to CPU&quot;);
    __GXSaveCPUFifoAux (realFifo);
}

#define SOME_MACRO1(fifo)                                                                      \
    do {                                                                                       \
        u32 temp     = (u32)GX_GET_CP_REG (29) &lt;&lt; 16;                                          \
        temp        |= GX_GET_CP_REG (28);                                                     \
        fifo-&gt;rdPtr  = OSPhysicalToCached (temp);                                              \
    }                                                                                          \
    while (0)

#define SOME_MACRO2(fifo)                                                                      \
    do {                                                                                       \
        s32 temp     = (s32)GX_GET_CP_REG (25) &lt;&lt; 16;                                          \
        temp        |= GX_GET_CP_REG (24);                                                     \
        fifo-&gt;count  = temp;                                                                   \
    }                                                                                          \
    while (0)

void
__GXSaveCPUFifoAux (__GXFifoObj* realFifo)
{
    BOOL enabled = OSDisableInterrupts();

    GXFlush();

    realFifo-&gt;base  = OSPhysicalToCached (GX_GET_PI_REG (3));
    realFifo-&gt;top   = OSPhysicalToCached (GX_GET_PI_REG (4));
    realFifo-&gt;wrPtr = OSPhysicalToCached (GX_GET_PI_REG (5) &amp; 0xFBFFFFFF);

    if (CPGPLinked)
    {
        SOME_MACRO1 (realFifo);
        SOME_MACRO2 (realFifo);
    }
    else
    {
        realFifo-&gt;count = (u8*)realFifo-&gt;wrPtr - (u8*)realFifo-&gt;rdPtr;
        if (realFifo-&gt;count &lt; 0)
        {
            realFifo-&gt;count += realFifo-&gt;size;
        }
    }
    OSRestoreInterrupts (enabled);
}

void
GXSaveGPFifo (GXFifoObj* fifo)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;
    u32          cpStatus;
    u16          readIdle;
    u32          temp;
#pragma unused(temp)

    ASSERTMSGLINE (0x36A, realFifo == GPFifo, &quot;GXSaveGPFifo: fifo is not attached to GP&quot;);

    cpStatus = GX_GET_CP_REG (0);
    readIdle = (u16)GET_REG_FIELD (cpStatus, 1, 2);

    ASSERTMSGLINE (0x371, readIdle, &quot;GXSaveGPFifo: GP is not idle&quot;);

    SOME_MACRO1 (realFifo);
    SOME_MACRO2 (realFifo);
}

void
GXGetGPStatus (GXBool* overhi,
               GXBool* underlow,
               GXBool* readIdle,
               GXBool* cmdIdle,
               GXBool* brkpt)
{
    __GXData-&gt;cpStatus = GX_GET_CP_REG (0);
    *overhi            = (u8)GET_REG_FIELD (__GXData-&gt;cpStatus, 1, 0);
    *underlow          = (u8)GET_REG_FIELD (__GXData-&gt;cpStatus, 1, 1);
    *readIdle          = (u8)GET_REG_FIELD (__GXData-&gt;cpStatus, 1, 2);
    *cmdIdle           = (u8)GET_REG_FIELD (__GXData-&gt;cpStatus, 1, 3);
    *brkpt             = (u8)GET_REG_FIELD (__GXData-&gt;cpStatus, 1, 4);
}

void
GXGetFifoStatus (GXFifoObj* fifo,
                 GXBool*    overhi,
                 GXBool*    underflow,
                 u32*       fifoCount,
                 GXBool*    cpuWrite,
                 GXBool*    gpRead,
                 GXBool*    fifowrap)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;

    *underflow            = GX_FALSE;
    *overhi               = GX_FALSE;
    *fifoCount            = 0;
    *fifowrap             = GX_FALSE;

    if (realFifo == GPFifo)
    {
        SOME_MACRO1 (realFifo);
        SOME_MACRO2 (realFifo);
    }

    if (realFifo == CPUFifo)
    {
        __GXSaveCPUFifoAux (realFifo);
        *fifowrap = (u8)GET_REG_FIELD (GX_GET_PI_REG (5), 1, 26);
    }

    *overhi    = (realFifo-&gt;count &gt; realFifo-&gt;hiWatermark);
    *underflow = (realFifo-&gt;count &lt; realFifo-&gt;loWatermark);
    *fifoCount = (u32)(realFifo-&gt;count);
    *cpuWrite  = (CPUFifo == realFifo);
    *gpRead    = (GPFifo == realFifo);
}

void
GXGetFifoPtrs (GXFifoObj* fifo, void** readPtr, void** writePtr)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;

    ASSERTMSGLINE (0x3F2,
                   realFifo == CPUFifo || realFifo == GPFifo,
                   &quot;GXGetFifoPtrs: fifo is not CPU or GP fifo&quot;);

    if (realFifo == CPUFifo)
    {
        realFifo-&gt;wrPtr = OSPhysicalToCached (GX_GET_PI_REG (5) &amp; 0xFBFFFFFF);
    }
    if (realFifo == GPFifo)
    {
        SOME_MACRO1 (realFifo);
        SOME_MACRO2 (realFifo);
    }
    else
    {
        realFifo-&gt;count = (u8*)realFifo-&gt;wrPtr - (u8*)realFifo-&gt;rdPtr;
        if (realFifo-&gt;count &lt; 0)
        {
            realFifo-&gt;count += realFifo-&gt;size;
        }
    }
    *readPtr  = realFifo-&gt;rdPtr;
    *writePtr = realFifo-&gt;wrPtr;
}

void*
GXGetFifoBase (GXFifoObj* fifo)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;

    return realFifo-&gt;base;
}

u32
GXGetFifoSize (GXFifoObj* fifo)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;

    return realFifo-&gt;size;
}

void
GXGetFifoLimits (GXFifoObj* fifo, u32* hi, u32* lo)
{
    __GXFifoObj* realFifo = (struct __GXFifoObj*)fifo;

    *hi                   = realFifo-&gt;hiWatermark;
    *lo                   = realFifo-&gt;loWatermark;
}

GXBreakPtCallback
GXSetBreakPtCallback (GXBreakPtCallback cb)
{
    GXBreakPtCallback oldcb   = BreakPointCB;
    BOOL              enabled = OSDisableInterrupts();

    BreakPointCB              = cb;
    OSRestoreInterrupts (enabled);

    return oldcb;
}

void* __GXCurrentBP;

void
GXEnableBreakPt (void* break_pt)
{
    BOOL enabled = OSDisableInterrupts();

    __GXFifoReadDisable();
    ASSERTMSGLINE (0x44A,
                   (u8*)break_pt &gt;= GPFifo-&gt;base &amp;&amp; (u8*)break_pt &lt;= GPFifo-&gt;top,
                   &quot;GXEnableBreakPt: Break point value not in fifo range&quot;);
    GX_SET_CP_REG (30, (u32)break_pt);
    GX_SET_CP_REG (31, ((u32)break_pt &gt;&gt; 16) &amp; 0x3FFF);
    __GXData-&gt;cpEnable = (__GXData-&gt;cpEnable &amp; 0xFFFFFFFD) | 2;
    __GXData-&gt;cpEnable = (__GXData-&gt;cpEnable &amp; 0xFFFFFFDF) | 0x20;
    GX_SET_CP_REG (1, __GXData-&gt;cpEnable);
    __GXCurrentBP = break_pt;
    __GXFifoReadEnable();

    OSRestoreInterrupts (enabled);
}

void
GXDisableBreakPt (void)
{
    BOOL enabled       = OSDisableInterrupts();

    __GXData-&gt;cpEnable = __GXData-&gt;cpEnable &amp; 0xFFFFFFFD;
    __GXData-&gt;cpEnable = __GXData-&gt;cpEnable &amp; 0xFFFFFFDF;
    GX_SET_CP_REG (1, __GXData-&gt;cpEnable);
    __GXCurrentBP = NULL;
    OSRestoreInterrupts (enabled);
}

void
__GXFifoInit (void)
{
    __OSSetInterruptHandler (0x11, GXCPInterruptHandler);
    __OSUnmaskInterrupts (0x4000);
    __GXCurrentThread           = OSGetCurrentThread();
    GXOverflowSuspendInProgress = FALSE;
}

static void
__GXFifoReadEnable (void)
{
    SET_REG_FIELD (0, __GXData-&gt;cpEnable, 1, 0, 1);
    GX_SET_CP_REG (1, __GXData-&gt;cpEnable);
}

static void
__GXFifoReadDisable (void)
{
    SET_REG_FIELD (0, __GXData-&gt;cpEnable, 1, 0, 0);
    GX_SET_CP_REG (1, __GXData-&gt;cpEnable);
}

static void
__GXFifoLink (u8 en)
{
    SET_REG_FIELD (0x4B0, __GXData-&gt;cpEnable, 1, 4, (en != 0) ? 1 : 0);
    GX_SET_CP_REG (1, __GXData-&gt;cpEnable);
}

static void
__GXWriteFifoIntEnable (u8 hiWatermarkEn, u8 loWatermarkEn)
{
    SET_REG_FIELD (0x4C6, __GXData-&gt;cpEnable, 1, 2, hiWatermarkEn);
    SET_REG_FIELD (0x4C7, __GXData-&gt;cpEnable, 1, 3, loWatermarkEn);
    GX_SET_CP_REG (1, __GXData-&gt;cpEnable);
}

static void
__GXWriteFifoIntReset (u8 hiWatermarkClr, u8 loWatermarkClr)
{
    SET_REG_FIELD (0x4DE, __GXData-&gt;cpClr, 1, 0, hiWatermarkClr);
    SET_REG_FIELD (0x4DF, __GXData-&gt;cpClr, 1, 1, loWatermarkClr);
    GX_SET_CP_REG (2, __GXData-&gt;cpClr);
}

void
__GXInsaneWatermark (void)
{
    __GXFifoObj* realFifo = GPFifo;

    realFifo-&gt;hiWatermark = realFifo-&gt;loWatermark + 512;
    GX_SET_CP_REG (20, (realFifo-&gt;hiWatermark &amp; 0x3FFFFFFF) &amp; 0xFFFF);
    GX_SET_CP_REG (21, (realFifo-&gt;hiWatermark &amp; 0x3FFFFFFF) &gt;&gt; 16);
}

void
__GXCleanGPFifo (void)
{
    GXFifoObj  dummyFifo;
    GXFifoObj* gpFifo  = GXGetGPFifo();
    GXFifoObj* cpuFifo = GXGetCPUFifo();
    void*      base    = GXGetFifoBase (gpFifo);

    dummyFifo          = *gpFifo;
    GXInitFifoPtrs (&amp;dummyFifo, base, base);
    GXSetGPFifo (&amp;dummyFifo);
    if (cpuFifo == gpFifo)
    {
        GXSetCPUFifo (&amp;dummyFifo);
    }

    GXInitFifoPtrs (gpFifo, base, base);
    GXSetGPFifo (gpFifo);
    if (cpuFifo == gpFifo)
    {
        GXSetCPUFifo (cpuFifo);
    }
}

OSThread*
GXSetCurrentGXThread (void)
{
    BOOL      enabled;
    OSThread* prev;

    enabled = OSDisableInterrupts();
    prev    = __GXCurrentThread;

    ASSERTMSGLINE (
        0x532,
        !GXOverflowSuspendInProgress,
        &quot;GXSetCurrentGXThread: Two threads cannot generate GX commands at the same time!&quot;);

    __GXCurrentThread = OSGetCurrentThread();
    OSRestoreInterrupts (enabled);

    return prev;
}

OSThread*
GXGetCurrentGXThread (void)
{
    return __GXCurrentThread;
}

GXFifoObj*
GXGetCPUFifo (void)
{
    return (GXFifoObj*)CPUFifo;
}

GXFifoObj*
GXGetGPFifo (void)
{
    return (GXFifoObj*)GPFifo;
}

u32
GXGetOverflowCount (void)
{
    return __GXOverflowCount;
}

u32
GXResetOverflowCount (void)
{
    u32 oldcount;

    oldcount          = __GXOverflowCount;
    __GXOverflowCount = 0;
    return oldcount;
}

#define SET_REG_FIELD2(line, reg, mask, val)                                                   \
    do {                                                                                       \
        ASSERTMSGLINE (line,                                                                   \
                       ((val) &amp; ~(mask)) == 0,                                                 \
                       &quot;GX Internal: Register field out of range&quot;);                            \
        (reg) = ((u32)(reg) &amp; ~(mask)) | ((u32)(val));                                         \
    }                                                                                          \
    while (0)

volatile void*
GXRedirectWriteGatherPipe (void* ptr)
{
    u32  reg     = 0;
    BOOL enabled = OSDisableInterrupts();

    CHECK_GXBEGIN (0x5A6, &quot;GXRedirectWriteGatherPipe&quot;);
    ASSERTLINE (0x5A7, OFFSET (ptr, 32) == 0);
    ASSERTLINE (0x5A9, !IsWGPipeRedirected);
#if DEBUG
    IsWGPipeRedirected = TRUE;
#endif

    GXFlush();
    while (PPCMfwpar() &amp; 1) {}
    PPCMtwpar ((u32)OSUncachedToPhysical ((void*)GXFIFO_ADDR));
    if (CPGPLinked)
    {
        __GXFifoLink (0);
        __GXWriteFifoIntEnable (0, 0);
    }
    CPUFifo-&gt;wrPtr = OSPhysicalToCached (GX_GET_PI_REG (5) &amp; 0xFBFFFFFF);
    GX_SET_PI_REG (3, 0);
    GX_SET_PI_REG (4, 0x04000000);
    SET_REG_FIELD (0x5C8, reg, 21, 5, ((u32)ptr &amp; 0x3FFFFFFF) &gt;&gt; 5);

    reg &amp;= 0xFBFFFFFF;
    GX_SET_PI_REG (5, reg);
    __sync();

    OSRestoreInterrupts (enabled);

    return (volatile void*)GXFIFO_ADDR;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>