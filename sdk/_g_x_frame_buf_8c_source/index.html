<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File GXFrameBuf.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-gxframebufc">File GXFrameBuf.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_b80c028b3e970eff7f2a07684ffcf104/"><strong>gx</strong></a> <strong>&gt;</strong> <a href="../_g_x_frame_buf_8c/"><strong>GXFrameBuf.c</strong></a></p>
<p><a href="../_g_x_frame_buf_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/gx.h&gt;
#include &lt;dolphin/os.h&gt;

#include &quot;GXPrivate.h&quot;

GXRenderModeObj GXNtsc240Ds = {
    VI_TVMODE_NTSC_DS,
    640,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};

GXRenderModeObj GXNtsc240DsAa = {
    VI_TVMODE_NTSC_DS,
    640,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 0, 0, 21, 22, 21, 0, 0 }
};

GXRenderModeObj GXNtsc240Int = {
    VI_TVMODE_NTSC_INT,
    640,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_TRUE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};

GXRenderModeObj GXNtsc240IntAa = {
    VI_TVMODE_NTSC_INT,
    640,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_TRUE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 0, 0, 21, 22, 21, 0, 0 }
};

GXRenderModeObj GXNtsc480IntDf = {
    VI_TVMODE_NTSC_INT,
    640,
    480,
    480,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 8, 8, 10, 12, 10, 8, 8 }
};

GXRenderModeObj GXNtsc480Int = {
    VI_TVMODE_NTSC_INT,
    640,
    480,
    480,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};

GXRenderModeObj GXNtsc480IntAa = {
    VI_TVMODE_NTSC_INT,
    640,
    242,
    480,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 4, 8, 12, 16, 12, 8, 4 }
};

GXRenderModeObj GXNtsc480Prog = {
    VI_TVMODE_NTSC_PROG,
    640,
    480,
    480,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};

GXRenderModeObj GXNtsc480ProgAa = {
    VI_TVMODE_NTSC_PROG,
    640,
    242,
    480,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 4, 8, 12, 16, 12, 8, 4 }
};

GXRenderModeObj GXMpal240Ds = {
    VI_TVMODE_MPAL_DS,
    640,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXMpal240DsAa = {
    VI_TVMODE_MPAL_DS,
    640,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXMpal240Int = {
    VI_TVMODE_MPAL_INT,
    640,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_TRUE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXMpal240IntAa = {
    VI_TVMODE_MPAL_INT,
    640,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_TRUE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXMpal480IntDf = {
    VI_TVMODE_MPAL_INT,
    640,
    480,
    480,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 8, 8, 10, 12, 10, 8, 8 }
};
GXRenderModeObj GXMpal480Int = {
    VI_TVMODE_MPAL_INT,
    640,
    480,
    480,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXMpal480IntAa = {
    VI_TVMODE_MPAL_INT,
    640,
    242,
    480,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 4, 8, 12, 16, 12, 8, 4 }
};
GXRenderModeObj GXPal264Ds = {
    VI_TVMODE_PAL_DS,
    640,
    264,
    264,
    40,
    23,
    640,
    528,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXPal264DsAa = {
    VI_TVMODE_PAL_DS,
    640,
    264,
    264,
    40,
    23,
    640,
    528,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXPal264Int = {
    VI_TVMODE_PAL_DS,
    640,
    264,
    264,
    40,
    23,
    640,
    528,
    VI_XFB_MODE_SF,
    GX_TRUE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXPal264IntAa = {
    VI_TVMODE_PAL_DS,
    640,
    264,
    264,
    40,
    23,
    640,
    528,
    VI_XFB_MODE_SF,
    GX_TRUE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXPal528IntDf = {
    VI_TVMODE_PAL_INT,
    640,
    528,
    528,
    40,
    23,
    640,
    528,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 8, 8, 10, 12, 10, 8, 8 }
};
GXRenderModeObj GXPal528Int = {
    VI_TVMODE_PAL_INT,
    640,
    528,
    528,
    40,
    23,
    640,
    528,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};
GXRenderModeObj GXPal524IntAa = {
    VI_TVMODE_PAL_INT,
    640,
    264,
    524,
    40,
    23,
    640,
    524,
    VI_XFB_MODE_DF,
    GX_FALSE,
    GX_TRUE,
    { 3, 2, 9, 6, 3, 10, 3, 2, 9, 6, 3, 10, 9, 2, 3, 6, 9, 10, 9, 2, 3, 6, 9, 10 },
    { 4, 8, 12, 16, 12, 8, 4 }
};
GXRenderModeObj GXRmHW = {
    VI_TVMODE_NTSC_DS,
    320,
    240,
    240,
    40,
    0,
    640,
    480,
    VI_XFB_MODE_SF,
    GX_FALSE,
    GX_FALSE,
    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },
    { 0, 0, 21, 22, 21, 0, 0 }
};

void
GXAdjustForOverscan (GXRenderModeObj* rmin, GXRenderModeObj* rmout, u16 hor, u16 ver)
{
    u16 hor2 = (u16)(hor * 2);
    u16 ver2 = (u16)(ver * 2);
    u32 verf;

    if (rmin != rmout)
    {
        *rmout = *rmin;
    }

    rmout-&gt;fbWidth   = (u16)(rmin-&gt;fbWidth - hor2);
    verf             = (ver2 * rmin-&gt;efbHeight) / (u32)rmin-&gt;xfbHeight;
    rmout-&gt;efbHeight = (u16)(rmin-&gt;efbHeight - verf);
    if (rmin-&gt;xFBmode == VI_XFB_MODE_SF &amp;&amp; (rmin-&gt;viTVmode &amp; 2) != 2)
    {
        rmout-&gt;xfbHeight = (u16)(rmin-&gt;xfbHeight - ver);
    }
    else
    {
        rmout-&gt;xfbHeight = (u16)(rmin-&gt;xfbHeight - ver2);
    }
    rmout-&gt;viWidth   = (u16)(rmin-&gt;viWidth - hor2);
    rmout-&gt;viHeight  = (u16)(rmin-&gt;viHeight - ver2);
    rmout-&gt;viXOrigin = (u16)(rmin-&gt;viXOrigin + hor);
    rmout-&gt;viYOrigin = (u16)(rmin-&gt;viYOrigin + ver);
}

void
GXSetDispCopySrc (u16 left, u16 top, u16 wd, u16 ht)
{
    CHECK_GXBEGIN (0x3B9, &quot;GXSetDispCopySrc&quot;);

    __GXData-&gt;cpDispSrc = 0;
    SET_REG_FIELD (0x3BC, __GXData-&gt;cpDispSrc, 10, 0, left);
    SET_REG_FIELD (0x3BD, __GXData-&gt;cpDispSrc, 10, 10, top);
    SET_REG_FIELD (0x3BE, __GXData-&gt;cpDispSrc, 8, 24, 0x49);

    __GXData-&gt;cpDispSize = 0;
    SET_REG_FIELD (0x3C1, __GXData-&gt;cpDispSize, 10, 0, wd - 1);
    SET_REG_FIELD (0x3C2, __GXData-&gt;cpDispSize, 10, 10, ht - 1);
    SET_REG_FIELD (0x3C3, __GXData-&gt;cpDispSize, 8, 24, 0x4A);
}

void
GXSetTexCopySrc (u16 left, u16 top, u16 wd, u16 ht)
{
    CHECK_GXBEGIN (0x3D5, &quot;GXSetTexCopySrc&quot;);

    __GXData-&gt;cpTexSrc = 0;
    SET_REG_FIELD (0x3D8, __GXData-&gt;cpTexSrc, 10, 0, left);
    SET_REG_FIELD (0x3D9, __GXData-&gt;cpTexSrc, 10, 10, top);
    SET_REG_FIELD (0x3DA, __GXData-&gt;cpTexSrc, 8, 24, 0x49);

    __GXData-&gt;cpTexSize = 0;
    SET_REG_FIELD (0x3DD, __GXData-&gt;cpTexSize, 10, 0, wd - 1);
    SET_REG_FIELD (0x3DE, __GXData-&gt;cpTexSize, 10, 10, ht - 1);
    SET_REG_FIELD (0x3DF, __GXData-&gt;cpTexSize, 8, 24, 0x4A);
}

void
GXSetDispCopyDst (u16 wd, u16 ht)
{
#pragma unused(ht)

    u16 stride;

    ASSERTMSGLINE (0x3F3, (wd &amp; 0xF) == 0, &quot;GXSetDispCopyDst: Width must be a multiple of 16&quot;);
    CHECK_GXBEGIN (0x3F4, &quot;GXSetDispCopyDst&quot;);

    stride                 = (u16)(wd * 2);
    __GXData-&gt;cpDispStride = 0;
    SET_REG_FIELD (0x3FA, __GXData-&gt;cpDispStride, 10, 0, (stride &gt;&gt; 5));
    SET_REG_FIELD (0x3FB, __GXData-&gt;cpDispStride, 8, 24, 0x4D);
}

void
GXSetTexCopyDst (u16 wd, u16 ht, GXTexFmt fmt, GXBool mipmap)
{
    u32 rowTiles;
    u32 colTiles;
    u32 cmpTiles;
    u32 peTexFmt;
    u32 peTexFmtH;

    CHECK_GXBEGIN (0x415, &quot;GXSetTexCopyDst&quot;);

    __GXData-&gt;cpTexZ = 0;
    peTexFmt         = (u32)(fmt &amp; 0xF);
    ASSERTMSGLINEV (0x434, peTexFmt &lt; 13, &quot;%s: invalid texture format&quot;, &quot;GXSetTexCopyDst&quot;);

    if (fmt == GX_TF_Z16)
    {
        peTexFmt = 0xB;
    }
    switch (fmt)
    {
        case GX_TF_I4:
        case GX_TF_I8:
        case GX_TF_IA4:
        case GX_TF_IA8:
        case GX_CTF_YUVA8:
            SET_REG_FIELD (0, __GXData-&gt;cpTex, 2, 15, 3);
            break;
        default:
            SET_REG_FIELD (0, __GXData-&gt;cpTex, 2, 15, 2);
            break;
    }

    __GXData-&gt;cpTexZ = (fmt &amp; _GX_TF_ZTF) == _GX_TF_ZTF;
    peTexFmtH        = (peTexFmt &gt;&gt; 3) &amp; 1;
    !peTexFmt;
    SET_REG_FIELD (0x44B, __GXData-&gt;cpTex, 1, 3, peTexFmtH);
    peTexFmt = peTexFmt &amp; 7;
    __GetImageTileCount (fmt, wd, ht, &amp;rowTiles, &amp;colTiles, &amp;cmpTiles);

    __GXData-&gt;cpTexStride = 0;
    SET_REG_FIELD (0x454, __GXData-&gt;cpTexStride, 10, 0, rowTiles * cmpTiles);
    SET_REG_FIELD (0x455, __GXData-&gt;cpTexStride, 8, 24, 0x4D);
    SET_REG_FIELD (0x456, __GXData-&gt;cpTex, 1, 9, mipmap);
    SET_REG_FIELD (0x457, __GXData-&gt;cpTex, 3, 4, peTexFmt);
}

void
GXSetDispCopyFrame2Field (GXCopyMode mode)
{
    CHECK_GXBEGIN (0x468, &quot;GXSetDispCopyFrame2Field&quot;);
    SET_REG_FIELD (0x469, __GXData-&gt;cpDisp, 2, 12, mode);
    SET_REG_FIELD (0x46A, __GXData-&gt;cpTex, 2, 12, 0);
}

void
GXSetCopyClamp (GXFBClamp clamp)
{
    u8 clmpB;
    u8 clmpT;

    CHECK_GXBEGIN (0x47D, &quot;GXSetCopyClamp&quot;);

    clmpT = (clamp &amp; 1) == 1;
    clmpB = (clamp &amp; 2) == 2;

    SET_REG_FIELD (0x481, __GXData-&gt;cpDisp, 1, 0, clmpT);
    SET_REG_FIELD (0x482, __GXData-&gt;cpDisp, 1, 1, clmpB);

    SET_REG_FIELD (0x484, __GXData-&gt;cpTex, 1, 0, clmpT);
    SET_REG_FIELD (0x485, __GXData-&gt;cpTex, 1, 1, clmpB);
}

u32
GXSetDispCopyYScale (f32 vscale)
{
    u8  enable;
    u32 iScale;
    f32 fScale;
    u32 ht;
    u32 reg;

    CHECK_GXBEGIN (0x49B, &quot;GXSetDispCopyYScale&quot;);

    ASSERTMSGLINE (0x49D, vscale &gt;= 1.0f, &quot;GXSetDispCopyYScale: Vertical scale must be &gt;= 1.0&quot;);

    iScale = (u32)(256.0f / vscale) &amp; 0x1FF;
    fScale = 256.0f / (f32)iScale;
    enable = (iScale != 256);

    reg    = 0;
    SET_REG_FIELD (0x4A6, reg, 9, 0, iScale);
    SET_REG_FIELD (0x4A7, reg, 8, 24, 0x4E);
    GX_WRITE_RAS_REG (reg);
    __GXData-&gt;bpSent = 1;
    SET_REG_FIELD (0x4AB, __GXData-&gt;cpDisp, 1, 10, enable);
    ht = (u32)GET_REG_FIELD (__GXData-&gt;cpDispSize, 10, 10) + 1;

    return (u32)(ht * fScale);
}

void
GXSetCopyClear (GXColor clear_clr, u32 clear_z)
{
    u32 reg;

    CHECK_GXBEGIN (0x4C4, &quot;GXSetCopyClear&quot;);
    ASSERTMSGLINE (0x4C6, clear_z &lt;= 0xFFFFFF, &quot;GXSetCopyClear: Z clear value is out of range&quot;);

    reg = 0;
    SET_REG_FIELD (0x4C9, reg, 8, 0, clear_clr.r);
    SET_REG_FIELD (0x4CA, reg, 8, 8, clear_clr.a);
    SET_REG_FIELD (0x4CB, reg, 8, 24, 0x4F);
    GX_WRITE_RAS_REG (reg);

    reg = 0;
    SET_REG_FIELD (0x4CF, reg, 8, 0, clear_clr.b);
    SET_REG_FIELD (0x4D0, reg, 8, 8, clear_clr.g);
    SET_REG_FIELD (0x4D1, reg, 8, 24, 0x50);
    GX_WRITE_RAS_REG (reg);

    reg = 0;
    SET_REG_FIELD (0x4D5, reg, 24, 0, clear_z);
    SET_REG_FIELD (0x4D6, reg, 8, 24, 0x51);
    GX_WRITE_RAS_REG (reg);
    __GXData-&gt;bpSent = 1;
}

void
GXSetCopyFilter (GXBool aa, const u8 sample_pattern[12][2], GXBool vf, const u8 vfilter[7])
{
    u32 msLoc[4];
    u32 coeff0;
    u32 coeff1;

    CHECK_GXBEGIN (0x4F1, &quot;GXSetCopyFilter&quot;);

    if (aa != 0)
    {
        msLoc[0] = 0;
        SET_REG_FIELD (0x4F5, msLoc[0], 4, 0, sample_pattern[0][0]);
        SET_REG_FIELD (0x4F6, msLoc[0], 4, 4, sample_pattern[0][1]);
        SET_REG_FIELD (0x4F7, msLoc[0], 4, 8, sample_pattern[1][0]);
        SET_REG_FIELD (0x4F8, msLoc[0], 4, 12, sample_pattern[1][1]);
        SET_REG_FIELD (0x4F9, msLoc[0], 4, 16, sample_pattern[2][0]);
        SET_REG_FIELD (0x4FA, msLoc[0], 4, 20, sample_pattern[2][1]);
        SET_REG_FIELD (0x4FB, msLoc[0], 8, 24, 1);

        msLoc[1] = 0;
        SET_REG_FIELD (0x4FE, msLoc[1], 4, 0, sample_pattern[3][0]);
        SET_REG_FIELD (0x4FF, msLoc[1], 4, 4, sample_pattern[3][1]);
        SET_REG_FIELD (0x500, msLoc[1], 4, 8, sample_pattern[4][0]);
        SET_REG_FIELD (0x501, msLoc[1], 4, 12, sample_pattern[4][1]);
        SET_REG_FIELD (0x502, msLoc[1], 4, 16, sample_pattern[5][0]);
        SET_REG_FIELD (0x503, msLoc[1], 4, 20, sample_pattern[5][1]);
        SET_REG_FIELD (0x504, msLoc[1], 8, 24, 2);

        msLoc[2] = 0;
        SET_REG_FIELD (0x507, msLoc[2], 4, 0, sample_pattern[6][0]);
        SET_REG_FIELD (0x508, msLoc[2], 4, 4, sample_pattern[6][1]);
        SET_REG_FIELD (0x509, msLoc[2], 4, 8, sample_pattern[7][0]);
        SET_REG_FIELD (0x50A, msLoc[2], 4, 12, sample_pattern[7][1]);
        SET_REG_FIELD (0x50B, msLoc[2], 4, 16, sample_pattern[8][0]);
        SET_REG_FIELD (0x50C, msLoc[2], 4, 20, sample_pattern[8][1]);
        SET_REG_FIELD (0x50D, msLoc[2], 8, 24, 3);

        msLoc[3] = 0;
        SET_REG_FIELD (0x510, msLoc[3], 4, 0, sample_pattern[9][0]);
        SET_REG_FIELD (0x511, msLoc[3], 4, 4, sample_pattern[9][1]);
        SET_REG_FIELD (0x512, msLoc[3], 4, 8, sample_pattern[10][0]);
        SET_REG_FIELD (0x513, msLoc[3], 4, 12, sample_pattern[10][1]);
        SET_REG_FIELD (0x514, msLoc[3], 4, 16, sample_pattern[11][0]);
        SET_REG_FIELD (0x515, msLoc[3], 4, 20, sample_pattern[11][1]);
        SET_REG_FIELD (0x516, msLoc[3], 8, 24, 4);
    }
    else
    {
        msLoc[0] = 0x01666666;
        msLoc[1] = 0x02666666;
        msLoc[2] = 0x03666666;
        msLoc[3] = 0x04666666;
    }
    GX_WRITE_RAS_REG (msLoc[0]);
    GX_WRITE_RAS_REG (msLoc[1]);
    GX_WRITE_RAS_REG (msLoc[2]);
    GX_WRITE_RAS_REG (msLoc[3]);

    coeff0 = 0;
    SET_REG_FIELD (0, coeff0, 8, 24, 0x53);
    coeff1 = 0;
    SET_REG_FIELD (0, coeff1, 8, 24, 0x54);
    if (vf != 0)
    {
        SET_REG_FIELD (0x52E, coeff0, 6, 0, vfilter[0]);
        SET_REG_FIELD (0x52F, coeff0, 6, 6, vfilter[1]);
        SET_REG_FIELD (0x530, coeff0, 6, 12, vfilter[2]);
        SET_REG_FIELD (0x531, coeff0, 6, 18, vfilter[3]);
        SET_REG_FIELD (0x532, coeff1, 6, 0, vfilter[4]);
        SET_REG_FIELD (0x533, coeff1, 6, 6, vfilter[5]);
        SET_REG_FIELD (0x534, coeff1, 6, 12, vfilter[6]);
    }
    else
    {
        SET_REG_FIELD (0, coeff0, 6, 0, 0);
        SET_REG_FIELD (0, coeff0, 6, 6, 0);
        SET_REG_FIELD (0, coeff0, 6, 12, 21);
        SET_REG_FIELD (0, coeff0, 6, 18, 22);
        SET_REG_FIELD (0, coeff1, 6, 0, 21);
        SET_REG_FIELD (0, coeff1, 6, 6, 0);
        SET_REG_FIELD (0, coeff1, 6, 12, 0);
    }
    GX_WRITE_RAS_REG (coeff0);
    GX_WRITE_RAS_REG (coeff1);
    __GXData-&gt;bpSent = 1;
}

void
GXSetDispCopyGamma (GXGamma gamma)
{
    CHECK_GXBEGIN (0x555, &quot;GXSetDispCopyGamma&quot;);
    SET_REG_FIELD (0x556, __GXData-&gt;cpDisp, 2, 7, gamma);
}

#if DEBUG
static void
__GXVerifCopy (void* dest, u8 clear)
{
    u8  clmpT;
    u8  clmpB;
    u32 x0;
    u32 y0;
    u32 dx;
    u32 dy;

    CHECK_GXBEGIN (0x56A, &quot;GXCopyDisp&quot;);

    clmpT = GET_REG_FIELD (__GXData-&gt;cpDisp, 1, 0);
    clmpB = (u32)GET_REG_FIELD (__GXData-&gt;cpDisp, 1, 1);
    x0    = GET_REG_FIELD (__GXData-&gt;cpDispSrc, 10, 0);
    dx    = GET_REG_FIELD (__GXData-&gt;cpDispSize, 10, 0) + 1;
    y0    = GET_REG_FIELD (__GXData-&gt;cpDispSrc, 10, 10);
    dy    = GET_REG_FIELD (__GXData-&gt;cpDispSize, 10, 10) + 1;

    ASSERTMSGLINE (0x574,
                   clmpT || y0 != 0,
                   &quot;GXCopy: Have to set GX_CLAMP_TOP if source top == 0&quot;);
    ASSERTMSGLINE (0x576,
                   clmpB || y0 + dy &lt;= 528,
                   &quot;GXCopy: Have to set GX_CLAMP_BOTTOM if source bottom &gt; 528&quot;);
    ASSERTMSGLINE (0x57B,
                   (__GXData-&gt;peCtrl &amp; 7) != 3 || clear == 0,
                   &quot;GXCopy: Can not do clear while pixel type is Z&quot;);
    if ((u32)(__GXData-&gt;peCtrl &amp; 7) == 5)
    {
        ASSERTMSGLINE (0x581, clear == 0, &quot;GXCopy: Can not clear YUV framebuffer&quot;);
        ASSERTMSGLINE (0x583,
                       (x0 &amp; 3) == 0,
                       &quot;GXCopy: Source x is not multiple of 4 for YUV copy&quot;);
        ASSERTMSGLINE (0x585,
                       (y0 &amp; 3) == 0,
                       &quot;GXCopy: Source y is not multiple of 4 for YUV copy&quot;);
        ASSERTMSGLINE (0x587,
                       (dx &amp; 3) == 0,
                       &quot;GXCopy: Source width is not multiple of 4 for YUV copy&quot;);
        ASSERTMSGLINE (0x589,
                       (dy &amp; 3) == 0,
                       &quot;GXCopy: Source height is not multiple of 4 for YUV copy&quot;);
    }
    else
    {
        ASSERTMSGLINE (0x58D,
                       (x0 &amp; 1) == 0,
                       &quot;GXCopy: Source x is not multiple of 2 for RGB copy&quot;);
        ASSERTMSGLINE (0x58F,
                       (y0 &amp; 1) == 0,
                       &quot;GXCopy: Source y is not multiple of 2 for RGB copy&quot;);
        ASSERTMSGLINE (0x591,
                       (dx &amp; 1) == 0,
                       &quot;GXCopy: Source width is not multiple of 2 for RGB copy&quot;);
        ASSERTMSGLINE (0x593,
                       (dy &amp; 1) == 0,
                       &quot;GXCopy: Source height is not multiple of 2 for RGB copy&quot;);
    }
    ASSERTMSGLINE (0x597,
                   ((u32)dest &amp; 0x1F) == 0,
                   &quot;GXCopy: Display destination address not 32B aligned&quot;);
}
#endif

void
GXCopyDisp (void* dest, GXBool clear)
{
    u32 reg;
    u32 tempPeCtrl;
    u32 phyAddr;
    u8  changePeCtrl;

    CHECK_GXBEGIN (0x5B1, &quot;GXCopyDisp&quot;);

#if DEBUG
    __GXVerifCopy (dest, clear);
#endif
    if (clear)
    {
        reg = __GXData-&gt;zmode;
        SET_REG_FIELD (0, reg, 1, 0, 1);
        SET_REG_FIELD (0, reg, 3, 1, 7);
        GX_WRITE_RAS_REG (reg);

        reg = __GXData-&gt;cmode0;
        SET_REG_FIELD (0, reg, 1, 0, 0);
        SET_REG_FIELD (0, reg, 1, 1, 0);
        GX_WRITE_RAS_REG (reg);
    }
    changePeCtrl = FALSE;
    if ((clear || (u32)GET_REG_FIELD (__GXData-&gt;peCtrl, 3, 0) == 3) &amp;&amp;
        (u32)GET_REG_FIELD (__GXData-&gt;peCtrl, 1, 6) == 1)
    {
        changePeCtrl = TRUE;
        tempPeCtrl   = __GXData-&gt;peCtrl;
        SET_REG_FIELD (0, tempPeCtrl, 1, 6, 0);
        GX_WRITE_RAS_REG (tempPeCtrl);
    }
    GX_WRITE_RAS_REG (__GXData-&gt;cpDispSrc);
    GX_WRITE_RAS_REG (__GXData-&gt;cpDispSize);
    GX_WRITE_RAS_REG (__GXData-&gt;cpDispStride);

    phyAddr = (u32)dest &amp; 0x3FFFFFFF;
    reg     = 0;
    SET_REG_FIELD (0x5D8, reg, 21, 0, phyAddr &gt;&gt; 5);
    SET_REG_FIELD (0x5D9, reg, 8, 24, 0x4B);
    GX_WRITE_RAS_REG (reg);

    SET_REG_FIELD (0x5DC, __GXData-&gt;cpDisp, 1, 11, clear);
    SET_REG_FIELD (0x5DD, __GXData-&gt;cpDisp, 1, 14, 1);
    SET_REG_FIELD (0x5DE, __GXData-&gt;cpDisp, 8, 24, 0x52);
    GX_WRITE_RAS_REG (__GXData-&gt;cpDisp);

    if (clear)
    {
        GX_WRITE_RAS_REG (__GXData-&gt;zmode);
        GX_WRITE_RAS_REG (__GXData-&gt;cmode0);
    }
    if (changePeCtrl)
    {
        GX_WRITE_RAS_REG (__GXData-&gt;peCtrl);
    }
    __GXData-&gt;bpSent = 1;
}

void
GXCopyTex (void* dest, GXBool clear)
{
    u32 reg;
    u32 tempPeCtrl;
    u32 phyAddr;
    u8  changePeCtrl;

    CHECK_GXBEGIN (0x604, &quot;GXCopyTex&quot;);

#if DEBUG
    __GXVerifCopy (dest, clear);
#endif
    if (clear)
    {
        reg = __GXData-&gt;zmode;
        SET_REG_FIELD (0, reg, 1, 0, 1);
        SET_REG_FIELD (0, reg, 3, 1, 7);
        GX_WRITE_RAS_REG (reg);

        reg = __GXData-&gt;cmode0;
        SET_REG_FIELD (0, reg, 1, 0, 0);
        SET_REG_FIELD (0, reg, 1, 1, 0);
        GX_WRITE_RAS_REG (reg);
    }
    changePeCtrl = 0;
    tempPeCtrl   = __GXData-&gt;peCtrl;
    if (((u8)__GXData-&gt;cpTexZ != 0) &amp;&amp; ((u32)(tempPeCtrl &amp; 7) != 3))
    {
        changePeCtrl = 1;
        tempPeCtrl   = (tempPeCtrl &amp; 0xFFFFFFF8) | 3;
    }
    if (((clear != 0) || ((u32)(tempPeCtrl &amp; 7) == 3)) &amp;&amp; ((u32)((tempPeCtrl &gt;&gt; 6U) &amp; 1) == 1))
    {
        changePeCtrl  = 1;
        tempPeCtrl   &amp;= 0xFFFFFFBF;
    }
    if (changePeCtrl)
    {
        GX_WRITE_RAS_REG (tempPeCtrl);
    }
    GX_WRITE_RAS_REG (__GXData-&gt;cpTexSrc);
    GX_WRITE_RAS_REG (__GXData-&gt;cpTexSize);
    GX_WRITE_RAS_REG (__GXData-&gt;cpTexStride);

    phyAddr = (u32)dest &amp; 0x3FFFFFFF;
    reg     = 0;
    SET_REG_FIELD (0x635, reg, 21, 0, phyAddr &gt;&gt; 5);
    SET_REG_FIELD (0x636, reg, 8, 24, 0x4B);
    GX_WRITE_RAS_REG (reg);

    SET_REG_FIELD (0x639, __GXData-&gt;cpTex, 1, 11, clear);
    SET_REG_FIELD (0x63A, __GXData-&gt;cpTex, 1, 14, 0);
    SET_REG_FIELD (0x63B, __GXData-&gt;cpTex, 8, 24, 0x52);
    GX_WRITE_RAS_REG (__GXData-&gt;cpTex);

    if (clear != 0)
    {
        GX_WRITE_RAS_REG (__GXData-&gt;zmode);
        GX_WRITE_RAS_REG (__GXData-&gt;cmode0);
    }
    if (changePeCtrl)
    {
        GX_WRITE_RAS_REG (__GXData-&gt;peCtrl);
    }
    __GXData-&gt;bpSent = 1;
}

void
GXClearBoundingBox (void)
{
    u32 reg;

    CHECK_GXBEGIN (0x65B, &quot;GXClearBoundingBox&quot;);
    reg = 0x550003FF;
    GX_WRITE_RAS_REG (reg);
    reg = 0x560003FF;
    GX_WRITE_RAS_REG (reg);
    __GXData-&gt;bpSent = 1;
}

void
GXReadBoundingBox (u16* left, u16* top, u16* right, u16* bottom)
{
    CHECK_GXBEGIN (0x671, &quot;GXReadBoundingBox&quot;);
    *left   = __PERegs[PE_PI_XBOUND0_ID];
    *top    = __PERegs[PE_PI_YBOUND0_ID];
    *right  = __PERegs[PE_PI_XBOUND1_ID];
    *bottom = __PERegs[PE_PI_YBOUND1_ID];
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>