<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File CARDCheck.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-cardcheckc">File CARDCheck.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_2dfa3b55db09c289c0394a464581d568/"><strong>card</strong></a> <strong>&gt;</strong> <a href="../_c_a_r_d_check_8c/"><strong>CARDCheck.c</strong></a></p>
<p><a href="../_c_a_r_d_check_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/card.h&gt;

#include &lt;string.h&gt;

#include &quot;../os/OSPrivate.h&quot;
#include &quot;CARDPrivate.h&quot;

static s32 VerifyID (CARDControl* card);
static s32 VerifyDir (CARDControl* card, int* outCurrent);
static s32 VerifyFAT (CARDControl* card, int* outCurrent);

void
__CARDCheckSum (void* ptr, int length, u16* checksum, u16* checksumInv)
{
    u16* p;
    int  i;

    ASSERTLINE (0x44, length % sizeof (u16) == 0);

    length /= sizeof (u16);
    *checksum = *checksumInv = 0;
    for (i = 0, p = ptr; i &lt; length; i++, p++)
    {
        *checksum += *p;
        *checksumInv += ~*p;
    }
    if (*checksum == 0xffff)
    {
        *checksum = 0;
    }
    if (*checksumInv == 0xffff)
    {
        *checksumInv = 0;
    }
}

static s32
VerifyID (CARDControl* card)
{
    CARDID*   id;
    u16       checksum;
    u16       checksumInv;
    OSSramEx* sramEx;
    OSTime    rand;
    int       i;

    id = card-&gt;workArea;

    if (id-&gt;deviceID != 0 || id-&gt;size != card-&gt;size)
    {
        return CARD_RESULT_BROKEN;
    }

    __CARDCheckSum (id, sizeof (CARDID) - sizeof (u32), &amp;checksum, &amp;checksumInv);
    if (id-&gt;checkSum != checksum || id-&gt;checkSumInv != checksumInv)
    {
        return CARD_RESULT_BROKEN;
    }

    if (id-&gt;encode != OSGetFontEncode())
    {
        return CARD_RESULT_ENCODING;
    }

    rand = *(OSTime*)&amp;id-&gt;serial[12];
    sramEx = __OSLockSramEx();
    for (i = 0; i &lt; 12; i++)
    {
        rand = (rand * 1103515245 + 12345) &gt;&gt; 16;
        if (id-&gt;serial[i] != (u8)(sramEx-&gt;flashID[card - __CARDBlock][i] + rand))
        {
            __OSUnlockSramEx (FALSE);
            return CARD_RESULT_BROKEN;
        }
        rand = ((rand * 1103515245 + 12345) &gt;&gt; 16) &amp; 0x7FFF;
    }

    __OSUnlockSramEx (FALSE);

    return CARD_RESULT_READY;
}

static s32
VerifyDir (CARDControl* card, int* outCurrent)
{
    CARDDir*      dir[2];
    CARDDirCheck* check[2];
    u16           checkSum;
    u16           checkSumInv;
    int           i;
    int           errors;
    int           current;

    current = errors = 0;
    for (i = 0; i &lt; 2; i++)
    {
        dir[i] = (CARDDir*)((u8*)card-&gt;workArea + (1 + i) * CARD_SYSTEM_BLOCK_SIZE);
        check[i] = CARDGetDirCheck (dir[i]);
        __CARDCheckSum (dir[i], CARD_SYSTEM_BLOCK_SIZE - sizeof (u32), &amp;checkSum, &amp;checkSumInv);
        if (check[i]-&gt;checkSum != checkSum || check[i]-&gt;checkSumInv != checkSumInv)
        {
            ++errors;
            current = i;
            card-&gt;currentDir = 0;
        }
    }

    if (0 == errors)
    {
        if (card-&gt;currentDir == 0)
        {
            if ((check[0]-&gt;checkCode - check[1]-&gt;checkCode) &lt; 0)
            {
                current = 0;
            }
            else
            {
                current = 1;
            }
            card-&gt;currentDir = dir[current];
            memcpy (dir[current], dir[current ^ 1], CARD_SYSTEM_BLOCK_SIZE);
        }
        else
        {
            current = (card-&gt;currentDir == dir[0]) ? 0 : 1;
        }
    }
    if (outCurrent)
    {
        *outCurrent = current;
    }
    return errors;
}

static s32
VerifyFAT (CARDControl* card, int* outCurrent)
{
    u16* fat[2];
    u16* fatp;
    u16  nBlock;
    u16  cFree;
    int  i;
    u16  checkSum;
    u16  checkSumInv;
    int  errors;
    int  current;

    current = errors = 0;
    for (i = 0; i &lt; 2; i++)
    {
        fatp = fat[i] = (u16*)((u8*)card-&gt;workArea + (3 + i) * CARD_SYSTEM_BLOCK_SIZE);

        __CARDCheckSum (&amp;fatp[CARD_FAT_CHECKCODE],
                        CARD_SYSTEM_BLOCK_SIZE - sizeof (u32),
                        &amp;checkSum,
                        &amp;checkSumInv);
        if (fatp[CARD_FAT_CHECKSUM] != checkSum || fatp[CARD_FAT_CHECKSUMINV] != checkSumInv)
        {
            ++errors;
            current = i;
            card-&gt;currentFat = 0;
            continue;
        }

        cFree = 0;
        for (nBlock = CARD_NUM_SYSTEM_BLOCK; nBlock &lt; card-&gt;cBlock; nBlock++)
        {
            if (fatp[nBlock] == CARD_FAT_AVAIL)
            {
                cFree++;
            }
        }
        if (cFree != fatp[CARD_FAT_FREEBLOCKS])
        {
            ++errors;
            current = i;
            card-&gt;currentFat = 0;
            continue;
        }
    }

    if (0 == errors)
    {
        if (card-&gt;currentFat == 0)
        {
            if (((s16)fat[0][CARD_FAT_CHECKCODE] - (s16)fat[1][CARD_FAT_CHECKCODE]) &lt; 0)
            {
                current = 0;
            }
            else
            {
                current = 1;
            }
            card-&gt;currentFat = fat[current];
            memcpy (fat[current], fat[current ^ 1], CARD_SYSTEM_BLOCK_SIZE);
        }
        else
        {
            current = (card-&gt;currentFat == fat[0]) ? 0 : 1;
        }
    }
    if (outCurrent)
    {
        *outCurrent = current;
    }
    return errors;
}

s32
__CARDVerify (CARDControl* card)
{
    s32 result;
    int errors;

    result = VerifyID (card);
    if (result &lt; 0)
    {
        return result;
    }

    errors = VerifyDir (card, NULL);
    errors += VerifyFAT (card, NULL);
    switch (errors)
    {
        case 0:
            ASSERTLINE (0x11F, card-&gt;currentDir);
            ASSERTLINE (0x120, card-&gt;currentFat);
            return CARD_RESULT_READY;
        case 1:
            return CARD_RESULT_BROKEN;
        default:
            return CARD_RESULT_BROKEN;
    }
}

s32
CARDCheckExAsync (s32 chan, s32* xferBytes, CARDCallback callback)
{
    CARDControl* card;
    CARDDir*     dir[2];
    u16*         fat[2];
    u16*         map;
    s32          result;
    int          errors;
    int          currentFat;
    int          currentDir;
    s32          fileNo;
    u16          iBlock;
    u16          cBlock;
    u16          cFree;
    BOOL         updateFat = FALSE;
    BOOL         updateDir = FALSE;
    BOOL         updateOrphan = FALSE;

    ASSERTLINE (346, 0 &lt;= chan &amp;&amp; chan &lt; 2);

    if (xferBytes)
    {
        *xferBytes = 0;
    }

    result = __CARDGetControlBlock (chan, &amp;card);
    if (result &lt; 0)
    {
        return result;
    }

    result = VerifyID (card);
    if (result &lt; 0)
    {
        return __CARDPutControlBlock (card, result);
    }

    errors = VerifyDir (card, &amp;currentDir);
    errors += VerifyFAT (card, &amp;currentFat);
    if (1 &lt; errors)
    {
        return __CARDPutControlBlock (card, CARD_RESULT_BROKEN);
    }

    dir[0] = (CARDDir*)((u8*)card-&gt;workArea + (1 + 0) * CARD_SYSTEM_BLOCK_SIZE);
    dir[1] = (CARDDir*)((u8*)card-&gt;workArea + (1 + 1) * CARD_SYSTEM_BLOCK_SIZE);
    fat[0] = (u16*)((u8*)card-&gt;workArea + (3 + 0) * CARD_SYSTEM_BLOCK_SIZE);
    fat[1] = (u16*)((u8*)card-&gt;workArea + (3 + 1) * CARD_SYSTEM_BLOCK_SIZE);

    ASSERTLINE (0x163, errors == 0 || errors == 1);

    switch (errors)
    {
        case 0:
            ASSERTLINE (0x167, card-&gt;currentDir);
            ASSERTLINE (0x168, card-&gt;currentFat);
            break;
        case 1:
            if (!card-&gt;currentDir)
            {
                ASSERTLINE (0x16D, card-&gt;currentFat);
                card-&gt;currentDir = dir[currentDir];
                memcpy (dir[currentDir], dir[currentDir ^ 1], CARD_SYSTEM_BLOCK_SIZE);
                updateDir = TRUE;
            }
            else
            {
                ASSERTLINE (0x174, !card-&gt;currentFat);
                card-&gt;currentFat = fat[currentFat];
                memcpy (fat[currentFat], fat[currentFat ^ 1], CARD_SYSTEM_BLOCK_SIZE);
                updateFat = TRUE;
            }
            break;
    }

    map = fat[currentFat ^ 1];
    memset (map, 0, CARD_SYSTEM_BLOCK_SIZE);

    for (fileNo = 0; fileNo &lt; CARD_MAX_FILE; fileNo++)
    {
        CARDDir* ent;

        ent = &amp;card-&gt;currentDir[fileNo];
        if (ent-&gt;gameName[0] == 0xff)
        {
            continue;
        }

        for (iBlock = ent-&gt;startBlock, cBlock = 0; iBlock != 0xFFFF &amp;&amp; cBlock &lt; ent-&gt;length;
             iBlock = card-&gt;currentFat[iBlock], ++cBlock)
        {
            if (!CARDIsValidBlockNo (card, iBlock) || 1 &lt; ++map[iBlock])
            {
                return __CARDPutControlBlock (card, CARD_RESULT_BROKEN);
            }
        }
        if (cBlock != ent-&gt;length || iBlock != 0xFFFF)
        {
            return __CARDPutControlBlock (card, CARD_RESULT_BROKEN);
        }
    }

    cFree = 0;
    for (iBlock = CARD_NUM_SYSTEM_BLOCK; iBlock &lt; card-&gt;cBlock; iBlock++)
    {
        u16 nextBlock;

        nextBlock = card-&gt;currentFat[iBlock];
        if (map[iBlock] == 0)
        {
            if (nextBlock != CARD_FAT_AVAIL)
            {
                card-&gt;currentFat[iBlock] = CARD_FAT_AVAIL;
                updateOrphan = TRUE;
            }
            cFree++;
        }
        else if (!CARDIsValidBlockNo (card, nextBlock) &amp;&amp; nextBlock != 0xFFFF)
        {
            return __CARDPutControlBlock (card, CARD_RESULT_BROKEN);
        }
    }
    if (cFree != card-&gt;currentFat[CARD_FAT_FREEBLOCKS])
    {
        card-&gt;currentFat[CARD_FAT_FREEBLOCKS] = cFree;
        updateOrphan = TRUE;
    }
    if (updateOrphan)
    {
        __CARDCheckSum (&amp;card-&gt;currentFat[CARD_FAT_CHECKCODE],
                        CARD_SYSTEM_BLOCK_SIZE - sizeof (u32),
                        &amp;card-&gt;currentFat[CARD_FAT_CHECKSUM],
                        &amp;card-&gt;currentFat[CARD_FAT_CHECKSUMINV]);
    }
    memcpy (fat[currentFat ^ 1], fat[currentFat], CARD_SYSTEM_BLOCK_SIZE);

    if (updateDir)
    {
        if (xferBytes)
        {
            *xferBytes = CARD_SYSTEM_BLOCK_SIZE;
        }
        return __CARDUpdateDir (chan, callback);
    }

    if (updateFat | updateOrphan)
    {
        if (xferBytes)
        {
            *xferBytes = CARD_SYSTEM_BLOCK_SIZE;
        }
        return __CARDUpdateFatBlock (chan, card-&gt;currentFat, callback);
    }

    __CARDPutControlBlock (card, CARD_RESULT_READY);
    if (callback)
    {
        BOOL enabled = OSDisableInterrupts();
        callback (chan, CARD_RESULT_READY);
        OSRestoreInterrupts (enabled);
    }
    return CARD_RESULT_READY;
}

s32
CARDCheckAsync (s32 chan, CARDCallback callback)
{
    s32 xferBytes;

    return CARDCheckExAsync (chan, &amp;xferBytes, callback);
}

s32
CARDCheckEx (s32 chan, s32* xferBytes)
{
    s32 result = CARDCheckExAsync (chan, xferBytes, __CARDSyncCallback);
    if (result &lt; 0 || xferBytes == 0)
    {
        return result;
    }

    return __CARDSync (chan);
}

s32
CARDCheck (s32 chan)
{
    s32 xferBytes;

    return CARDCheckEx (chan, &amp;xferBytes);
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>