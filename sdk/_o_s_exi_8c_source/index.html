<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File OSExi.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-osexic">File OSExi.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_c85f9e83f0f4b4374578811cecebda65/"><strong>os</strong></a> <strong>&gt;</strong> <a href="../_o_s_exi_8c/"><strong>OSExi.c</strong></a></p>
<p><a href="../_o_s_exi_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/os.h&gt;

#include &lt;string.h&gt;

typedef void (*EXICallback) (s32, OSContext*);

typedef struct EXIControl
{
    EXICallback  exiCallback; 
    EXICallback  tcCallback;  
    EXICallback  extCallback; 
    volatile u32 state;       
    int          immLen;      
    u8*          immBuf;      
    u32          dev;         
    int          items;       

    struct
    {
        u32         dev;
        EXICallback callback;
    } queue[3];
} EXIControl;

#define MAX_CHAN                   0x03

#define STATE_IDLE                 0x00
#define STATE_DMA                  0x01
#define STATE_IMM                  0x02
#define STATE_BUSY                 0x03
#define STATE_SELECTED             0x04
#define STATE_ATTACHED             0x08
#define STATE_LOCKED               0x10

#define MAX_IMM                    0x04
#define MAX_TYPE                   0x03
#define MAX_DEV                    0x03
#define MAX_FREQ                   0x06

#define EXI_0LENGTH_EXILENGTH_MASK 0x03FFFFE0

#define EXI_READ                   0
#define EXI_WRITE                  1
#define EXI_RDWR                   2
#ifdef __MWERKS__
unsigned int __gUnknown800030C0[2] : (OS_BASE_CACHED | 0x30C0);
#endif

static EXIControl Ecb[3];

static void SetExiInterruptMask (s32 chan, EXIControl* exi);
static void CompleteTransfer (s32 chan);
int         EXIImm (s32 chan, void* buf, long len, u32 type, EXICallback callback);
int         EXIImmEx (s32 chan, void* buf, long len, u32 mode);
int         EXIDma (s32 chan, void* buf, long len, u32 type, EXICallback callback);
int         EXISync (s32 chan);
u32         EXIClearInterrupts (s32 chan, int exi, int tc, int ext);
EXICallback EXISetExiCallback (s32 chan, EXICallback exiCallback);
void        EXIProbeReset ();
int         EXIProbe (s32 chan);
int         EXIProbeEx (s32 chan);
int         EXIAttach (s32 chan, EXICallback extCallback);
int         EXIDetach (s32 chan);
int         EXISelect (s32 chan, u32 dev, u32 freq);
int         EXIDeselect (s32 chan);
static void EXIIntrruptHandler (s16 interrupt, OSContext* context);
static void TCIntrruptHandler (s16 interrupt, OSContext* context);
static void EXTIntrruptHandler (s16 interrupt, OSContext* context);
void        EXIInit ();
int         EXILock (s32 chan, u32 dev, void (*unlockedCallback) (long, OSContext*));
int         EXIUnlock (s32 chan);
u32         EXIGetState (s32 chan);
int         EXIGetID (s32 chan, u32 dev, u32* id);

static void
SetExiInterruptMask (s32 chan, EXIControl* exi)
{
    EXIControl* exi2 = &amp;Ecb[2];

    switch (chan)
    {
        case 0:
            if ((exi-&gt;exiCallback == 0 &amp;&amp; exi2-&gt;exiCallback == 0) || exi-&gt;state &amp; STATE_LOCKED)
            {
                __OSMaskInterrupts (0x410000U);
                return;
            }
            __OSUnmaskInterrupts (0x410000U);
            return;
        case 1:
            if (exi-&gt;exiCallback == 0 || exi-&gt;state &amp; STATE_LOCKED)
            {
                __OSMaskInterrupts (0x80000U);
                return;
            }
            __OSUnmaskInterrupts (0x80000U);
            return;
        case 2:
            if ((__OSGetInterruptHandler (0x19) == 0U) || (exi-&gt;state &amp; STATE_LOCKED))
            {
                __OSMaskInterrupts (0x40U);
                return;
            }
            __OSUnmaskInterrupts (0x40U);
            return;
    }
}

static void
CompleteTransfer (s32 chan)
{
    EXIControl* exi;
    u8*         buf;
    u32         data;
    int         i;
    int         len;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x115, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);

    if (exi-&gt;state &amp; STATE_BUSY)
    {
        if (exi-&gt;state &amp; STATE_IMM)
        {
            if ((len = exi-&gt;immLen) != 0)
            {
                buf = exi-&gt;immBuf;
                data = __EXIRegs[(chan * 5) + 4];
                for (i = 0; i &lt; len; i++) { *buf++ = (u8)(data &gt;&gt; ((3 - i) * 8)); }
            }
        }
        exi-&gt;state &amp;= ~STATE_BUSY;
    }
}

int
EXIImm (s32 chan, void* buf, long len, u32 type, EXICallback callback)
{
    EXIControl* exi;
    int         enabled;
    u32         data;
    int         i;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x13B, exi-&gt;state &amp; STATE_SELECTED);
    ASSERTLINE (0x13C, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    ASSERTLINE (0x13D, 0 &lt; len &amp;&amp; len &lt;= MAX_IMM);
    ASSERTLINE (0x13E, type &lt; MAX_TYPE);
    enabled = OSDisableInterrupts();
    if ((exi-&gt;state &amp; STATE_BUSY) || !(exi-&gt;state &amp; STATE_SELECTED))
    {
        OSRestoreInterrupts (enabled);
        return 0;
    }
    exi-&gt;tcCallback = callback;
    if (exi-&gt;tcCallback)
    {
        EXIClearInterrupts (chan, 0, 1, 0);
        __OSUnmaskInterrupts (0x200000U &gt;&gt; (chan * 3));
    }
    exi-&gt;state |= STATE_IMM;
    if (type != 0)
    {
        data = 0;
        for (i = 0; i &lt; len; i++) { data |= ((u8*)buf)[i] &lt;&lt; ((3 - i) * 8); }
        __EXIRegs[(chan * 5) + 4] = data;
    }
    exi-&gt;immBuf = buf;
    exi-&gt;immLen = (type != 1) ? len : 0;
    __EXIRegs[(chan * 5) + 3] = (type &lt;&lt; 2) | 1 | ((len - 1) &lt;&lt; 4);
    OSRestoreInterrupts (enabled);
    return 1;
}

int
EXIImmEx (s32 chan, void* buf, long len, u32 mode)
{
    s32 xLen;

    while (len)
    {
        xLen = (len &lt; 4) ? len : 4;
        if (EXIImm (chan, buf, xLen, mode, 0) == 0)
        {
            return 0;
        }
        if (EXISync (chan) == 0)
        {
            return 0;
        }
        ((u8*)buf) += xLen;
        len -= xLen;
    }
    return 1;
}

int
EXIDma (s32 chan, void* buf, long len, u32 type, EXICallback callback)
{
    EXIControl* exi;
    int         enabled;

    exi = &amp;Ecb[chan];

    ASSERTLINE (0x1A4, exi-&gt;state &amp; STATE_SELECTED);
    ASSERTLINE (0x1A5, OFFSET (buf, 32) == 0);
    ASSERTLINE (0x1A6, 0 &lt; len &amp;&amp; OFFSET (len, 32) == 0);
    ASSERTLINE (0x1A8, ((u32)len &amp; ~EXI_0LENGTH_EXILENGTH_MASK) == 0);
    ASSERTLINE (0x1AA, type == EXI_READ || type == EXI_WRITE);

    enabled = OSDisableInterrupts();
    if ((exi-&gt;state &amp; STATE_BUSY) || !(exi-&gt;state &amp; STATE_SELECTED))
    {
        OSRestoreInterrupts (enabled);
        return 0;
    }
    exi-&gt;tcCallback = callback;
    if ((u32)exi-&gt;tcCallback)
    {
        EXIClearInterrupts (chan, 0, 1, 0);
        __OSUnmaskInterrupts (0x200000U &gt;&gt; (chan * 3));
    }
    exi-&gt;state |= STATE_DMA;
    __EXIRegs[(chan * 5) + 1] = (u32)buf &amp; 0x03FFFFE0;
    __EXIRegs[(chan * 5) + 2] = (u32)len;
    __EXIRegs[(chan * 5) + 3] = (type * 4) | 3;
    OSRestoreInterrupts (enabled);
    return 1;
}

extern u32 __OSGetDIConfig (void);

int
EXISync (s32 chan)
{
    EXIControl* exi = &amp;Ecb[chan];
    int         rc = FALSE;
    int         enabled;

    ASSERTLINE (0x1D7, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    while ((exi-&gt;state &amp; STATE_SELECTED))
    {
        if (!(__EXIRegs[(chan * 5) + 3] &amp; 1))
        {
            enabled = OSDisableInterrupts();
            if (exi-&gt;state &amp; STATE_SELECTED)
            {
                CompleteTransfer (chan);
                if (__OSGetDIConfig() != 0xFF || exi-&gt;immLen != 4 ||
                    __EXIRegs[chan * 5] &amp; 0x70 || __EXIRegs[(chan * 5) + 4] != 0x1010000)
                {
                    rc = TRUE;
                }
            }
            OSRestoreInterrupts (enabled);
            break;
        }
    }
    ASSERTLINE (0x1E9, !(exi-&gt;state &amp; STATE_BUSY));
    return rc;
}

u32
EXIClearInterrupts (s32 chan, int exi, int tc, int ext)
{
    u32 cpr;
    u32 prev;

    ASSERTLINE (0x1FE, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    cpr = prev = __EXIRegs[(chan * 5)];
    prev &amp;= 0x7F5;
    if (exi != 0)
    {
        prev |= 2;
    }
    if (tc != 0)
    {
        prev |= 8;
    }
    if (ext != 0)
    {
        prev |= 0x800;
    }
    __EXIRegs[(chan * 5)] = prev;
    return cpr;
}

EXICallback
EXISetExiCallback (s32 chan, EXICallback exiCallback)
{
    EXIControl* exi;
    EXICallback prev;
    int         enabled;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x220, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    enabled = OSDisableInterrupts();
    prev = exi-&gt;exiCallback;
    exi-&gt;exiCallback = exiCallback;
    if (chan != 2)
    {
        SetExiInterruptMask (chan, exi);
    }
    else
    {
        SetExiInterruptMask (0, &amp;Ecb[0]);
    }
    OSRestoreInterrupts (enabled);
    return prev;
}

void
EXIProbeReset ()
{
    __gUnknown800030C0[0] = __gUnknown800030C0[1] = 0;
    EXIProbe (0);
    EXIProbe (1);
}

int
EXIProbe (s32 chan)
{
    EXIControl* exi;
    int         enabled;
    int         rc;
    u32         cpr;
    s32         t;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x256, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    if (chan == 2)
    {
        return 1;
    }
    rc = 1;
    enabled = OSDisableInterrupts();
    cpr = __EXIRegs[(chan * 5)];
    if (!(exi-&gt;state &amp; STATE_ATTACHED))
    {
        if (cpr &amp; 0x800)
        {
            EXIClearInterrupts (chan, 0, 0, 1);
            __gUnknown800030C0[chan] = 0;
        }
        if (cpr &amp; 0x1000)
        {
            t = ((s32)(OSTicksToMilliseconds (OSGetTime()) / 100) + 1);

            if (__gUnknown800030C0[chan] == 0U)
            {
                __gUnknown800030C0[chan] = (u32)t;
            }
            if (t - (s32)__gUnknown800030C0[chan] &lt; 3)
            {
                rc = 0;
            }
        }
        else
        {
            __gUnknown800030C0[chan] = 0;
            rc = 0;
        }
    }
    else if (!(cpr &amp; 0x1000) || (cpr &amp; 0x800))
    {
        __gUnknown800030C0[chan] = 0;
        rc = 0;
    }
    OSRestoreInterrupts (enabled);
    return rc;
}

int
EXIProbeEx (s32 chan)
{
    if (EXIProbe (chan))
    {
        return 1;
    }
    if (__gUnknown800030C0[chan])
    {
        return 0;
    }
    return -1;
}

int
EXIAttach (s32 chan, EXICallback extCallback)
{
    EXIControl* exi;
    int         enabled;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x2AE, 0 &lt;= chan &amp;&amp; chan &lt; 2);
    enabled = OSDisableInterrupts();
    if (exi-&gt;state &amp; STATE_ATTACHED)
    {
        OSRestoreInterrupts (enabled);
        return 0;
    }
    if (EXIProbe (chan) == 0)
    {
        OSRestoreInterrupts (enabled);
        return 0;
    }
    EXIClearInterrupts (chan, 1, 0, 0);
    exi-&gt;extCallback = extCallback;
    __OSUnmaskInterrupts (0x100000U &gt;&gt; (chan * 3));
    exi-&gt;state |= STATE_ATTACHED;
    OSRestoreInterrupts (enabled);
    return 1;
}

int
EXIDetach (s32 chan)
{
    EXIControl* exi;
    int         enabled;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x2D7, 0 &lt;= chan &amp;&amp; chan &lt; 2);
    enabled = OSDisableInterrupts();
    if (!(exi-&gt;state &amp; STATE_ATTACHED))
    {
        OSRestoreInterrupts (enabled);
        return 1;
    }
    if ((exi-&gt;state &amp; STATE_LOCKED) &amp;&amp; (exi-&gt;dev == 0))
    {
        OSRestoreInterrupts (enabled);
        return 0;
    }
    exi-&gt;state &amp;= ~STATE_ATTACHED;
    __OSMaskInterrupts (0x700000U &gt;&gt; (chan * 3));
    OSRestoreInterrupts (enabled);
    return 1;
}

int
EXISelect (s32 chan, u32 dev, u32 freq)
{
    EXIControl* exi;
    u32         cpr;
    int         enabled;

    exi = &amp;Ecb[chan];

    ASSERTLINE (0x2FF, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    ASSERTLINE (0x300, chan == 0 &amp;&amp; dev &lt; MAX_DEV || dev == 0);
    ASSERTLINE (0x301, freq &lt; MAX_FREQ);
    ASSERTLINE (0x302, !(exi-&gt;state &amp; STATE_SELECTED));

    enabled = OSDisableInterrupts();
    if ((exi-&gt;state &amp; STATE_SELECTED) ||
        ((chan != 2) &amp;&amp;
         (((dev == 0) &amp;&amp; !(exi-&gt;state &amp; STATE_ATTACHED) &amp;&amp; (EXIProbe (chan) == 0)) ||
          !(exi-&gt;state &amp; STATE_LOCKED) || (exi-&gt;dev != dev))))
    {
        OSRestoreInterrupts (enabled);
        return 0;
    }
    exi-&gt;state |= STATE_SELECTED;
    cpr = __EXIRegs[(chan * 5)];
    cpr &amp;= 0x405;
    cpr |= (((1 &lt;&lt; dev) &lt;&lt; 7) | (freq * 0x10));
    __EXIRegs[(chan * 5)] = cpr;
    if (exi-&gt;state &amp; STATE_ATTACHED)
    {
        switch (chan)
        {
            case 0:
                __OSMaskInterrupts (0x100000U);
                break;
            case 1:
                __OSMaskInterrupts (0x20000U);
                break;
        }
    }
    OSRestoreInterrupts (enabled);
    return 1;
}

int
EXIDeselect (s32 chan)
{
    EXIControl* exi;
    u32         cpr;
    int         enabled;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x335, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    enabled = OSDisableInterrupts();
    if (!(exi-&gt;state &amp; STATE_SELECTED))
    {
        OSRestoreInterrupts (enabled);
        return 0;
    }
    exi-&gt;state &amp;= ~STATE_SELECTED;
    cpr = __EXIRegs[(chan * 5)];
    __EXIRegs[(chan * 5)] = cpr &amp; 0x405;
    if (exi-&gt;state &amp; STATE_ATTACHED)
    {
        switch (chan)
        {
            case 0:
                __OSUnmaskInterrupts (0x100000U);
                break;
            case 1:
                __OSUnmaskInterrupts (0x20000U);
                break;
        }
    }
    OSRestoreInterrupts (enabled);
    if ((chan != 2) &amp;&amp; (cpr &amp; 0x80))
    {
        if (EXIProbe (chan) != 0)
        {
            return 1;
        }
        return 0;
    }
    return 1;
}

static void
EXIIntrruptHandler (s16 interrupt, OSContext* context)
{
    s32         chan;
    EXIControl* exi;
    EXICallback callback;

    chan = (interrupt - 9) / 3;

    ASSERTLINE (0x368, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    exi = &amp;Ecb[chan];
    EXIClearInterrupts (chan, 1, 0, 0);
    callback = exi-&gt;exiCallback;
    if (callback)
    {
        callback (chan, context);
    }
}

static void
TCIntrruptHandler (s16 interrupt, OSContext* context)
{
    s32         chan;
    EXIControl* exi;
    EXICallback callback;

    chan = (interrupt - 10) / 3;

    ASSERTLINE (0x383, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    exi = &amp;Ecb[chan];
    __OSMaskInterrupts (0x80000000U &gt;&gt; interrupt);
    EXIClearInterrupts (chan, 0, 1, 0);
    callback = exi-&gt;tcCallback;
    if (callback)
    {
        exi-&gt;tcCallback = NULL;
        CompleteTransfer (chan);
        callback (chan, context);
    }
}

static void
EXTIntrruptHandler (s16 interrupt, OSContext* context)
{
    s32         chan;
    EXIControl* exi;
    EXICallback callback;

    chan = (interrupt - 11) / 3;

    ASSERTLINE (0x3A2, 0 &lt;= chan &amp;&amp; chan &lt; 2);
    __OSMaskInterrupts (0x700000U &gt;&gt; (chan * 3));
    __EXIRegs[(chan * 5)] = 0;
    exi = &amp;Ecb[chan];
    callback = exi-&gt;extCallback;
    exi-&gt;state &amp;= ~STATE_ATTACHED;
    if (callback)
    {
        exi-&gt;extCallback = 0;
        callback (chan, context);
    }
}

void
EXIInit ()
{
    __OSMaskInterrupts (0x7F8000U);
    __EXIRegs[0] = 0;
    __EXIRegs[5] = 0;
    __EXIRegs[10] = 0;
    __EXIRegs[0] = 0x2000;
    __OSSetInterruptHandler (9, EXIIntrruptHandler);
    __OSSetInterruptHandler (10, TCIntrruptHandler);
    __OSSetInterruptHandler (11, EXTIntrruptHandler);
    __OSSetInterruptHandler (12, EXIIntrruptHandler);
    __OSSetInterruptHandler (13, TCIntrruptHandler);
    __OSSetInterruptHandler (14, EXTIntrruptHandler);
    __OSSetInterruptHandler (15, EXIIntrruptHandler);
    __OSSetInterruptHandler (16, TCIntrruptHandler);
    if (OSGetConsoleType() &amp; 0x10000000)
    {
        EXIProbeReset();
    }
}

int
EXILock (s32 chan, u32 dev, void (*unlockedCallback) (long, OSContext*))
{
    EXIControl* exi;
    int         enabled;
    int         i;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x3F2, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    ASSERTLINE (0x3F3, chan == 0 &amp;&amp; dev &lt; MAX_DEV || dev == 0);
    enabled = OSDisableInterrupts();

    if (exi-&gt;state &amp; STATE_LOCKED)
    {
        if (unlockedCallback)
        {
            ASSERTLINE (0x3F9, chan == 0 &amp;&amp; exi-&gt;items &lt; (MAX_DEV - 1) || exi-&gt;items == 0);
            for (i = 0; i &lt; exi-&gt;items; i++)
            {
                if (exi-&gt;queue[i].dev == dev)
                {
                    OSRestoreInterrupts (enabled);
                    return 0;
                }
            }
            exi-&gt;queue[exi-&gt;items].callback = unlockedCallback;
            exi-&gt;queue[exi-&gt;items].dev = dev;
            exi-&gt;items++;
        }
        OSRestoreInterrupts (enabled);
        return 0;
    }
    ASSERTLINE (0x409, exi-&gt;items == 0);
    exi-&gt;state |= STATE_LOCKED;
    exi-&gt;dev = dev;
    SetExiInterruptMask (chan, exi);
    OSRestoreInterrupts (enabled);
    return 1;
}

int
EXIUnlock (s32 chan)
{
    EXIControl* exi;
    int         enabled;
    EXICallback unlockedCallback;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x421, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    enabled = OSDisableInterrupts();
    if (!(exi-&gt;state &amp; STATE_LOCKED))
    {
        OSRestoreInterrupts (enabled);
        return 0;
    }
    exi-&gt;state &amp;= ~STATE_LOCKED;
    SetExiInterruptMask (chan, exi);
    if (exi-&gt;items &gt; 0)
    {
        unlockedCallback = exi-&gt;queue[0].callback;
        if (--exi-&gt;items &gt; 0)
        {
            memmove (&amp;exi-&gt;queue[0], &amp;exi-&gt;queue[1], (u32)(exi-&gt;items * 8));
        }
        unlockedCallback (chan, 0);
    }
    OSRestoreInterrupts (enabled);
    return 1;
}

u32
EXIGetState (s32 chan)
{
    EXIControl* exi;

    exi = &amp;Ecb[chan];
    ASSERTLINE (0x446, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    return exi-&gt;state;
}

int
EXIGetID (s32 chan, u32 dev, u32* id)
{
    int err;
    u32 cmd;

    ASSERTLINE (0x45A, 0 &lt;= chan &amp;&amp; chan &lt; MAX_CHAN);
    if ((chan != 2) &amp;&amp; (dev == 0) &amp;&amp; (EXIAttach (chan, 0) == 0))
    {
        return 0;
    }
    err = !EXILock (chan, dev, 0);
    if (err == 0)
    {
        err = !EXISelect (chan, dev, 0);
        if (err == 0)
        {
            cmd = 0;
            err |= !EXIImm (chan, &amp;cmd, 2, 1, 0);
            err |= !EXISync (chan);
            err |= !EXIImm (chan, id, 4, 0, 0);
            err |= !EXISync (chan);
            err |= !EXIDeselect (chan);
        }
        EXIUnlock (chan);
    }
    if ((chan != 2) &amp;&amp; (dev == 0))
    {
        EXIDetach (chan);
    }
    if (err)
    {
        return 0;
    }
    return 1;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>