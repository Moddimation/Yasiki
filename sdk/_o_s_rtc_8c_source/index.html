<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File OSRtc.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-osrtcc">File OSRtc.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_c85f9e83f0f4b4374578811cecebda65/"><strong>os</strong></a> <strong>&gt;</strong> <a href="../_o_s_rtc_8c/"><strong>OSRtc.c</strong></a></p>
<p><a href="../_o_s_rtc_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">
#include &lt;dolphin/exi.h&gt;
#include &lt;dolphin/os.h&gt;

// BOOLernal include
#include &quot;OSPrivate.h&quot;

#define RTC_SRAM_SIZE 64

struct SramControl
{
    u8   sram[RTC_SRAM_SIZE]; 
    u32  offset;              
    BOOL enabled;             
    BOOL locked;              
    BOOL sync;                
    void (*callback)();       
};
static struct SramControl Scb ALIGN (32);

static BOOL  GetRTC (u32* rtc);
static BOOL  ReadSram (void* buffer);
static void  WriteSramCallback ();
static BOOL  WriteSram (void* buffer, u32 offset, u32 size);
static void* LockSram (u32 offset);
static BOOL  UnlockSram (BOOL commit, u32 offset);
static void  __OSReadROMCallback (s32 chan);

static BOOL
GetRTC (u32* rtc)
{
    BOOL err;
    u32  cmd;

    if (!EXILock (0, 1, NULL))
    {
        return FALSE;
    }
    if (!EXISelect (0, 1, 3))
    {
        EXIUnlock (0);
        return FALSE;
    }
    cmd = 0x20000000;
    err = FALSE;
    err |= !EXIImm (0, &amp;cmd, 4, 1, 0);
    err |= !EXISync (0);
    err |= !EXIImm (0, &amp;cmd, 4, 0, 0);
    err |= !EXISync (0);
    err |= !EXIDeselect (0);
    EXIUnlock (0);
    rtc[0] = cmd;
    return !err;
}

BOOL
__OSGetRTC (u32* rtc)
{
    BOOL err;
    u32  t0;
    u32  t1;
    BOOL i;

    for (i = 0; i &lt; 16; i++)
    {
        err = FALSE;
        err |= !GetRTC (&amp;t0);
        err |= !GetRTC (&amp;t1);
        if (err)
        {
            break;
        }
        if (t0 == t1)
        {
            rtc[0] = t0;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
__OSSetRTC (u32 rtc)
{
    BOOL err;
    u32  cmd;

    if (!EXILock (0, 1, NULL))
    {
        return FALSE;
    }
    if (!EXISelect (0, 1, 3))
    {
        EXIUnlock (0);
        return FALSE;
    }
    cmd = 0xA0000000;
    err = FALSE;
    err |= !EXIImm (0, &amp;cmd, 4, 1, 0);
    err |= !EXISync (0);
    err |= !EXIImm (0, &amp;rtc, 4, 1, 0);
    err |= !EXISync (0);
    err |= !EXIDeselect (0);
    EXIUnlock (0);
    return !err;
}

static BOOL
ReadSram (void* buffer)
{
    BOOL err;
    u32  cmd;

    DCInvalidateRange (buffer, RTC_SRAM_SIZE);
    if (!EXILock (0, 1, NULL))
    {
        return FALSE;
    }
    if (!EXISelect (0, 1, 3))
    {
        EXIUnlock (0);
        return FALSE;
    }
    cmd = 0x20000100;
    err = FALSE;
    err |= !EXIImm (0, &amp;cmd, 4, 1, 0);
    err |= !EXISync (0);
    err |= !EXIDma (0, buffer, RTC_SRAM_SIZE, 0, NULL);
    err |= !EXISync (0);
    err |= !EXIDeselect (0);
    EXIUnlock (0);
    return !err;
}

static void
WriteSramCallback ()
{
    BOOL unused;
#pragma unused(unused)

    ASSERTLINE (0xF0, !Scb.locked);
    Scb.sync = WriteSram (&amp;Scb.sram[Scb.offset], Scb.offset, RTC_SRAM_SIZE - Scb.offset);
    if (Scb.sync)
    {
        Scb.offset = RTC_SRAM_SIZE;
    }
    ASSERTLINE (0xF6, Scb.sync);
}

static BOOL
WriteSram (void* buffer, u32 offset, u32 size)
{
    BOOL err;
    u32  cmd;

    if (!EXILock (0, 1, WriteSramCallback))
    {
        return FALSE;
    }
    if (!EXISelect (0, 1, 3))
    {
        EXIUnlock (0);
        return FALSE;
    }
    offset &lt;&lt;= 6;
    cmd = ((offset + 0x100) | 0xA0000000);
    err = FALSE;
    err |= !EXIImm (0, &amp;cmd, 4, 1, 0);
    err |= !EXISync (0);
    err |= !EXIImmEx (0, buffer, (s32)size, 1);
    err |= !EXIDeselect (0);
    EXIUnlock (0);
    return !err;
}

void
__OSInitSram ()
{
    Scb.locked = Scb.enabled = 0;
    Scb.sync = ReadSram (&amp;Scb);
    ASSERTLINE (0x12C, Scb.sync);
    Scb.offset = RTC_SRAM_SIZE;
}

static void*
LockSram (u32 offset)
{
    BOOL enabled;

    enabled = OSDisableInterrupts();
    ASSERTLINE (0x140, !Scb.locked);
    if (Scb.locked)
    {
        OSRestoreInterrupts (enabled);
        return NULL;
    }
    Scb.enabled = enabled;
    Scb.locked = TRUE;
    return &amp;Scb.sram[offset];
}

OSSram*
__OSLockSram ()
{
    return (OSSram*)LockSram (0);
}

OSSramEx*
__OSLockSramEx (void)
{
    return (OSSramEx*)LockSram (0x14);
}

static BOOL
UnlockSram (BOOL commit, u32 offset)
{
    u16* p;

    ASSERTLINE (0x162, Scb.locked);
    if (commit)
    {
        if (!offset)
        {
            OSSram* sram = (struct OSSram*)&amp;Scb.sram;
            if ((sram-&gt;flags &amp; 3) &gt; 2U)
            {
                sram-&gt;flags &amp;= ~3;
            }
            sram-&gt;checkSum = sram-&gt;checkSumInv = 0;
            for (p = (u16*)&amp;sram-&gt;counterBias; p &lt; ((u16*)&amp;Scb.sram[sizeof (OSSram)]); p++)
            {
                sram-&gt;checkSum += *p;
                sram-&gt;checkSumInv += ~(*p);
            }
        }
        if (offset &lt; Scb.offset)
        {
            Scb.offset = offset;
        }
        Scb.sync = WriteSram (Scb.sram + Scb.offset, Scb.offset, RTC_SRAM_SIZE - Scb.offset);
        if (Scb.sync)
        {
            Scb.offset = RTC_SRAM_SIZE;
        }
    }
    Scb.locked = FALSE;
    OSRestoreInterrupts (Scb.enabled);
    return Scb.sync;
}

BOOL
__OSUnlockSram (BOOL commit)
{
    return UnlockSram (commit, 0);
}

BOOL
__OSUnlockSramEx (BOOL commit)
{
    return UnlockSram (commit, 0x14);
}

BOOL
__OSSyncSram ()
{
    return Scb.sync;
}

BOOL
__OSCheckSram ()
{
    u16*    p;
    u16     checkSum;
    u16     checkSumInv;
    OSSram* sram;
    BOOL    unused;
#pragma unused(unused)

    ASSERTLINE (0x1A9, Scb.locked);

    checkSum = checkSumInv = 0;

    sram = (OSSram*)&amp;Scb.sram[0];

    for (p = (void*)&amp;sram-&gt;counterBias; p &lt; (u16*)&amp;Scb.sram[0x14]; p++)
    {
        checkSum += *p;
        checkSumInv += ~(*p);
    }

    return (sram-&gt;checkSum == checkSum &amp;&amp; sram-&gt;checkSumInv == checkSumInv);
}

BOOL
__OSReadROM (void* buffer, s32 length, long offset)
{
    BOOL err;
    u32  cmd;

    ASSERTLINE (0x1C8, length &lt;= 1024);
    DCInvalidateRange (buffer, (u32)length);
    if (!EXILock (0, 1, NULL))
    {
        return FALSE;
    }
    if (!EXISelect (0, 1, 3))
    {
        EXIUnlock (0);
        return FALSE;
    }
    cmd = (u32)(offset &lt;&lt; 6);
    err = FALSE;
    err |= !EXIImm (0, &amp;cmd, 4, 1, 0);
    err |= !EXISync (0);
    err |= !EXIDma (0, buffer, length, 0, NULL);
    err |= !EXISync (0);
    err |= !EXIDeselect (0);
    EXIUnlock (0);
    return !err;
}

static void
__OSReadROMCallback (s32 chan)
{
    void (*callback)();

    EXIDeselect (chan);
    EXIUnlock (chan);
    callback = Scb.callback;
    if (callback)
    {
        Scb.callback = NULL;
        callback();
    }
}

BOOL
__OSReadROMAsync (void* buffer, s32 length, long offset, void (*callback)())
{
    BOOL err;
    u32  cmd;

    ASSERTLINE (0x203, length &lt;= 1024);
    ASSERTLINE (0x204, callback);
    DCInvalidateRange (buffer, (u32)length);
    Scb.callback = callback;
    if (!EXILock (0, 1, NULL))
    {
        return FALSE;
    }
    if (!EXISelect (0, 1, 3))
    {
        EXIUnlock (0);
        return FALSE;
    }
    cmd = (u32)(offset &lt;&lt; 6);
    err = FALSE;
    err |= !EXIImm (0, &amp;cmd, 4, 1, 0);
    err |= !EXISync (0);
    err |= !EXIDma (0, buffer, length, 0, (void*)__OSReadROMCallback);
    return !err;
}

u32
OSGetSoundMode ()
{
    OSSram* sram = __OSLockSram();
    u32     mode = (u32)(sram-&gt;flags &amp; 4) ? (u32)1 : (u32)0;

    __OSUnlockSram (FALSE);
    return mode;
}

void
OSSetSoundMode (u32 mode)
{
    OSSram* sram;
    BOOL    unused;
#pragma unused(unused)

    ASSERTLINE (0x22A, mode == OS_SOUND_MODE_MONO || mode == OS_SOUND_MODE_STEREO);
    mode *= 4;
    mode &amp;= 4;
    sram = __OSLockSram();
    if (mode == (sram-&gt;flags &amp; 4))
    {
        __OSUnlockSram (FALSE);
        return;
    }
    sram-&gt;flags &amp;= 0xFFFFFFFB;
    sram-&gt;flags |= mode;
    __OSUnlockSram (TRUE);
}

u32
OSGetProgressiveMode ()
{
    OSSram* sram;
    BOOL    mode;

    sram = __OSLockSram();
    mode = (sram-&gt;flags &amp; 0x80) ? TRUE : FALSE;
    __OSUnlockSram (FALSE);
    return (u32)mode;
}

void
OSSetProgressiveMode (u32 mode)
{
    char    trash[0x2];       // TODO: intermediate vars or inlines?
    OSSram* sram;
#pragma unused(trash)

    mode &lt;&lt;= 7;
    mode &amp;= 0x80;

    sram = __OSLockSram();
    if (mode == (sram-&gt;flags &amp; 0x80))
    {
        __OSUnlockSram (FALSE);
        return;
    }

    sram-&gt;flags &amp;= ~0x80;
    sram-&gt;flags |= mode;
    __OSUnlockSram (TRUE);
}

u32
OSGetVideoMode ()
{
    OSSram* sram = __OSLockSram();
    u32     mode = (u32)(sram-&gt;flags &amp; 3);

    __OSUnlockSram (FALSE);
    return mode;
}

void
OSSetVideoMode (u32 mode)
{
    OSSram* sram;
    BOOL    unused;
#pragma unused(unused)

    ASSERTLINE (0x249, OS_VIDEO_MODE_NTSC &lt;= mode &amp;&amp; mode &lt;= OS_VIDEO_MODE_MPAL);

    mode &amp;= 3;
    sram = __OSLockSram();
    if (mode == (sram-&gt;flags &amp; 3))
    {
        __OSUnlockSram (FALSE);
        return;
    }
    sram-&gt;flags &amp;= 0xFFFFFFFC;
    sram-&gt;flags |= mode;
    __OSUnlockSram (TRUE);
}

u16
OSGetLanguage ()
{
    OSSram* sram = __OSLockSram();
    u16     language = sram-&gt;language;

    __OSUnlockSram (FALSE);
    return language;
}

void
OSSetLanguage (u16 language)
{
    OSSram* sram = __OSLockSram();
    BOOL    unused;
#pragma unused(unused)

    if (language == sram-&gt;language)
    {
        __OSUnlockSram (FALSE);
        return;
    }
    sram-&gt;language = (u8)language;
    __OSUnlockSram (TRUE);
}

u16
__OSGetBootMode ()
{
    OSSram* sram = __OSLockSram();
    u16     ntd = sram-&gt;ntd;

    __OSUnlockSram (FALSE);

    return (u16)(ntd &amp; 0x80);
}

void
__OSSetBootMode (u16 ntd)
{
    OSSram* sram;
    BOOL    unused;
#pragma unused(unused)

    ntd &amp;= 0x80;
    sram = __OSLockSram();
    if (ntd == (sram-&gt;ntd &amp; 0x80U))
    {
        __OSUnlockSram (FALSE);
        return;
    }
    sram-&gt;ntd &amp;= 0xFFFFFF7F;
    sram-&gt;ntd |= ntd;
    __OSUnlockSram (TRUE);
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>