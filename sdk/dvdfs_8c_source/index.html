<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File dvdfs.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-dvdfsc">File dvdfs.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_6809de60dbef2d995cf7d874d1fa5b65/"><strong>dvd</strong></a> <strong>&gt;</strong> <a href="../dvdfs_8c/"><strong>dvdfs.c</strong></a></p>
<p><a href="../dvdfs_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin.h&gt;
#include &lt;dolphin/dvd.h&gt;

#include &lt;ctype.h&gt;
#include &lt;stddef.h&gt;

#include &quot;dvd_private.h&quot;

typedef struct FSTEntry
{
    u32 isDirAndStringOff; 
    u32 parentOrPosition;  
    u32 nextEntryOrLength; 
} FSTEntry;

// .sbss
static OSBootInfo* BootInfo;              // size: 0x4, address: 0x0
static FSTEntry*   FstStart;              // size: 0x4, address: 0x4
static u8*         FstStringStart;        // size: 0x4, address: 0x8
static u32         MaxEntryNum;           // size: 0x4, address: 0xC
static u32         currentDirectory;      // size: 0x4, address: 0x10
OSThreadQueue      __DVDThreadQueue;      // size: 0x8, address: 0x18
u32                __DVDLongFileNameFlag; // size: 0x4, address: 0x14

// functions
static BOOL isSame (const u8* path, const u8* string);
static u32  myStrncpy (u8* dest, u8* src, u32 maxlen);
static u32  entryToPath (u32 entry, u8* path, u32 maxlen);
static BOOL DVDConvertEntrynumToPath (s32 entrynum, u8* path, u32 maxlen);
static void cbForReadAsync (s32 result, DVDCommandBlock* block);
static void cbForReadSync (s32 result, DVDCommandBlock* block);
static void cbForSeekAsync (s32 result, DVDCommandBlock* block);
static void cbForSeekSync (s32 result, DVDCommandBlock* block);
static void cbForPrepareStreamAsync (s32 result, DVDCommandBlock* block);
static void cbForPrepareStreamSync (s32 result, DVDCommandBlock* block);

void
__DVDFSInit ()
{
    BootInfo = (void*)OSPhysicalToCached (0);
    FstStart = BootInfo-&gt;FSTLocation;
    if (FstStart)
    {
        MaxEntryNum    = FstStart-&gt;nextEntryOrLength;
        FstStringStart = (u8*)FstStart + (MaxEntryNum * 0xC);
    }
}

/* For convenience */
#define entryIsDir(i)   (((FstStart[i].isDirAndStringOff &amp; 0xff000000) == 0) ? FALSE : TRUE)
#define stringOff(i)    (FstStart[i].isDirAndStringOff &amp; ~0xff000000)
#define parentDir(i)    (FstStart[i].parentOrPosition)
#define nextDir(i)      (FstStart[i].nextEntryOrLength)
#define filePosition(i) (FstStart[i].parentOrPosition)
#define fileLength(i)   (FstStart[i].nextEntryOrLength)

static BOOL
isSame (const u8* path, const u8* string)
{
    while (*string != '\0')
    {
        if (tolower (*path++) != tolower (*string++))
        {
            return FALSE;
        }
    }

    if ((*path == '/') || (*path == '\0'))
    {
        return TRUE;
    }

    return FALSE;
}

s32
DVDConvertPathToEntrynum (u8* pathPtr)
{
    const u8* ptr;
    u8*       stringPtr;
    BOOL      isDir;
    u32       length;
    u32       dirLookAt;
    u32       i;
    const u8* origPathPtr = pathPtr;
    const u8* extentionStart;
    BOOL      illegal;
    BOOL      extention;

    ASSERTMSGLINE (0x126, pathPtr, &quot;DVDConvertPathToEntrynum(): null pointer is specified  &quot;);

    dirLookAt = currentDirectory;

    while (1)
    {
        if (*pathPtr == '\0')
        {
            return (s32)dirLookAt;
        }
        else if (*pathPtr == '/')
        {
            dirLookAt = 0;
            pathPtr++;
            continue;
        }
        else if (*pathPtr == '.')
        {
            if (*(pathPtr + 1) == '.')
            {
                if (*(pathPtr + 2) == '/')
                {
                    dirLookAt  = parentDir (dirLookAt);
                    pathPtr   += 3;
                    continue;
                }
                else if (*(pathPtr + 2) == '\0')
                {
                    return (s32)parentDir (dirLookAt);
                }
            }
            else if (*(pathPtr + 1) == '/')
            {
                pathPtr += 2;
                continue;
            }
            else if (*(pathPtr + 1) == '\0')
            {
                return (s32)dirLookAt;
            }
        }

        if (__DVDLongFileNameFlag == 0)
        {
            extention = FALSE;
            illegal   = FALSE;

            for (ptr = pathPtr; (*ptr != '\0') &amp;&amp; (*ptr != '/'); ptr++)
            {
                if (*ptr == '.')
                {
                    if ((ptr - pathPtr &gt; 8) || (extention == TRUE))
                    {
                        illegal = TRUE;
                        break;
                    }
                    extention      = TRUE;
                    extentionStart = ptr + 1;
                }
                else if (*ptr == ' ')
                {
                    illegal = TRUE;
                }
            }

            if ((extention == TRUE) &amp;&amp; (ptr - extentionStart &gt; 3))
            {
                illegal = TRUE;
            }

            if (illegal)
            {
                OSPanic (__FILE__,
                         0x175,
                         &quot;DVDConvertEntrynumToPath(possibly DVDOpen or DVDChangeDir &quot;
                         &quot;or DVDOpenDir): &quot;
                         &quot;specified directory or file (%s) doesn't match standard &quot;
                         &quot;8.3 format. This is a &quot;
                         &quot;temporary restriction and will be removed soon\n&quot;,
                         origPathPtr);
            }
        }
        else
        {
            for (ptr = pathPtr; (*ptr != '\0') &amp;&amp; (*ptr != '/'); ptr++) {}
        }

        isDir  = (*ptr == '\0') ? FALSE : TRUE;
        length = (u32)(ptr - pathPtr);

        ptr    = pathPtr;

        for (i = dirLookAt + 1; i &lt; nextDir (dirLookAt);
             i = entryIsDir (i) ? nextDir (i) : (i + 1))
        {
            if ((entryIsDir (i) == FALSE) &amp;&amp; (isDir == TRUE))
            {
                continue;
            }

            stringPtr = FstStringStart + stringOff (i);

            if (isSame (ptr, stringPtr) == TRUE)
            {
                goto next_hier;
            }
        }

        return -1;

    next_hier:
        if (!isDir)
        {
            return (s32)i;
        }

        dirLookAt  = i;
        pathPtr   += length + 1;
    }
}

BOOL
DVDFastOpen (s32 entrynum, DVDFileInfo* fileInfo)
{
    ASSERTMSGLINE (0x1AF,
                   fileInfo,
                   &quot;DVDFastOpen(): null pointer is specified to file info address  &quot;);
    ASSERTMSG1LINE (0x1B2,
                    (entrynum &gt;= 0) &amp;&amp; ((u32)entrynum &lt; (u32)MaxEntryNum),
                    &quot;DVDFastOpen(): specified entry number '%d' is out of range  &quot;,
                    entrynum);
    ASSERTMSG1LINE (0x1B5,
                    !entryIsDir (entrynum),
                    &quot;DVDFastOpen(): entry number '%d' is assigned to a directory  &quot;,
                    entrynum);

    if ((entrynum &lt; 0) || (entrynum &gt;= MaxEntryNum) || entryIsDir (entrynum))
    {
        return FALSE;
    }

    fileInfo-&gt;startAddr = filePosition (entrynum);
    fileInfo-&gt;length    = fileLength (entrynum);
    fileInfo-&gt;callback  = (DVDCallback)NULL;
    fileInfo-&gt;cb.state  = DVD_STATE_END;

    return TRUE;
}

BOOL
DVDOpen (u8* fileName, DVDFileInfo* fileInfo)
{
    s32 entry;
    u8  currentDir[128];

    ASSERTMSGLINE (0x1D3, fileName, &quot;DVDOpen(): null pointer is specified to file name  &quot;);
    ASSERTMSGLINE (0x1D4,
                   fileInfo,
                   &quot;DVDOpen(): null pointer is specified to file info address  &quot;);

    entry = DVDConvertPathToEntrynum (fileName);

    if (0 &gt; entry)
    {
        DVDGetCurrentDir (currentDir, 128);
        OSReport (&quot;Warning: DVDOpen(): file '%s' was not found under %s.\n&quot;,
                  fileName,
                  currentDir);
        return FALSE;
    }

    if (entryIsDir (entry))
    {
        ASSERTMSG1LINE (0x1E2,
                        !entryIsDir (entry),
                        &quot;DVDOpen(): directory '%s' is specified as a filename  &quot;,
                        fileName);
        return FALSE;
    }

    fileInfo-&gt;startAddr = filePosition (entry);
    fileInfo-&gt;length    = fileLength (entry);
    fileInfo-&gt;callback  = (DVDCallback)NULL;
    fileInfo-&gt;cb.state  = DVD_STATE_END;

    return TRUE;
}

BOOL
DVDClose (DVDFileInfo* fileInfo)
{
    ASSERTMSGLINE (0x1FA,
                   fileInfo,
                   &quot;DVDClose(): null pointer is specified to file info address  &quot;);
    DVDCancel (&amp;(fileInfo-&gt;cb));

    return TRUE;
}

static u32
myStrncpy (u8* dest, u8* src, u32 maxlen)
{
    u32 i = maxlen;

    while ((i &gt; 0) &amp;&amp; (*src != 0))
    {
        *dest++ = *src++;
        i--;
    }

    return (maxlen - i);
}

static u32
entryToPath (u32 entry, u8* path, u32 maxlen)
{
    u8* name;
    u32 loc;

    if (entry == 0)
    {
        return FALSE;
    }

    name = FstStringStart + stringOff (entry);

    loc  = entryToPath (parentDir (entry), path, maxlen);

    if (loc == maxlen)
    {
        return loc;
    }

    *(path + loc++)  = '/';

    loc             += myStrncpy (path + loc, name, maxlen - loc);

    return loc;
}

static BOOL
DVDConvertEntrynumToPath (s32 entrynum, u8* path, u32 maxlen)
{
    u32 loc;

    ASSERTMSG1LINE (0x255,
                    (entrynum &gt;= 0) &amp;&amp; (entrynum &lt; MaxEntryNum),
                    &quot;DVDConvertEntrynumToPath: specified entrynum(%d) is out of range  &quot;,
                    entrynum);
    ASSERTMSG1LINE (0x257,
                    maxlen &gt; 1,
                    &quot;DVDConvertEntrynumToPath: maxlen should be more than 1 (%d is specified)&quot;,
                    maxlen);
    ASSERTMSGLINE (0x25C,
                   entryIsDir (entrynum),
                   &quot;DVDConvertEntrynumToPath: cannot convert an entry num for a file &quot;
                   &quot;to path  &quot;);

    loc = entryToPath ((u32)entrynum, path, maxlen);

    if (loc == maxlen)
    {
        path[maxlen - 1] = '\0';
        return FALSE;
    }

    if (entryIsDir (entrynum))
    {
        if (loc == maxlen - 1)
        {
            path[loc] = '\0';
            return FALSE;
        }

        path[loc++] = '/';
    }

    path[loc] = '\0';

    return TRUE;
}

BOOL
DVDGetCurrentDir (u8* path, u32 maxlen)
{
    ASSERTMSG1LINE (0x286,
                    (maxlen &gt; 1),
                    &quot;DVDGetCurrentDir: maxlen should be more than 1 (%d is specified)&quot;,
                    maxlen);
    return DVDConvertEntrynumToPath ((s32)currentDirectory, path, maxlen);
}

BOOL
DVDChangeDir (u8* dirName)
{
    s32 entry;
    s8  currentDir[128];
#pragma unused(currentDir)

    ASSERTMSGLINE (0x29C,
                   dirName,
                   &quot;DVDChangeDir(): null pointer is specified to directory name  &quot;);
    entry = DVDConvertPathToEntrynum (dirName);
    ASSERTMSG2LINE (0x2A4,
                    entry &gt;= 0,
                    &quot;DVDChangeDir(): directory '%s' is not found under %s  &quot;,
                    dirName,
                    (DVDGetCurrentDir (currentDir, 128), currentDir));
    ASSERTMSG1LINE (0x2A8,
                    entryIsDir (entry),
                    &quot;DVDChangeDir(): file '%s' is specified as a directory name  &quot;,
                    dirName);

    if ((entry &lt; 0) || (entryIsDir (entry) == FALSE))
    {
        return FALSE;
    }

    currentDirectory = (u32)entry;

    return TRUE;
}

BOOL
DVDReadAsyncPrio (DVDFileInfo* fileInfo,
                  void*        addr,
                  s32          length,
                  s32          offset,
                  DVDCallback  callback,
                  s32          prio)
{
    ASSERTMSGLINE (0x2C7,
                   fileInfo,
                   &quot;DVDReadAsync(): null pointer is specified to file info address  &quot;);
    ASSERTMSGLINE (0x2C8, addr, &quot;DVDReadAsync(): null pointer is specified to addr  &quot;);
    ASSERTMSGLINE (0x2CC,
                   !OFFSET (addr, 32),
                   &quot;DVDReadAsync(): address must be aligned with 32 byte boundaries  &quot;);
    ASSERTMSGLINE (0x2CE,
                   !(length &amp; 0x1F),
                   &quot;DVDReadAsync(): length must be  multiple of 32 byte  &quot;);
    ASSERTMSGLINE (0x2D0, !(offset &amp; 3), &quot;DVDReadAsync(): offset must be multiple of 4 byte  &quot;);

    if (!((0 &lt;= offset) &amp;&amp; (offset &lt; fileInfo-&gt;length)))
    {
        OSPanic (__FILE__, 0x2DF, &quot;DVDReadAsync(): specified area is out of the file  &quot;);
    }

    if (!((0 &lt;= offset + length) &amp;&amp;
          (offset + length &lt; fileInfo-&gt;length + DVD_MIN_TRANSFER_SIZE)))
    {
        OSPanic (__FILE__, 0x2E5, &quot;DVDReadAsync(): specified area is out of the file  &quot;);
    }

    fileInfo-&gt;callback = callback;
    DVDReadAbsAsyncPrio (&amp;(fileInfo-&gt;cb),
                         addr,
                         length,
                         (s32)(fileInfo-&gt;startAddr + offset),
                         cbForReadAsync,
                         prio);

    return TRUE;
}

static void
cbForReadAsync (s32 result, DVDCommandBlock* block)
{
    DVDFileInfo* fileInfo;

    fileInfo = (DVDFileInfo*)((u8*)block - offsetof (DVDFileInfo, cb));

    ASSERTLINE (0x2ED, (void*)&amp;fileInfo-&gt;cb == (void*)block);

    if (fileInfo-&gt;callback)
    {
        (fileInfo-&gt;callback) (result, fileInfo);
    }
}

s32
DVDReadPrio (DVDFileInfo* fileInfo, void* addr, s32 length, s32 offset, s32 prio)
{
    BOOL             result;
    DVDCommandBlock* block;
    s32              state;
    BOOL             enabled;
    s32              retVal;

    ASSERTMSGLINE (0x30D,
                   fileInfo,
                   &quot;DVDRead(): null pointer is specified to file info address  &quot;);
    ASSERTMSGLINE (0x30E, addr, &quot;DVDRead(): null pointer is specified to addr  &quot;);
    ASSERTMSGLINE (0x312,
                   !OFFSET (addr, 32),
                   &quot;DVDRead(): address must be aligned with 32 byte boundaries  &quot;);
    ASSERTMSGLINE (0x314, !(length &amp; 0x1F), &quot;DVDRead(): length must be  multiple of 32 byte  &quot;);
    ASSERTMSGLINE (0x316, !(offset &amp; 3), &quot;DVDRead(): offset must be multiple of 4 byte  &quot;);

    if (!((0 &lt;= offset) &amp;&amp; (offset &lt; fileInfo-&gt;length)))
    {
        OSPanic (__FILE__, 0x325, &quot;DVDRead(): specified area is out of the file  &quot;);
    }

    if (!((0 &lt;= offset + length) &amp;&amp;
          (offset + length &lt; fileInfo-&gt;length + DVD_MIN_TRANSFER_SIZE)))
    {
        OSPanic (__FILE__, 0x32B, &quot;DVDRead(): specified area is out of the file  &quot;);
    }

    block  = &amp;fileInfo-&gt;cb;
    result = DVDReadAbsAsyncPrio (block,
                                  addr,
                                  length,
                                  (s32)(fileInfo-&gt;startAddr + offset),
                                  cbForReadSync,
                                  prio);
    if (result == 0)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (1)
    {
        state = ((volatile DVDCommandBlock*)block)-&gt;state;
        if (state == 0)
        {
            retVal = (s32)block-&gt;transferredSize;
            break;
        }
        else if (state == -1)
        {
            retVal = -1;
            break;
        }
        else if (state == 10)
        {
            retVal = -3;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);
    return retVal;
}

static void
cbForReadSync (s32 result, DVDCommandBlock* block)
{
#pragma unused(result)
#pragma unused(block)

    OSWakeupThread (&amp;__DVDThreadQueue);
}

BOOL
DVDSeekAsyncPrio (DVDFileInfo* fileInfo,
                  s32          offset,
                  void         (*callback) (s32, DVDFileInfo*),
                  s32          prio)
{
    ASSERTMSGLINE (0x368,
                   fileInfo,
                   &quot;DVDSeek(): null pointer is specified to file info address  &quot;);
    ASSERTMSGLINE (0x36C, !(offset &amp; 3), &quot;DVDSeek(): offset must be multiple of 4 byte  &quot;);

    if (!((0 &lt;= offset) &amp;&amp; (offset &lt; fileInfo-&gt;length)))
    {
        OSPanic (__FILE__, 0x371, &quot;DVDSeek(): offset is out of the file  &quot;);
    }

    fileInfo-&gt;callback = callback;
    DVDSeekAbsAsyncPrio (&amp;fileInfo-&gt;cb,
                         (s32)(u8*)fileInfo-&gt;startAddr + offset,
                         cbForSeekAsync,
                         prio);

    return TRUE;
}

static void
cbForSeekAsync (s32 result, DVDCommandBlock* block)
{
    DVDFileInfo* fileInfo;

    fileInfo = (DVDFileInfo*)&amp;block-&gt;next;
    ASSERTLINE (0x383, (void*)&amp;fileInfo-&gt;cb == (void*)block);
    if (fileInfo-&gt;callback)
    {
        (fileInfo-&gt;callback) (result, fileInfo);
    }
}

s32
DVDSeekPrio (DVDFileInfo* fileInfo, s32 offset, s32 prio)
{
    BOOL             result;
    DVDCommandBlock* block;
    s32              state;
    BOOL             enabled;
    s32              retVal;

    ASSERTMSGLINE (0x3A1,
                   fileInfo,
                   &quot;DVDSeek(): null pointer is specified to file info address  &quot;);
    ASSERTMSGLINE (0x3A5, !(offset &amp; 3), &quot;DVDSeek(): offset must be multiple of 4 byte  &quot;);
    ASSERTMSGLINE (0x3A9,
                   (offset &gt;= 0) &amp;&amp; ((u32)offset &lt; (u32)fileInfo-&gt;length),
                   &quot;DVDSeek(): offset is out of the file  &quot;);

    block  = &amp;fileInfo-&gt;cb;
    result = DVDSeekAbsAsyncPrio (block,
                                  (s32)(u8*)fileInfo-&gt;startAddr + offset,
                                  cbForSeekSync,
                                  prio);
    if (!result)
    {
        return -1;
    }
    enabled = OSDisableInterrupts();

    while (1)
    {
        state = ((volatile DVDCommandBlock*)block)-&gt;state;
        if (state == 0)
        {
            retVal = 0;
            break;
        }
        else if (state == -1)
        {
            retVal = -1;
            break;
        }
        else if (state == 10)
        {
            retVal = -6;
            break;
        }
        OSSleepThread (&amp;__DVDThreadQueue);
    }
    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForSeekSync (s32 result, DVDCommandBlock* block)
{
#pragma unused(result)
#pragma unused(block)

    OSWakeupThread (&amp;__DVDThreadQueue);
}

s32
DVDGetFileInfoStatus (DVDFileInfo* fileInfo)
{
    return fileInfo-&gt;cb.state;
}

int
DVDOpenDir (u8* dirName, DVDDir* dir)
{
    s32 entry;
#if DEBUG
    s8 currentDir[128];
#endif

    ASSERTMSGLINE (0x401,
                   dirName,
                   &quot;DVDOpendir(): null pointer is specified to directory name  &quot;);
    entry = DVDConvertPathToEntrynum (dirName);
    ASSERTMSG2LINE (0x409,
                    entry &gt;= 0,
                    &quot;DVDOpendir(): directory '%s' is not found under %s  &quot;,
                    dirName,
                    (DVDGetCurrentDir (currentDir, 128), currentDir));
    ASSERTMSG1LINE (0x40E,
                    entryIsDir (entry),
                    &quot;DVDOpendir(): file '%s' is specified as a directory name  &quot;,
                    dirName);
    if (entry &lt; 0 || !entryIsDir (entry))
    {
        return FALSE;
    }
    dir-&gt;entryNum = (u32)entry;
    dir-&gt;location = (u32)entry + 1;
    dir-&gt;next     = nextDir (entry);

    return TRUE;
}

BOOL
DVDReadDir (DVDDir* dir, DVDDirEntry* dirent)
{
    u32 loc;

    loc = dir-&gt;location;
    if ((loc &lt;= (u32)dir-&gt;entryNum) || ((u32)dir-&gt;next &lt;= loc))
    {
        return FALSE;
    }

    dirent-&gt;entryNum = loc;
    dirent-&gt;isDir    = entryIsDir (loc);
    dirent-&gt;name     = FstStringStart + stringOff (loc);
    dir-&gt;location    = entryIsDir (loc) ? nextDir (loc) : loc + 1;

    return TRUE;
}

BOOL
DVDCloseDir (DVDDir* dir)
{
#pragma unused(dir)

    return TRUE;
}

void*
DVDGetFSTLocation ()
{
    return BootInfo-&gt;FSTLocation;
}

#define RoundUp32KB(x)   (((u32)(x) + 32 * 1024 - 1) &amp; ~(32 * 1024 - 1))
#define Is32KBAligned(x) (((u32)(x) &amp; (32 * 1024 - 1)) == 0)

BOOL
DVDPrepareStreamAsync (DVDFileInfo* fileInfo, u32 length, u32 offset, DVDCallback callback)
{
    u32 start;

    ASSERTMSGLINE (0x46C, fileInfo, &quot;DVDPrepareStreamAsync(): NULL file info was specified&quot;);

    start = fileInfo-&gt;startAddr + offset;

    if (!Is32KBAligned (start))
    {
        OSPanic (__FILE__,
                 0x47E,
                 &quot;DVDPrepareStreamAsync(): Specified start address (filestart(0x%x) &quot;
                 &quot;+ offset(0x%x)) is &quot;
                 &quot;not 32KB aligned&quot;,
                 fileInfo-&gt;startAddr,
                 offset);
    }

    if (length == 0)
    {
        length = fileInfo-&gt;length - offset;
    }

    if (!Is32KBAligned (length))
    {
        OSPanic (__FILE__,
                 0x488,
                 &quot;DVDPrepareStreamAsync(): Specified length (0x%x) is not a multiple &quot;
                 &quot;of 32768(32*1024)&quot;,
                 length);
    }

    if (!((offset &lt; fileInfo-&gt;length) &amp;&amp; (offset + length &lt;= fileInfo-&gt;length)))
    {
        OSPanic (__FILE__,
                 0x490,
                 &quot;DVDPrepareStreamAsync(): The area specified (offset(0x%x), &quot;
                 &quot;length(0x%x)) is out of &quot;
                 &quot;the file&quot;,
                 offset,
                 length);
    }

    fileInfo-&gt;callback = callback;

    return DVDPrepareStreamAbsAsync (&amp;(fileInfo-&gt;cb),
                                     length,
                                     fileInfo-&gt;startAddr + offset,
                                     cbForPrepareStreamAsync);
}

static void
cbForPrepareStreamAsync (s32 result, DVDCommandBlock* block)
{
    DVDFileInfo* fileInfo;

    fileInfo = (DVDFileInfo*)((u8*)block - offsetof (DVDFileInfo, cb));

    ASSERTLINE (0x497, (void*)&amp;fileInfo-&gt;cb == (void*)block);

    if (fileInfo-&gt;callback)
    {
        (fileInfo-&gt;callback) (result, fileInfo);
    }
}

/* This is based on the revolution SDK, these may not match in all cases */
s32
DVDPrepareStream (DVDFileInfo* fileInfo, u32 length, u32 offset)
{
    BOOL             result;
    DVDCommandBlock* block;
    s32              state;
    BOOL             enabled;
    s32              retVal;
    u32              start;

    ASSERTMSGLINE (0x4B9, fileInfo, &quot;DVDPrepareStream(): NULL file info was specified&quot;);

    start = fileInfo-&gt;startAddr + offset;

    if (!Is32KBAligned (start))
    {
        OSPanic (__FILE__,
                 0x4BF,
                 &quot;DVDPrepareStream(): Specified start address (filestart(0x%x) + &quot;
                 &quot;offset(0x%x)) is not &quot;
                 &quot;32KB aligned&quot;,
                 fileInfo-&gt;startAddr,
                 offset);
    }

    if (length == 0)
    {
        length = fileInfo-&gt;length - offset;
    }

    if (!Is32KBAligned (length))
    {
        OSPanic (__FILE__,
                 0x4C9,
                 &quot;DVDPrepareStream(): Specified length (0x%x) is not a multiple of &quot;
                 &quot;32768(32*1024)&quot;,
                 length);
    }

    if (!((offset &lt; fileInfo-&gt;length) &amp;&amp; (offset + length &lt;= fileInfo-&gt;length)))
    {
        OSPanic (__FILE__,
                 0x4D1,
                 &quot;DVDPrepareStream(): The area specified (offset(0x%x), &quot;
                 &quot;length(0x%x)) is out of the file&quot;,
                 offset,
                 length);
    }

    block  = &amp;(fileInfo-&gt;cb);
    result = DVDPrepareStreamAbsAsync (block, length, start, cbForPrepareStreamSync);

    if (result == FALSE)
    {
        return -1;
    }

    enabled = OSDisableInterrupts();

    while (1)
    {
        state = ((volatile DVDCommandBlock*)block)-&gt;state;

        if (state == DVD_STATE_END)
        {
            retVal = 0;
            break;
        }
        if (state == DVD_STATE_FATAL_ERROR)
        {
            retVal = DVD_RESULT_FATAL_ERROR;
            break;
        }
        if (state == DVD_STATE_CANCELED)
        {
            retVal = DVD_RESULT_CANCELED;
            break;
        }

        OSSleepThread (&amp;__DVDThreadQueue);
    }

    OSRestoreInterrupts (enabled);

    return retVal;
}

static void
cbForPrepareStreamSync (s32 result, DVDCommandBlock* block)
{
#pragma unused(result)
#pragma unused(block)

    OSWakeupThread (&amp;__DVDThreadQueue);
}

s32
DVDGetTransferredSize (DVDFileInfo* fileinfo)
{
    s32              bytes;
    DVDCommandBlock* cb;

    cb = &amp;(fileinfo-&gt;cb);

    switch (cb-&gt;state)
    {
        case DVD_STATE_COVER_CLOSED:
        case DVD_STATE_NO_DISK:
        case DVD_STATE_COVER_OPEN:
        case DVD_STATE_WRONG_DISK:
        case DVD_STATE_FATAL_ERROR:
        case DVD_STATE_MOTOR_STOPPED:
        case DVD_STATE_CANCELED:
        case DVD_STATE_END:
            bytes = (s32)cb-&gt;transferredSize;
            break;
        case DVD_STATE_WAITING:
            bytes = 0;
            break;
        case DVD_STATE_BUSY:
            bytes = (s32)(cb-&gt;transferredSize + (cb-&gt;currTransferSize - __DIRegs[6]));
            break;
        default:
            ASSERTLINE (0x524, FALSE);
            break;
    }

    return bytes;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>