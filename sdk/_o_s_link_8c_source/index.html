<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File OSLink.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-oslinkc">File OSLink.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_c85f9e83f0f4b4374578811cecebda65/"><strong>os</strong></a> <strong>&gt;</strong> <a href="../_o_s_link_8c/"><strong>OSLink.c</strong></a></p>
<p><a href="../_o_s_link_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/os.h&gt;

#include &lt;string.h&gt;

#include &quot;dolphin/types.h&quot;
#include &quot;OSPrivate.h&quot;

#define SHN_UNDEF             0
#define SHN_LORESERVE         0xff00
#define SHN_LOPROC            0xff00
#define SHN_HIPROC            0xff1f
#define SHN_ABS               0xfff1
#define SHN_COMMON            0xfff2
#define SHN_HIRESERVE         0xffff

#define ELF32_R_SYM(i)        ((i) &gt;&gt; 8)
#define ELF32_R_TYPE(i)       ((u16)(i))
#define ELF32_R_INFO(s, t)    (((s) &lt;&lt; 8) + (u16)(t))

//      Name                    Value       Field   Calculation
#define R_PPC_NONE            0   //  none    none
#define R_PPC_ADDR32          1   //  word32  S + A
#define R_PPC_ADDR24          2   //  low24*  (S + A) &gt;&gt; 2
#define R_PPC_ADDR16          3   //  half16* S + A
#define R_PPC_ADDR16_LO       4   //  half16  #lo(S + A)
#define R_PPC_ADDR16_HI       5   //  half16  #hi(S + A)
#define R_PPC_ADDR16_HA       6   //  half16  #ha(S + A)
#define R_PPC_ADDR14          7   //  low14*  (S + A) &gt;&gt; 2
#define R_PPC_ADDR14_BRTAKEN  8   //  low14*  (S + A) &gt;&gt; 2
#define R_PPC_ADDR14_BRNTAKEN 9   //  low14*  (S + A) &gt;&gt; 2
#define R_PPC_REL24           10  //  low24*  (S + A - P) &gt;&gt; 2
#define R_PPC_REL14           11  //  low14*  (S + A - P) &gt;&gt; 2
#define R_PPC_REL14_BRTAKEN   12  //  low14*  (S + A - P) &gt;&gt; 2
#define R_PPC_REL14_BRNTAKEN  13  //  low14*  (S + A - P) &gt;&gt; 2

#define R_PPC_GOT16           14  //  half16* G + A
#define R_PPC_GOT16_LO        15  //  half16  #lo(G + A)
#define R_PPC_GOT16_HI        16  //  half16  #hi(G + A)
#define R_PPC_GOT16_HA        17  //  half16  #ha(G + A)
#define R_PPC_PLTREL24        18  //  low24*  (L + A - P) &gt;&gt; 2
#define R_PPC_COPY            19  //  none    none
#define R_PPC_GLOB_DAT        20  //  word32  S + A
#define R_PPC_JMP_SLOT        21  //  none
#define R_PPC_RELATIVE        22  //  word32  B + A

#define R_PPC_LOCAL24PC       23  //  low24*

#define R_PPC_UADDR32         24  //  word32  S + A
#define R_PPC_UADDR16         25  //  half16* S + A
#define R_PPC_REL32           26  //  word32  S + A - P

#define R_PPC_PLT32           27  //  word32  L + A
#define R_PPC_PLTREL32        28  //  word32  L + A - P
#define R_PPC_PLT16_LO        29  //  half16  #lo(L + A)
#define R_PPL_PLT16_HI        30  //  half16  #hi(L + A)
#define R_PPC_PLT16_HA        31  //  half16  #ha(L + A)

#define R_PPC_SDAREL16        32  //  half16* S + A - _SDA_BASE_
#define R_PPC_SECTOFF         33  //  half16* R + A
#define R_PPC_SECTOFF_LO      34  //  half16  #lo(R + A)
#define R_PPC_SECTOFF_HI      35  //  half16  #hi(R + A)
#define R_PPC_SECTOFF_HA      36  //  half16  #ha(R + A)
#define R_PPC_ADDR30          37  //  word30  (S + A - P) &gt;&gt; 2

#define R_PPC_EMB_NADDR32     101 //  uword32 N       (A - S)
#define R_PPC_EMB_NADDR16     102 //  uhalf16 Y       (A - S)
#define R_PPC_EMB_NADDR16_LO  103 //  uhalf16 N       #lo(A - S)
#define R_PPC_EMB_NADDR16_HI  104 //  uhalf16 N       #hi(A - S)
#define R_PPC_EMB_NADDR16_HA  105 //  uhalf16 N       #ha(A - S)
#define R_PPC_EMB_SDAI16      106 //  uhalf16 Y       T
#define R_PPC_EMB_SDA2I16     107 //  uhalf16 Y       U
#define R_PPC_EMB_SDA2REL     108 //  uhalf16 Y       S + A - _SDA2_BASE_
#define R_PPC_EMB_SDA21       109 //  ulow21  N
#define R_PPC_EMB_MRKREF      110 //  none    N
#define R_PPC_EMB_RELSEC16    111 //  uhalf16 Y       V + A
#define R_PPC_EMB_RELST_LO    112 //  uhalf16 N       #lo(W + A)
#define R_PPC_EMB_RELST_HI    113 //  uhalf16 N       #hi(W + A)
#define R_PPC_EMB_RELST_HA    114 //  uhalf16 N       #ha(W + A)
#define R_PPC_EMB_BIT_FLD     115 //  uword32 Y
#define R_PPC_EMB_RELSDA      116 //  uhalf16 Y

OSModuleQueue __OSModuleInfoList AT_ADDRESS (OS_BASE_CACHED | 0x30C8);
const void* __OSStringTable      AT_ADDRESS (OS_BASE_CACHED | 0x30D0);

#define ENQUEUE_INFO(queue, info, link)                                                        \
    do {                                                                                       \
        OSModuleInfo* __prev;                                                                  \
                                                                                               \
        __prev = (queue)-&gt;tail;                                                                \
        if (__prev == NULL)                                                                    \
            (queue)-&gt;head = (info);                                                            \
        else                                                                                   \
            __prev-&gt;link.next = (info);                                                        \
        (info)-&gt;link.prev = __prev;                                                            \
        (info)-&gt;link.next = NULL;                                                              \
        (queue)-&gt;tail = (info);                                                                \
    }                                                                                          \
    while (0)

#define DEQUEUE_INFO(info, queue, link)                                                        \
    do {                                                                                       \
        OSModuleInfo* __next;                                                                  \
        OSModuleInfo* __prev;                                                                  \
                                                                                               \
        __next = (info)-&gt;link.next;                                                            \
        __prev = (info)-&gt;link.prev;                                                            \
                                                                                               \
        if (__next == NULL)                                                                    \
            (queue)-&gt;tail = __prev;                                                            \
        else                                                                                   \
            __next-&gt;link.prev = __prev;                                                        \
                                                                                               \
        if (__prev == NULL)                                                                    \
            (queue)-&gt;head = __next;                                                            \
        else                                                                                   \
            __prev-&gt;link.next = __next;                                                        \
    }                                                                                          \
    while (0)

#pragma dont_inline on

void
OSNotifyLink ()
{}

void
OSNotifyUnlink ()
{}

#pragma dont_inline reset

void
OSSetStringTable (const void* stringTable)
{
    __OSStringTable = stringTable;
}

static BOOL
Relocate (OSModuleHeader* newModule, OSModuleHeader* module)
{
    OSModuleID     idNew;
    OSImportInfo*  imp;
    OSRel*         rel;
    OSSectionInfo* si;
    OSSectionInfo* siFlush;
    u32*           p;
    u32            offset;
    u32            x;

    idNew = newModule ? newModule-&gt;info.id : 0;
    for (imp = (OSImportInfo*)module-&gt;impOffset;
         imp &lt; (OSImportInfo*)(module-&gt;impOffset + module-&gt;impSize);
         imp++)
    {
        if (imp-&gt;id == idNew)
        {
            goto Found;
        }
    }
    return FALSE;

Found:
    siFlush = 0;
    for (rel = (OSRel*)imp-&gt;offset; rel-&gt;type != R_DOLPHIN_END; rel++)
    {
        (u8*)p += rel-&gt;offset;
        if (idNew)
        {
            si = &amp;OSGetSectionInfo (newModule)[rel-&gt;section];
            offset = OS_SECTIONINFO_OFFSET (si-&gt;offset);
        }
        else
        {
            offset = 0;
        }
        switch (rel-&gt;type)
        {
            case R_PPC_NONE:
                break;
            case R_PPC_ADDR32:
                x = offset + rel-&gt;addend;
                *p = x;
                break;
            case R_PPC_ADDR24:
                x = offset + rel-&gt;addend;
                *p = (*p &amp; ~0x03fffffc) | (x &amp; 0x03fffffc);
                break;
            case R_PPC_ADDR16:
                x = offset + rel-&gt;addend;
                *(u16*)p = (u16)(x &amp; 0xffff);
                break;
            case R_PPC_ADDR16_LO:
                x = offset + rel-&gt;addend;
                *(u16*)p = (u16)(x &amp; 0xffff);
                break;
            case R_PPC_ADDR16_HI:
                x = offset + rel-&gt;addend;
                *(u16*)p = (u16)(((x &gt;&gt; 16) &amp; 0xffff));
                break;
            case R_PPC_ADDR16_HA:
                x = offset + rel-&gt;addend;
                *(u16*)p = (u16)(((x &gt;&gt; 16) + ((x &amp; 0x8000) ? 1 : 0)) &amp; 0xffff);
                break;
            case R_PPC_REL24:
                x = offset + rel-&gt;addend - (u32)p;
                *p = (*p &amp; ~0x03fffffc) | (x &amp; 0x03fffffc);
                break;
            case R_DOLPHIN_NOP:
                break;
            case R_DOLPHIN_SECTION:
                si = &amp;OSGetSectionInfo (module)[rel-&gt;section];
                p = (u32*)OS_SECTIONINFO_OFFSET (si-&gt;offset);
                if (siFlush)
                {
                    offset = OS_SECTIONINFO_OFFSET (siFlush-&gt;offset);
                    DCFlushRange ((void*)offset, siFlush-&gt;size);
                    ICInvalidateRange ((void*)offset, siFlush-&gt;size);
                }
                siFlush = (si-&gt;offset &amp; OS_SECTIONINFO_EXEC) ? si : 0;
                break;
            default:
                OSReport (&quot;OSLink: unknown relocation type %3d\n&quot;, rel-&gt;type);
                break;
        }
    }

    if (siFlush)
    {
        offset = OS_SECTIONINFO_OFFSET (siFlush-&gt;offset);
        DCFlushRange ((void*)offset, siFlush-&gt;size);
        ICInvalidateRange ((void*)offset, siFlush-&gt;size);
    }

    return TRUE;
}

BOOL
OSLink (OSModuleInfo* newModule, void* bss)
{
    u32             i;
    OSSectionInfo*  si;
    OSModuleHeader* moduleHeader;
    OSModuleInfo*   moduleInfo;
    OSImportInfo*   imp;

    ASSERTLINE (0xEB, newModule-&gt;version == OS_MODULE_VERSION);

    moduleHeader = (OSModuleHeader*)newModule;

    ENQUEUE_INFO (&amp;__OSModuleInfoList, newModule, link);

    memset (bss, 0, moduleHeader-&gt;bssSize);
    newModule-&gt;sectionInfoOffset += (u32)moduleHeader;
    moduleHeader-&gt;relOffset += (u32)moduleHeader;
    moduleHeader-&gt;impOffset += (u32)moduleHeader;

    for (i = 0; i &lt; newModule-&gt;numSections; i++)
    {
        si = &amp;OSGetSectionInfo (newModule)[i];
        if (si-&gt;offset != 0)
        {
            si-&gt;offset += (u32)moduleHeader;
        }
        else if (si-&gt;size != 0)
        {
            si-&gt;offset = (u32)bss;
            bss = (void*)((u32)bss + si-&gt;size);
        }
    }
    for (imp = (OSImportInfo*)moduleHeader-&gt;impOffset;
         imp &lt; (OSImportInfo*)(moduleHeader-&gt;impOffset + moduleHeader-&gt;impSize);
         imp++)
    {
        imp-&gt;offset += (u32)moduleHeader;
    }
    if (moduleHeader-&gt;prologSection != SHN_UNDEF)
    {
        moduleHeader-&gt;prolog += OS_SECTIONINFO_OFFSET (
            OSGetSectionInfo (newModule)[moduleHeader-&gt;prologSection].offset);
    }
    if (moduleHeader-&gt;epilogSection != SHN_UNDEF)
    {
        moduleHeader-&gt;epilog += OS_SECTIONINFO_OFFSET (
            OSGetSectionInfo (newModule)[moduleHeader-&gt;epilogSection].offset);
    }
    if (moduleHeader-&gt;unresolvedSection != SHN_UNDEF)
    {
        moduleHeader-&gt;unresolved += OS_SECTIONINFO_OFFSET (
            OSGetSectionInfo (newModule)[moduleHeader-&gt;unresolvedSection].offset);
    }
    if (__OSStringTable)
    {
        newModule-&gt;nameOffset += (u32)__OSStringTable;
    }

    Relocate (0, moduleHeader);

    for (moduleInfo = __OSModuleInfoList.head; moduleInfo; moduleInfo = moduleInfo-&gt;link.next)
    {
        Relocate (moduleHeader, (OSModuleHeader*)moduleInfo);
        if (moduleInfo != newModule)
        {
            Relocate ((OSModuleHeader*)moduleInfo, moduleHeader);
        }
    }

    OSNotifyLink();

    return TRUE;
}

static BOOL
Undo (OSModuleHeader* newModule, OSModuleHeader* module)
{
    OSModuleID     idNew;
    OSImportInfo*  imp;
    OSRel*         rel;
    OSSectionInfo* si;
    OSSectionInfo* siFlush;
    u32*           p;
    u32            offset;
    u32            x;

    ASSERTLINE (0x147, newModule);
    idNew = newModule-&gt;info.id;
    ASSERTLINE (0x149, idNew);

    for (imp = (OSImportInfo*)module-&gt;impOffset;
         imp &lt; (OSImportInfo*)(module-&gt;impOffset + module-&gt;impSize);
         imp++)
    {
        if (imp-&gt;id == idNew)
        {
            goto Found;
        }
    }
    return FALSE;

Found:
    siFlush = 0;
    for (rel = (OSRel*)imp-&gt;offset; rel-&gt;type != R_DOLPHIN_END; rel++)
    {
        (u8*)p += rel-&gt;offset;
        si = &amp;OSGetSectionInfo (newModule)[rel-&gt;section];
        offset = OS_SECTIONINFO_OFFSET (si-&gt;offset);
        x = 0;
        switch (rel-&gt;type)
        {
            case R_PPC_NONE:
                break;
            case R_PPC_ADDR32:
                *p = x;
                break;
            case R_PPC_ADDR24:
                *p = (*p &amp; ~0x03fffffc) | (x &amp; 0x03fffffc);
                break;
            case R_PPC_ADDR16:
                *(u16*)p = (u16)(x &amp; 0xffff);
                break;
            case R_PPC_ADDR16_LO:
                *(u16*)p = (u16)(x &amp; 0xffff);
                break;
            case R_PPC_ADDR16_HI:
                *(u16*)p = (u16)(((x &gt;&gt; 16) &amp; 0xffff));
                break;
            case R_PPC_ADDR16_HA:
                *(u16*)p = (u16)(((x &gt;&gt; 16) + ((x &amp; 0x8000) ? 1 : 0)) &amp; 0xffff);
                break;
            case R_PPC_REL24:
                if (module-&gt;unresolvedSection != SHN_UNDEF)
                {
                    x = (u32)module-&gt;unresolved - (u32)p;
                }
                *p = (*p &amp; ~0x03fffffc) | (x &amp; 0x03fffffc);
                break;
            case R_DOLPHIN_NOP:
                break;
            case R_DOLPHIN_SECTION:
                si = &amp;OSGetSectionInfo (module)[rel-&gt;section];
                p = (u32*)OS_SECTIONINFO_OFFSET (si-&gt;offset);
                if (siFlush)
                {
                    offset = OS_SECTIONINFO_OFFSET (siFlush-&gt;offset);
                    DCFlushRange ((void*)offset, siFlush-&gt;size);
                    ICInvalidateRange ((void*)offset, siFlush-&gt;size);
                }
                siFlush = (si-&gt;offset &amp; OS_SECTIONINFO_EXEC) ? si : 0;
                break;
            default:
                OSReport (&quot;OSUnlink: unknown relocation type %3d\n&quot;, rel-&gt;type);
                break;
        }
    }

    if (siFlush)
    {
        offset = OS_SECTIONINFO_OFFSET (siFlush-&gt;offset);
        DCFlushRange ((void*)offset, siFlush-&gt;size);
        ICInvalidateRange ((void*)offset, siFlush-&gt;size);
    }

    return TRUE;
}

BOOL
OSUnlink (OSModuleInfo* oldModule)
{
    OSModuleHeader* moduleHeader;
    OSModuleInfo*   moduleInfo;

    ASSERTLINE (0x1AA, oldModule-&gt;version == OS_MODULE_VERSION);
    moduleHeader = (OSModuleHeader*)oldModule;

    DEQUEUE_INFO (oldModule, &amp;__OSModuleInfoList, link);

    for (moduleInfo = __OSModuleInfoList.head; moduleInfo; moduleInfo = moduleInfo-&gt;link.next)
    {
        Undo (moduleHeader, (OSModuleHeader*)moduleInfo);
    }

    OSNotifyUnlink();

    return TRUE;
}

void
__OSModuleInit (void)
{
    __OSModuleInfoList.head = __OSModuleInfoList.tail = 0;
    __OSStringTable = 0;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>