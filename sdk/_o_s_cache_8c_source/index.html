<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File OSCache.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-oscachec">File OSCache.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_c85f9e83f0f4b4374578811cecebda65/"><strong>os</strong></a> <strong>&gt;</strong> <a href="../_o_s_cache_8c/"><strong>OSCache.c</strong></a></p>
<p><a href="../_o_s_cache_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/db.h&gt;
#include &lt;dolphin/os.h&gt;

// Can't use this due to weird condition register issues
// #include &quot;asm_types.h&quot;
#define HID2 920

void DMAErrorHandler (OSError error, OSContext* context, ...);

asm void
DCFlashInvalidate (void)
{
#ifdef __MWERKS__
    nofralloc;
    mfspr r3, HID0;
    ori   r3, r3, 0x400;
    mtspr HID0, r3;
    blr;
#endif
}

asm void
DCEnable (void)
{
#ifdef __MWERKS__
    nofralloc;
    sync;
    mfspr r3, HID0;
    ori   r3, r3, 0x4000;
    mtspr HID0, r3;
    blr;
#endif
}

asm void
DCDisable (void)
{
#ifdef __MWERKS__
    nofralloc;
    sync;
    mfspr  r3, HID0;
    rlwinm r3, r3, 0, 18, 16;
    mtspr  HID0, r3;
    blr;
#endif
}

asm void
DCFreeze (void)
{
#ifdef __MWERKS__
    nofralloc;
    sync;
    mfspr r3, HID0;
    ori   r3, r3, 0x1000;
    mtspr HID0, r3;
    blr;
#endif
}

asm void
DCUnfreeze (void)
{
#ifdef __MWERKS__
    nofralloc;
    mfspr  r3, HID0;
    rlwinm r3, r3, 0, 20, 18;
    mtspr  HID0, r3;
    blr;
#endif
}

asm void
DCTouchLoad (register void* addr)
{
#ifdef __MWERKS__
    nofralloc;
    dcbt r0, addr;
    blr;
#endif
}

asm void
DCBlockZero (register void* addr)
{
#ifdef __MWERKS__
    nofralloc;
    dcbz r0, addr;
    blr;
#endif
}

asm void
DCBlockStore (register void* addr)
{
#ifdef __MWERKS__
    nofralloc;
    dcbst r0, addr;
    blr;
#endif
}

asm void
DCBlockFlush (register void* addr)
{
#ifdef __MWERKS__
    nofralloc;
    dcbf r0, addr;
    blr;
#endif
}

asm void
DCBlockInvalidate (register void* addr)
{
#ifdef __MWERKS__
    nofralloc;
    dcbi r0, addr;
    blr;
#endif
}

asm void
DCInvalidateRange (register void* addr, register u32 nBytes)
{
#ifdef __MWERKS__
    nofralloc;
    cmplwi nBytes, 0;
    blelr;
    clrlwi.r5, addr, 27;
    beq @2;
    addi nBytes, nBytes, 32;

    @2 addi nBytes, nBytes, 31;
    srwi    nBytes, nBytes, 5;
    mtctr   nBytes;

    @1 dcbi r0, addr;
    addi    addr, addr, 32;
    bdnz @1;
    blr;
#endif
}

asm void
DCFlushRange (register void* addr, register u32 nBytes)
{
#ifdef __MWERKS__
    nofralloc;
    cmplwi nBytes, 0;
    blelr;
    clrlwi.r5, addr, 27;
    beq @2;
    addi nBytes, nBytes, 32;

    @2 addi nBytes, nBytes, 31;
    srwi    nBytes, nBytes, 5;
    mtctr   nBytes;

    @1 dcbf r0, addr;
    addi    addr, addr, 32;
    bdnz @1;
    sc;
    blr;
#endif
}

asm void
DCStoreRange (register void* addr, register u32 nBytes)
{
#ifdef __MWERKS__
    nofralloc;
    cmplwi nBytes, 0;
    blelr;
    clrlwi.r5, addr, 27;
    beq @2;
    addi nBytes, nBytes, 32;

    @2 addi nBytes, nBytes, 31;
    srwi    nBytes, nBytes, 5;
    mtctr   nBytes;

    @1 dcbst r0, addr;
    addi     addr, addr, 32;
    bdnz @1;
    sc;

    blr;
#endif
}

asm void
DCFlushRangeNoSync (register void* addr, register u32 nBytes)
{
#ifdef __MWERKS__
    nofralloc;
    cmplwi nBytes, 0;
    blelr;
    clrlwi.r5, addr, 27;
    beq @2;
    addi nBytes, nBytes, 32;

    @2 addi nBytes, nBytes, 31;
    srwi    nBytes, nBytes, 5;
    mtctr   nBytes;

    @1 dcbf r0, addr;
    addi    addr, addr, 32;
    bdnz @1;
    blr;
#endif
}

asm void
DCStoreRangeNoSync (register void* addr, register u32 nBytes)
{
#ifdef __MWERKS__
    nofralloc;
    cmplwi nBytes, 0;
    blelr;
    clrlwi.r5, addr, 27;
    beq @2;
    addi nBytes, nBytes, 32;

    @2 addi nBytes, nBytes, 31;
    srwi    nBytes, nBytes, 5;
    mtctr   nBytes;

    @1 dcbst r0, addr;
    addi     addr, addr, 32;
    bdnz @1;

    blr;
#endif
}

asm void
DCZeroRange (register void* addr, register u32 nBytes)
{
#ifdef __MWERKS__
    nofralloc;
    cmplwi nBytes, 0;
    blelr;
    clrlwi.r5, addr, 27;
    beq @2;
    addi    nBytes, nBytes, 32;
    @2 addi nBytes, nBytes, 31;
    srwi    nBytes, nBytes, 5;
    mtctr   nBytes;

    @1 dcbz r0, addr;
    addi    addr, addr, 32;
    bdnz @1;

    blr;
#endif
}

asm void
DCTouchRange (register void* addr, register u32 nBytes)
{
#ifdef __MWERKS__
    nofralloc;
    cmplwi nBytes, 0;
    blelr;
    clrlwi.r5, addr, 27;
    beq @2;
    addi nBytes, nBytes, 32;

    @2 addi nBytes, nBytes, 31;
    srwi    nBytes, nBytes, 5;
    mtctr   nBytes;

    @1 dcbt r0, addr;
    addi    addr, addr, 32;
    bdnz @1;

    blr;
#endif
}

asm void
ICInvalidateRange (register void* addr, register u32 nBytes)
{
#ifdef __MWERKS__
    nofralloc;
    cmplwi nBytes, 0;
    blelr;
    clrlwi.r5, addr, 27;
    beq @2;
    addi nBytes, nBytes, 32;

    @2 addi nBytes, nBytes, 31;
    srwi    nBytes, nBytes, 5;
    mtctr   nBytes;

    @1 icbi r0, addr;
    addi    addr, addr, 32;
    bdnz @1;
    sync;
    isync;

    blr;
#endif
}

asm void
ICFlashInvalidate (void)
{
#ifdef __MWERKS__
    nofralloc;
    mfspr r3, HID0;
    ori   r3, r3, 0x800;
    mtspr HID0, r3;
    blr;
#endif
}

asm void
ICEnable (void)
{
#ifdef __MWERKS__
    nofralloc;
    isync;
    mfspr r3, HID0;
    ori   r3, r3, 0x8000;
    mtspr HID0, r3;
    blr;
#endif
}

asm void
ICDisable (void)
{
#ifdef __MWERKS__
    nofralloc;
    isync;
    mfspr  r3, HID0;
    rlwinm r3, r3, 0, 17, 15;
    mtspr  HID0, r3;
    blr;
#endif
}

asm void
ICFreeze (void)
{
#ifdef __MWERKS__
    nofralloc;
    isync;
    mfspr r3, HID0;
    ori   r3, r3, 0x2000;
    mtspr HID0, r3;
    blr;
#endif
}

asm void
ICUnfreeze (void)
{
#ifdef __MWERKS__
    nofralloc;
    mfspr  r3, HID0;
    rlwinm r3, r3, 0, 19, 17;
    mtspr  HID0, r3;
    blr;
#endif
}

asm void
ICBlockInvalidate (register void* addr)
{
#ifdef __MWERKS__
    nofralloc;
    icbi r0, addr;
    blr;
#endif
}

asm void
ICSync (void)
{
#ifdef __MWERKS__
    nofralloc;
    isync;
    blr;
#endif
}

#define LC_LINES    512
#define CACHE_LINES 1024

static asm void
__LCEnable (void)
{
#ifdef __MWERKS__
    nofralloc;
    mfmsr r5;
    ori   r5, r5, 0x1000;
    mtmsr r5;

    lis   r3, OS_CACHED_REGION_PREFIX;
    li    r4, CACHE_LINES;
    mtctr r4;

_touchloop:
    dcbt 0, r3;
    dcbst 0, r3;
    addi  r3, r3, 32;
    bdnz  _touchloop;
    mfspr r4, HID2;
    oris  r4, r4, 0x100F;
    mtspr HID2, r4;

    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;

    lis   r3, LC_BASE_PREFIX;
    ori   r3, r3, 0x0002;
    mtspr DBAT3L, r3;
    ori   r3, r3, 0x01fe;
    mtspr DBAT3U, r3;
    isync;
    lis   r3, LC_BASE_PREFIX;
    li    r6, LC_LINES;
    mtctr r6;
    li    r6, 0;

_lockloop:
    dcbz_l r6, r3;
    addi   r3, r3, 32;
    bdnz + _lockloop;

    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;
    nop;

    blr;
#endif
}

void
LCEnable (void)
{
    BOOL enabled;

    enabled = OSDisableInterrupts();
    __LCEnable();
    OSRestoreInterrupts (enabled);
}

asm void
LCDisable (void)
{
#ifdef __MWERKS__
    nofralloc;
    lis   r3, LC_BASE_PREFIX;
    li    r4, LC_LINES;
    mtctr r4;

    @1 dcbi r0, r3;
    addi    r3, r3, 32;
    bdnz @1;
    mfspr  r4, HID2;
    rlwinm r4, r4, 0, 4, 2;
    mtspr  HID2, r4;
    blr;
#endif
}

asm void
LCAllocOneTag (register BOOL invalidate, register void* tag)
{
#ifdef __MWERKS__
    nofralloc;
    cmpwi invalidate, 0;
    beq @1;
    dcbi r0, tag;

    @1 dcbz_l r0, tag;
    blr;
#endif
}

asm void
LCAllocTags (register BOOL invalidate, register void* startTag, register u32 numBlocks)
{
#ifdef __MWERKS__
    nofralloc;
    mflr   r6;
    cmplwi numBlocks, 0;
    ble @3;
    mtctr numBlocks;
    cmpwi invalidate, 0;
    beq @2;

    @1 dcbi r0, startTag;
    dcbz_l  r0, startTag;
    addi    startTag, startTag, 32;
    bdnz @1;
    b @3;

    @2 dcbz_l r0, startTag;
    addi      startTag, startTag, 32;
    bdnz @2;

    @3 mtlr r6;
    blr;
#endif
}

asm void
LCLoadBlocks (register void* destTag, register void* srcAddr, register u32 numBlocks)
{
#ifdef __MWERKS__
    nofralloc;
    rlwinm r6, numBlocks, 30, 27, 31;
    rlwinm srcAddr, srcAddr, 0, 4, 31;
    or r6, r6, srcAddr;
    mtspr  DMA_U, r6;
    rlwinm r6, numBlocks, 2, 28, 29;
    or r6, r6, destTag;
    ori   r6, r6, 0x12;
    mtspr DMA_L, r6;
    blr;
#endif
}

asm void
LCStoreBlocks (register void* destAddr, register void* srcTag, register u32 numBlocks)
{
#ifdef __MWERKS__
    nofralloc;
    rlwinm r6, numBlocks, 30, 27, 31;
    rlwinm destAddr, destAddr, 0, 4, 31;
    or r6, r6, destAddr;
    mtspr  DMA_U, r6;
    rlwinm r6, numBlocks, 2, 28, 29;
    or r6, r6, srcTag;
    ori   r6, r6, 0x2;
    mtspr DMA_L, r6;
    blr;
#endif
}

void
LCAlloc (void* addr, u32 nBytes)
{
    u32 numBlocks = nBytes &gt;&gt; 5;
    u32 hid2 = PPCMfhid2();

    ASSERTMSGLINE (0x530, !((u32)addr &amp; 31), &quot;LCAlloc(): addr must be 32 byte aligned&quot;);
    ASSERTMSGLINE (0x532, !((u32)nBytes &amp; 31), &quot;LCAlloc(): nBytes must be 32 byte aligned&quot;);

    if ((hid2 &amp; 0x10000000) == 0)
    {
        LCEnable();
    }
    LCAllocTags (1, addr, numBlocks);
}

void
LCAllocNoInvalidate (void* addr, u32 nBytes)
{
    u32 numBlocks = nBytes &gt;&gt; 5;
    u32 hid2 = PPCMfhid2();

    ASSERTMSGLINE (0x55F, !((u32)addr &amp; 31), &quot;LCAllocNoFlush(): addr must be 32 byte aligned&quot;);
    ASSERTMSGLINE (0x561,
                   !((u32)nBytes &amp; 31),
                   &quot;LCAllocNoFlush(): nBytes must be 32 byte aligned&quot;);

    if ((hid2 &amp; 0x10000000) == 0)
    {
        LCEnable();
    }
    LCAllocTags (0, addr, numBlocks);
}

u32
LCLoadData (void* destAddr, void* srcAddr, u32 nBytes)
{
    u32 numBlocks = (nBytes + 31) / 32;
    u32 numTransactions = (numBlocks + 128 - 1) / 128;

    ASSERTMSGLINE (0x59B, !((u32)srcAddr &amp; 31), &quot;LCLoadData(): srcAddr not 32 byte aligned&quot;);
    ASSERTMSGLINE (0x59D, !((u32)destAddr &amp; 31), &quot;LCLoadData(): destAddr not 32 byte aligned&quot;);

    while (numBlocks &gt; 0)
    {
        if (numBlocks &lt; 128)
        {
            LCLoadBlocks (destAddr, srcAddr, numBlocks);
            numBlocks = 0;
        }
        else
        {
            LCLoadBlocks (destAddr, srcAddr, 0);
            numBlocks -= 128;
            destAddr = (void*)((u32)destAddr + 4096);
            srcAddr = (void*)((u32)srcAddr + 4096);
        }
    }

    return numTransactions;
}

u32
LCStoreData (void* destAddr, void* srcAddr, u32 nBytes)
{
    u32 numBlocks = (nBytes + 31) / 32;
    u32 numTransactions = (numBlocks + 128 - 1) / 128;

    ASSERTMSGLINE (0x5DF, !((u32)srcAddr &amp; 31), &quot;LCStoreData(): srcAddr not 32 byte aligned&quot;);
    ASSERTMSGLINE (0x5E1, !((u32)destAddr &amp; 31), &quot;LCStoreData(): destAddr not 32 byte aligned&quot;);

    while (numBlocks &gt; 0)
    {
        if (numBlocks &lt; 128)
        {
            LCStoreBlocks (destAddr, srcAddr, numBlocks);
            numBlocks = 0;
        }
        else
        {
            LCStoreBlocks (destAddr, srcAddr, 0);
            numBlocks -= 128;
            destAddr = (void*)((u32)destAddr + 4096);
            srcAddr = (void*)((u32)srcAddr + 4096);
        }
    }

    return numTransactions;
}

asm u32
LCQueueLength (void)
{
#ifdef __MWERKS__
    nofralloc;
    mfspr  r4, HID2;
    rlwinm r3, r4, 8, 28, 31;
    blr;
#endif
}

asm void
LCQueueWait (register u32 len)
{
#ifdef __MWERKS__
    nofralloc;
    addi len, len, 1;

    @1 mfspr r4, HID2;
    rlwinm   r4, r4, 8, 28, 31;
    cmpw     cr2, r4, r3;
    bge      cr2, @1;
    blr;
#endif
}

void
LCFlushQueue ()
{
    union
    {
        u32 val; // offset 0x0, size 0x4

        struct
        {
            // total size: 0x4
            u32 lcAddr     : 27; // offset 0x0, size 0x4
            u32 dmaLd      : 1;  // offset 0x0, size 0x4
            u32 dmaLenL    : 2;  // offset 0x0, size 0x4
            u32 dmaTrigger : 1;  // offset 0x0, size 0x4
            u32 dmaFlush   : 1;  // offset 0x0, size 0x4
        } f;                     // offset 0x0, size 0x4
    } dmaL;                      // r1+0x8

    dmaL.val = 0;
    dmaL.f.dmaFlush = 1;
    PPCMtdmaU (0);
    PPCMtdmaL (dmaL.val);
    PPCSync();
}

static void
L2Init (void)
{
    u32 oldMSR;
    oldMSR = PPCMfmsr();
    __sync();
    PPCMtmsr (MSR_IR | MSR_DR);
    __sync();
    L2Disable();
    L2GlobalInvalidate();
    PPCMtmsr (oldMSR);
}

void
L2Enable (void)
{
    PPCMtl2cr ((PPCMfl2cr() | L2CR_L2E) &amp; ~L2CR_L2I);
}

void
L2Disable (void)
{
    __sync();
    PPCMtl2cr (PPCMfl2cr() &amp; ~0x80000000);
    __sync();
}

void
L2GlobalInvalidate (void)
{
    L2Disable();
    PPCMtl2cr (PPCMfl2cr() | 0x00200000);
    while (PPCMfl2cr() &amp; 0x00000001u) {}
    PPCMtl2cr (PPCMfl2cr() &amp; ~0x00200000);
    while (PPCMfl2cr() &amp; 0x00000001u)
    {
        DBPrintf (&quot;&gt;&gt;&gt; L2 INVALIDATE : SHOULD NEVER HAPPEN\n&quot;);
    }
}

void
L2SetDataOnly (BOOL dataOnly)
{
    if (dataOnly)
    {
        PPCMtl2cr (PPCMfl2cr() | 0x400000);
        return;
    }
    PPCMtl2cr (PPCMfl2cr() &amp; 0xFFBFFFFF);
}

void
L2SetWriteThrough (BOOL writeThrough)
{
    if (writeThrough)
    {
        PPCMtl2cr (PPCMfl2cr() | 0x80000);
        return;
    }
    PPCMtl2cr (PPCMfl2cr() &amp; 0xFFF7FFFF);
}

void
DMAErrorHandler (OSError error, OSContext* context, ...)
{
#pragma unused(error)

    u32 hid2 = PPCMfhid2();

    OSReport (&quot;Machine check received\n&quot;);
    OSReport (&quot;HID2 = 0x%x   SRR1 = 0x%x\n&quot;, hid2, context-&gt;srr1);
    if (!(hid2 &amp; (HID2_DCHERR | HID2_DNCERR | HID2_DCMERR | HID2_DQOERR)) ||
        !(context-&gt;srr1 &amp; SRR1_DMA_BIT))
    {
        OSReport (&quot;Machine check was not DMA/locked cache related\n&quot;);
        OSDumpContext (context);
        PPCHalt();
    }

    OSReport (&quot;DMAErrorHandler(): An error occurred while processing DMA.\n&quot;);
    OSReport (&quot;The following errors have been detected and cleared :\n&quot;);

    if (hid2 &amp; HID2_DCHERR)
    {
        OSReport (&quot;\t- Requested a locked cache tag that was already in the cache\n&quot;);
    }

    if (hid2 &amp; HID2_DNCERR)
    {
        OSReport (&quot;\t- DMA attempted to access normal cache\n&quot;);
    }

    if (hid2 &amp; HID2_DCMERR)
    {
        OSReport (&quot;\t- DMA missed in data cache\n&quot;);
    }

    if (hid2 &amp; HID2_DQOERR)
    {
        OSReport (&quot;\t- DMA queue overflowed\n&quot;);
    }

    // write hid2 back to clear the error bits
    PPCMthid2 (hid2);
}

void
__OSCacheInit ()
{
    if (!(PPCMfhid0() &amp; HID0_ICE))
    {
        ICEnable();
        DBPrintf (&quot;L1 i-caches initialized\n&quot;);
    }
    if (!(PPCMfhid0() &amp; HID0_DCE))
    {
        DCEnable();
        DBPrintf (&quot;L1 d-caches initialized\n&quot;);
    }

    if (!(PPCMfl2cr() &amp; L2CR_L2E))
    {
        L2Init();
        L2Enable();
        DBPrintf (&quot;L2 cache initialized\n&quot;);
    }

    OSSetErrorHandler (OS_ERROR_MACHINE_CHECK, DMAErrorHandler);
    DBPrintf (&quot;Locked cache machine check handler installed\n&quot;);
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>