<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File GXMisc.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-gxmiscc">File GXMisc.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_b80c028b3e970eff7f2a07684ffcf104/"><strong>gx</strong></a> <strong>&gt;</strong> <a href="../_g_x_misc_8c/"><strong>GXMisc.c</strong></a></p>
<p><a href="../_g_x_misc_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/base/PPCArch.h&gt;
#include &lt;dolphin/gx.h&gt;
#include &lt;dolphin/os.h&gt;

#include &lt;stddef.h&gt;

#include &quot;GXPrivate.h&quot;

static GXDrawSyncCallback TokenCB;
static GXDrawDoneCallback DrawDoneCB;
static u8                 DrawDone;
static OSThreadQueue      FinishQueue;

void
GXSetMisc (GXMiscToken token, u32 val)
{
    switch (token)
    {
        case GX_MT_XF_FLUSH:
            __GXData-&gt;vNum = (u16)val;
            if (__GXData-&gt;vNum != 0)
            {
                __GXData-&gt;dirtyState |= 8;
            }
            break;
        case GX_MT_DL_SAVE_CONTEXT:
            ASSERTMSGLINE (0xC4,
                           !__GXData-&gt;inDispList,
                           &quot;GXSetMisc: Cannot change DL context setting while making &quot;
                           &quot;a display list&quot;);
            __GXData-&gt;dlSaveContext = (val &gt; 0);
            break;
        case GX_MT_NULL:
            break;
        default:
#if DEBUG
            OSReport (&quot;GXSetMisc: bad token %d (val %d)\n&quot;, token, val);
#endif
            break;
    }
}

void
GXFlush (void)
{
    u32 i;

    CHECK_GXBEGIN (0xF0, &quot;GXFlush&quot;);
    if (__GXData-&gt;dirtyState)
    {
        __GXSetDirtyState();
    }
    for (i = 32; i &gt; 0; i--) { GX_WRITE_U8 (0); }
    PPCSync();
}

void
GXResetWriteGatherPipe (void)
{
    while (PPCMfwpar() &amp; 1) {}
    PPCMtwpar (OSUncachedToPhysical ((void*)GXFIFO_ADDR));
}

static inline void
__GXAbortWait (u32 clocks)
{
    OSTime time0;
    OSTime time1;

    time0 = OSGetTime();
    do {
        time1 = OSGetTime();
    }
    while (time1 - time0 &lt;= (clocks / 4));
}

void
GXAbortFrame (void)
{
    GX_SET_PI_REG (6, 1);
    __GXAbortWait (0xC8U);
    GX_SET_PI_REG (6, 0);
    __GXAbortWait (0x14U);
    __GXCleanGPFifo();
}

void
GXSetDrawSync (u16 token)
{
    BOOL enabled;
    u32  reg;

    CHECK_GXBEGIN (0x162, &quot;GXSetDrawSync&quot;);

    enabled = OSDisableInterrupts();
    reg     = (u32)(token | 0x48000000);
    GX_WRITE_RAS_REG (reg);
    SET_REG_FIELD (0x16F, reg, 16, 0, token);
    SET_REG_FIELD (0x170, reg, 8, 24, 0x47);
    GX_WRITE_RAS_REG (reg);
    GXFlush();

    OSRestoreInterrupts (enabled);

    __GXData-&gt;bpSent = 1;
}

u16
GXReadDrawSync (void)
{
    u16 token = GX_GET_PE_REG (7);
    return token;
}

void
GXSetDrawDone (void)
{
    u32  reg;
    BOOL enabled;

    CHECK_GXBEGIN (0x19C, &quot;GXSetDrawDone&quot;);
    enabled = OSDisableInterrupts();
    reg     = 0x45000002;
    GX_WRITE_RAS_REG (reg);
    GXFlush();
    DrawDone = 0;

    OSRestoreInterrupts (enabled);
}

void
GXWaitDrawDone (void)
{
    BOOL enabled;

    CHECK_GXBEGIN (0x1CA, &quot;GXWaitDrawDone&quot;);

    enabled = OSDisableInterrupts();
    while (!DrawDone) { OSSleepThread (&amp;FinishQueue); }
    OSRestoreInterrupts (enabled);
}

void
GXDrawDone (void)
{
    CHECK_GXBEGIN (0x1EA, &quot;GXDrawDone&quot;);
    GXSetDrawDone();
    GXWaitDrawDone();
}

void
GXPixModeSync (void)
{
    CHECK_GXBEGIN (0x20D, &quot;GXPixModeSync&quot;);
    GX_WRITE_RAS_REG (__GXData-&gt;peCtrl);
    __GXData-&gt;bpSent = 1;
}

void
GXTexModeSync (void)
{
    u32 reg;

    CHECK_GXBEGIN (0x225, &quot;GXTexModeSync&quot;);
    reg = 0x63000000;
    GX_WRITE_RAS_REG (reg);
    __GXData-&gt;bpSent = 1;
}
#if DEBUG
void
__GXBypass (u32 reg)
{
    CHECK_GXBEGIN (0x23B, &quot;__GXBypass&quot;);
    GX_WRITE_RAS_REG (reg);
    __GXData-&gt;bpSent = 1;
}

u16
__GXReadPEReg (u32 reg)
{
    return __peReg[reg];
}
#endif
void
GXPokeAlphaMode (GXCompare func, u8 threshold)
{
    u32 reg;

    CHECK_GXBEGIN (0x25F, &quot;GXPokeAlphaMode&quot;);
    reg = (u32)((func &lt;&lt; 8) | threshold);
    GX_SET_PE_REG (PE_PI_ALPHA_THRESHOLD_ID, reg);
}

void
GXPokeAlphaRead (GXAlphaReadMode mode)
{
    u32 reg;

    CHECK_GXBEGIN (0x26A, &quot;GXPokeAlphaRead&quot;);
    reg = 0;
    SET_REG_FIELD (0x26D, reg, 2, 0, mode);
    SET_REG_FIELD (0x26E, reg, 1, 2, 1);
    GX_SET_PE_REG (4, reg);
}

void
GXPokeAlphaUpdate (GXBool update_enable)
{
    u32 reg;

    CHECK_GXBEGIN (0x277, &quot;GXPokeAlphaUpdate&quot;);
    reg = GX_GET_PE_REG (1);
    SET_REG_FIELD (0x27A, reg, 1, 4, update_enable);
    GX_SET_PE_REG (1, reg);
}

void
GXPokeBlendMode (GXBlendMode   type,
                 GXBlendFactor src_factor,
                 GXBlendFactor dst_factor,
                 GXLogicOp     op)
{
    u32 reg;

    CHECK_GXBEGIN (0x284, &quot;GXPokeBlendUpdate&quot;);
    reg = GX_GET_PE_REG (1);
    SET_REG_FIELD (0x28C, reg, 1, 0, (type == GX_BM_BLEND) || (type == GX_BM_SUBTRACT));
    SET_REG_FIELD (0x28D, reg, 1, 11, (type == GX_BM_SUBTRACT));
    SET_REG_FIELD (0x28F, reg, 1, 1, (type == GX_BM_LOGIC));
    SET_REG_FIELD (0x290, reg, 4, 12, op);
    SET_REG_FIELD (0x291, reg, 3, 8, src_factor);
    SET_REG_FIELD (0x292, reg, 3, 5, dst_factor);
    SET_REG_FIELD (0x293, reg, 8, 24, 0x41);
    GX_SET_PE_REG (1, reg);
}

void
GXPokeColorUpdate (GXBool update_enable)
{
    u32 reg;

    CHECK_GXBEGIN (0x29D, &quot;GXPokeColorUpdate&quot;);
    reg = GX_GET_PE_REG (1);
    SET_REG_FIELD (0x2A0, reg, 1, 3, update_enable);
    GX_SET_PE_REG (1, reg);
}

void
GXPokeDstAlpha (GXBool enable, u8 alpha)
{
    u32 reg = 0;

    CHECK_GXBEGIN (0x2A9, &quot;GXPokeDstAlpha&quot;);
    SET_REG_FIELD (0x2AB, reg, 8, 0, alpha);
    SET_REG_FIELD (0x2AC, reg, 1, 8, enable);
    GX_SET_PE_REG (2, reg);
}

void
GXPokeDither (GXBool dither)
{
    u32 reg;

    CHECK_GXBEGIN (0x2B5, &quot;GXPokeDither&quot;);
    reg = GX_GET_PE_REG (1);
    SET_REG_FIELD (0x2B8, reg, 1, 2, dither);
    GX_SET_PE_REG (1, reg);
}

void
GXPokeZMode (GXBool compare_enable, GXCompare func, GXBool update_enable)
{
    u32 reg = 0;

    CHECK_GXBEGIN (0x2C1, &quot;GXPokeZMode&quot;);

    SET_REG_FIELD (0x2C3, reg, 1, 0, compare_enable);
    SET_REG_FIELD (0x2C4, reg, 3, 1, func);
    SET_REG_FIELD (0x2C5, reg, 1, 4, update_enable);
    GX_SET_PE_REG (0, reg);
}

void
GXPeekARGB (u16 x, u16 y, u32* color)
{
    u32 addr = (u32)OSPhysicalToUncached (0x08000000);

    SET_REG_FIELD (0x2DC, addr, 10, 2, x);
    SET_REG_FIELD (0x2DD, addr, 10, 12, y);
    SET_REG_FIELD (0x2DE, addr, 2, 22, 0);
    *color = *(u32*)addr;
}

void
GXPokeARGB (u16 x, u16 y, u32 color)
{
    u32 addr = (u32)OSPhysicalToUncached (0x08000000);

    SET_REG_FIELD (0x2E6, addr, 10, 2, x);
    SET_REG_FIELD (0x2E7, addr, 10, 12, y);
    SET_REG_FIELD (0x2E8, addr, 2, 22, 0);
    *(u32*)addr = color;
}

void
GXPeekZ (u16 x, u16 y, u32* z)
{
    u32 addr = (u32)OSPhysicalToUncached (0x08000000);

    SET_REG_FIELD (0x2F0, addr, 10, 2, x);
    SET_REG_FIELD (0x2F1, addr, 10, 12, y);
    SET_REG_FIELD (0x2F2, addr, 2, 22, 1);
    *z = *(u32*)addr;
}

void
GXPokeZ (u16 x, u16 y, u32 z)
{
    u32 addr = (u32)OSPhysicalToUncached (0x08000000);

    SET_REG_FIELD (0x2FA, addr, 10, 2, x);
    SET_REG_FIELD (0x2FB, addr, 10, 12, y);
    SET_REG_FIELD (0x2FC, addr, 2, 22, 1);
    *(u32*)addr = z;
}

GXDrawSyncCallback
GXSetDrawSyncCallback (GXDrawSyncCallback cb)
{
    GXDrawSyncCallback oldcb;
    BOOL               enabled;

    oldcb   = TokenCB;
    enabled = OSDisableInterrupts();
    TokenCB = cb;

    OSRestoreInterrupts (enabled);

    return oldcb;
}

static void
GXTokenInterruptHandler (__OSInterrupt interrupt, OSContext* context)
{
#pragma unused(interrupt)

    u16       token;
    OSContext exceptionContext;
    u32       reg;

    token = GX_GET_PE_REG (7);
    if (TokenCB != NULL)
    {
        OSClearContext (&amp;exceptionContext);
        OSSetCurrentContext (&amp;exceptionContext);
        TokenCB (token);
        OSClearContext (&amp;exceptionContext);
        OSSetCurrentContext (context);
    }
    reg = GX_GET_PE_REG (5);
    SET_REG_FIELD (0, reg, 1, 2, 1);
    GX_SET_PE_REG (5, reg);
}

GXDrawDoneCallback
GXSetDrawDoneCallback (GXDrawDoneCallback cb)
{
    GXDrawDoneCallback oldcb;
    BOOL               enabled;

    oldcb      = DrawDoneCB;
    enabled    = OSDisableInterrupts();
    DrawDoneCB = cb;

    OSRestoreInterrupts (enabled);

    return oldcb;
}

static void
GXFinishInterruptHandler (__OSInterrupt interrupt, OSContext* context)
{
#pragma unused(interrupt)

    OSContext exceptionContext;
    u32       reg;

    reg = GX_GET_PE_REG (5);
    SET_REG_FIELD (0, reg, 1, 3, 1);
    GX_SET_PE_REG (5, reg);
    DrawDone = 1;
    if (DrawDoneCB != NULL)
    {
        OSClearContext (&amp;exceptionContext);
        OSSetCurrentContext (&amp;exceptionContext);
        DrawDoneCB();
        OSClearContext (&amp;exceptionContext);
        OSSetCurrentContext (context);
    }
    OSWakeupThread (&amp;FinishQueue);
}

void
__GXPEInit (void)
{
    u32 reg;
    __OSSetInterruptHandler (0x12, GXTokenInterruptHandler);
    __OSSetInterruptHandler (0x13, GXFinishInterruptHandler);
    OSInitThreadQueue (&amp;FinishQueue);
    __OSUnmaskInterrupts (0x2000);
    __OSUnmaskInterrupts (0x1000);
    reg = GX_GET_PE_REG (5);
    SET_REG_FIELD (0, reg, 1, 2, 1);
    SET_REG_FIELD (0, reg, 1, 3, 1);
    SET_REG_FIELD (0, reg, 1, 0, 1);
    SET_REG_FIELD (0, reg, 1, 1, 1);
    GX_SET_PE_REG (5, reg);
}

u32
GXCompressZ16 (u32 z24, GXZFmt16 zfmt)
{
    u32 z16;
    u32 z24n;
    s32 exp;
    s32 shift;
#if DEBUG
#define temp exp
#else
    s32 temp;
    u8  unused[4];
#pragma unused(unused)
#endif

    z24n = ~(z24 &lt;&lt; 8);
    temp = __cntlzw (z24n);
    switch (zfmt)
    {
        case GX_ZC_LINEAR:
            z16 = (z24 &gt;&gt; 8) &amp; 0xFFFF;
            break;
        case GX_ZC_NEAR:
            if (temp &gt; 3)
            {
                exp = 3;
            }
            else
            {
                exp = temp;
            }
            if (exp == 3)
            {
                shift = 7;
            }
            else
            {
                shift = 9 - exp;
            }
            z16 = ((z24 &gt;&gt; shift) &amp; 0x3FFF &amp; ~0xFFFFC000) | (exp &lt;&lt; 14);
            break;
        case GX_ZC_MID:
            if (temp &gt; 7)
            {
                exp = 7;
            }
            else
            {
                exp = temp;
            }
            if (exp == 7)
            {
                shift = 4;
            }
            else
            {
                shift = 10 - exp;
            }
            z16 = ((z24 &gt;&gt; shift) &amp; 0x1FFF &amp; ~0xFFFFE000) | (exp &lt;&lt; 13);
            break;
        case GX_ZC_FAR:
            if (temp &gt; 12)
            {
                exp = 12;
            }
            else
            {
                exp = temp;
            }
            if (exp == 12)
            {
                shift = 0;
            }
            else
            {
                shift = 11 - exp;
            }
            z16 = ((z24 &gt;&gt; shift) &amp; 0xFFF &amp; ~0xFFFFF000) | (exp &lt;&lt; 12);
            break;
        default:
            OSPanic (__FILE__, 0x3B0, &quot;GXCompressZ16: Invalid Z format\n&quot;);
            break;
    }

    return z16;
}

u32
GXDecompressZ16 (u32 z16, GXZFmt16 zfmt)
{
    u32 z24;
    u32 cb1;
    s32 exp;
    s32 shift;

#ifdef __MWERKS__
    cb1;
    cb1;
    cb1;
    z16;
    z16;
    z16; // needed to match
#endif

    switch (zfmt)
    {
        case GX_ZC_LINEAR:
            z24 = (z16 &lt;&lt; 8) &amp; 0xFFFF00;
            break;
        case GX_ZC_NEAR:
            exp = (s32)((z16 &gt;&gt; 14) &amp; 3);
            if (exp == 3)
            {
                shift = 7;
            }
            else
            {
                shift = 9 - exp;
            }
            cb1 = (u32)(-1 &lt;&lt; (24 - exp));
            z24 = (cb1 | ((z16 &amp; 0x3FFF) &lt;&lt; shift)) &amp; 0xFFFFFF;
            break;
        case GX_ZC_MID:
            exp = (s32)((z16 &gt;&gt; 13) &amp; 7);
            if (exp == 7)
            {
                shift = 4;
            }
            else
            {
                shift = 10 - exp;
            }
            cb1 = (u32)(-1 &lt;&lt; (24 - exp));
            z24 = (cb1 | ((z16 &amp; 0x1FFF) &lt;&lt; shift)) &amp; 0xFFFFFF;
            break;
        case GX_ZC_FAR:
            exp = (s32)((z16 &gt;&gt; 12) &amp; 0xF);
            if (exp == 12)
            {
                shift = 0;
            }
            else
            {
                shift = 11 - exp;
            }
            cb1 = (u32)(-1 &lt;&lt; (24 - exp));
            z24 = (cb1 | ((z16 &amp; 0xFFF) &lt;&lt; shift)) &amp; 0xFFFFFF;
            break;
        default:
            OSPanic (__FILE__, 0x3E2, &quot;GXDecompressZ16: Invalid Z format\n&quot;);
            break;
    }

    return z24;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>