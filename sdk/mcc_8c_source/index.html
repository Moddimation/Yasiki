<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File mcc.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-mccc">File mcc.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_09af956a0e77733960814cc502aa891a/"><strong>mcc</strong></a> <strong>&gt;</strong> <a href="../mcc_8c/"><strong>mcc.c</strong></a></p>
<p><a href="../mcc_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/mcc.h&gt;

#include &lt;dolphin.h&gt;

// .bss
static MCC_ChannelInfo gChannelInfo[16] ALIGN (32);
static s8              gStreamWork[32] ALIGN (32);
static s8              m_szAdapterMode[32] ALIGN (32);
static s8              m_szInitCode[32] ALIGN (32);
static MCC_Info        channelInfo[16] ALIGN (32);

// .sdata
volatile static int gIsChannelinfoDirty = 1;

// .sbss
static void         (* volatile gCallbackSysEvent) (enum MCC_SYSEVENT);
static int          gOtherSideInitDone;
volatile static u16 gLastError;
static int          gMccInitialized;
static int          gMccSession;
volatile static int gPingFlag;
volatile static u16 gAsyncResourceStatus;

// functions
static void mccDebugPrint (char* str);
static void callbackEventStream (enum MCC_CHANNEL chID, u32 event, u32 value);
static int  SetUsbAdapterMode (u8 mode);
static u8   GetUsbAdapterMode (void);
static int  InitializeCodeClear (void);
static int  InitializeCodeSet (void);
static int  InitializeCodeCheck (void);
static void AsyncResourceClearState (void);
static void AsyncResourceSetState (u16 state);
static void AsyncResourceStateBusy (u8 channel, u16 mode);
static void AsyncResourceStateDone (void);
static u16  AsyncResourceGetStat (void);
static u16  AsyncResourceGetMode (void);
static u8   AsyncResourceGetChannel (void);
static int  AsyncResourceIsBusy (void);
static int  LoadChannelInfo (MCC_ChannelInfo* info);
static int  FlushChannelInfo (MCC_ChannelInfo* info);
static void SetChannelInfoDirty (int dirty);
static void ClearChannelInfo (int i);
static void MakeMemoryMap (u8* map);
static int  IsChannelOpened (enum MCC_CHANNEL chID);
static u8   SearchFreeBlocks (enum MCC_MODE mode, u8* index);
static int  NotifyCompulsorily (enum MCC_CHANNEL chID, u32 notify, u32 timeout);
static int  NotifyInit (void);
static int  NotifyInitDone (void);
static int  NotifyChannelEvent (enum MCC_CHANNEL chID, u32 notify);
static int  WaitAMinute (int timeout, volatile int* flag, int value);
static void MailboxCheck (void);
static void MCCExiCallback (void);
static void MCCTxCallback (void);
static void MCCRxCallback (void);
static int  mccInitializeCheck (u8 timeout);

static void
mccDebugPrint (char* str)
{
}

static void
callbackEventStream (enum MCC_CHANNEL chID, u32 event, u32 value)
{
    value;      // needed to bump registers. what?
    if (event == 16)
    {
        gChannelInfo[chID].isStreamDone = 1;
    }
    if (event == 32)
    {
        gChannelInfo[chID].isStreamDone = 1;
    }
    if (event == 1)
    {
        gChannelInfo[chID].isStreamConnection = 1;
    }
    if (event == 2)
    {
        gChannelInfo[chID].isStreamConnection = 1;
    }
}

int
MCCStreamOpen (enum MCC_CHANNEL chID, u8 blockSize)
{
    int bResult;

    bResult = 0;
    if (MCCOpen (chID, blockSize, callbackEventStream) != 0)
    {
        gChannelInfo[chID].isStreamDone = 0;
        gChannelInfo[chID].isStreamConnection = 0;
        bResult = 1;
    }
    return bResult;
}

int
MCCStreamClose (enum MCC_CHANNEL chID)
{
    MCCClose (chID);
}

int
MCCStreamWrite (enum MCC_CHANNEL chID, void* data, u32 dataBlockSize)
{
    MCC_Info chanInfo;
    char*    dataAddress;
    u32      lastBlocks;

    if (gMccInitialized == 0)
    {
        gLastError = 1;
    }
    else if ((chID &lt; 1) || (chID &gt;= 16))
    {
        gLastError = 14;
    }
    else if (LoadChannelInfo (gChannelInfo) == 0)
    {
        gLastError = 11;
    }
    else if (WaitAMinute (5, &amp;gChannelInfo[chID].isStreamConnection, 1) == 0)
    {
        gLastError = 2;
    }
    else
    {
        gChannelInfo[chID].isStreamConnection = 0;
        if (MCCGetChannelInfo (chID, &amp;chanInfo) != 0)
        {
            *(u32*)&amp;gStreamWork = dataBlockSize;
            if (MCCWrite (chID, 0, gStreamWork, 0x20, 0) != 0)
            {
                if (WaitAMinute (5, &amp;gChannelInfo[chID].isStreamDone, 1) == 0)
                {
                    gLastError = 2;
                }
                else
                {
                    dataAddress = data;
                    lastBlocks = dataBlockSize;
                    gChannelInfo[chID].isStreamDone = 0;
                    while (lastBlocks)
                    {
                        if (!MCCWrite (chID, 0, dataAddress, chanInfo.blockLength &lt;&lt; 0xD, 0))
                        {
                            break;
                        }
                        if (WaitAMinute (5, &amp;gChannelInfo[chID].isStreamDone, 1) == 0)
                        {
                            gLastError = 2;
                            break;
                        }
                        else
                        {
                            gChannelInfo[chID].isStreamDone = 0;
                            dataAddress += chanInfo.blockLength &lt;&lt; 0xD;
                            if (lastBlocks &gt; chanInfo.blockLength)
                            {
                                lastBlocks -= chanInfo.blockLength;
                            }
                            else
                            {
                                lastBlocks = 0;
                                break;
                            }
                        }
                    }
                    return lastBlocks == 0;
                }
            }
        }
    }
exit:;
    return 0;
}

u32
MCCStreamRead (enum MCC_CHANNEL chID, void* data)
{
    MCC_Info chanInfo;
    char*    dataAddress;
    u32      allBlocks;
    u32      lastBlocks;

    if (gMccInitialized == 0)
    {
        gLastError = 1;
    }
    else if ((chID &lt; 1) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
    }
    else if (LoadChannelInfo (gChannelInfo) == 0)
    {
        gLastError = 0xB;
    }
    else if (WaitAMinute (5, &amp;gChannelInfo[chID].isStreamConnection, 1) == 0)
    {
        gLastError = 2;
    }
    else
    {
        gChannelInfo[chID].isStreamConnection = 0;
        if (MCCGetChannelInfo (chID, &amp;chanInfo) != 0)
        {
            if (WaitAMinute (5, &amp;gChannelInfo[chID].isStreamDone, 1) == 0)
            {
                gLastError = 2;
            }
            else
            {
                gChannelInfo[chID].isStreamDone = 0;
                if (MCCRead (chID, 0, gStreamWork, 0x20, 0) != 0)
                {
                    dataAddress = data;
                    allBlocks = lastBlocks = *(u32*)&amp;gStreamWork[0];
                    while (lastBlocks)
                    {
                        if (WaitAMinute (5, &amp;gChannelInfo[chID].isStreamDone, 1) == 0)
                        {
                            gLastError = 2;
                            break;
                        }
                        gChannelInfo[chID].isStreamDone = 0;
                        if (MCCRead (chID,
                                     0,
                                     dataAddress,
                                     (lastBlocks &gt; chanInfo.blockLength)
                                         ? chanInfo.blockLength &lt;&lt; 0xD
                                         : lastBlocks &lt;&lt; 0xD,
                                     0) != 0)
                        {
                            dataAddress += chanInfo.blockLength &lt;&lt; 0xD;
                            if (lastBlocks &gt; chanInfo.blockLength)
                            {
                                lastBlocks -= chanInfo.blockLength;
                            }
                            else
                            {
                                lastBlocks = 0;
                                break;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    return allBlocks - lastBlocks;
                }
            }
        }
    }

    return 0;
}

static int
SetUsbAdapterMode (u8 mode)
{
    int result = 0;

    if (HIORead (0x680, m_szAdapterMode, 0x20) != 0)
    {
        DCInvalidateRange (m_szAdapterMode, 0x20);
        m_szAdapterMode[0] = mode;
        DCFlushRange (m_szAdapterMode, 0x20);
        if (HIOWrite (0x680, m_szAdapterMode, 0x20) != 0)
        {
            result = 1;
        }
    }
    return result;
}

static u8
GetUsbAdapterMode (void)
{
    if (HIORead (0x680, m_szAdapterMode, 0x20) != 0)
    {
        DCInvalidateRange (m_szAdapterMode, 0x20);
        return m_szAdapterMode[0];
    }
    return 0;
}

static int
InitializeCodeClear (void)
{
    memset (m_szInitCode, 0, 0x20);
    DCFlushRange (m_szInitCode, 0x20);
    HIOWrite (0x600, m_szInitCode, 0x20);
}

static int
InitializeCodeSet (void)
{
    strcpy (m_szInitCode, &quot;HUDSON/USB2EXI/INITCODE/TARGET&quot;);
    DCFlushRange (m_szInitCode, 0x20);
    HIOWrite (0x600, m_szInitCode, 0x20);
}

static int
InitializeCodeCheck (void)
{
    int result;

    if ((result = HIORead (0x600, m_szInitCode, 0x20)) != 0)
    {
        DCInvalidateRange (m_szInitCode, 0x20);
        result = strcmp (m_szInitCode, &quot;HUDSON/USB2EXI/INITCODE/HOST&quot;);
        return result == 0;
    }
    return result;
}

static void
AsyncResourceClearState (void)
{
    gAsyncResourceStatus = 0;
}

static void
AsyncResourceSetState (u16 state)
{
    gAsyncResourceStatus &amp;= 0xFFFF0FFF;
    gAsyncResourceStatus |= state;
}

static void
AsyncResourceStateBusy (u8 channel, u16 mode)
{
    AsyncResourceClearState();
    AsyncResourceSetState (0x1000);
    gAsyncResourceStatus |= channel;
    gAsyncResourceStatus |= mode;
}

static void
AsyncResourceStateDone (void)
{
    AsyncResourceSetState (0x2000);
}

static u16
AsyncResourceGetStat (void)
{
    return gAsyncResourceStatus &amp; 0xF000;
}

static u16
AsyncResourceGetMode (void)
{
    return gAsyncResourceStatus &amp; 0xF00;
}

static u8
AsyncResourceGetChannel (void)
{
    return gAsyncResourceStatus;
}

static int
AsyncResourceIsBusy (void)
{
    return AsyncResourceGetStat() &amp; 0x1000;
}

static int
LoadChannelInfo (MCC_ChannelInfo* info)
{
    volatile int result = 0;
    u8           count;
#ifndef DEBUG
    int unused; // this is fake, but i cant seem to find whats messing with the
                // stack.
#endif

    if (gIsChannelinfoDirty == 0)
    {
        result = 1;
    }
    else
    {
        count = 0;
        mccDebugPrint (&quot;+++ Load channel info.&quot;);
        while ((result = HIORead (0x700, channelInfo, 0x40)) != 1)
        {
            count -= 1;
            if (count == 0)
            {
                break;
            }
        }
        if (result)
        {
            DCInvalidateRange (channelInfo, 0x40);
            for (count = 0; count &lt; 16; count++)
            {
                info[count].info = channelInfo[count];
            }
            SetChannelInfoDirty (0);
        }
    }
    return result;
}

static int
FlushChannelInfo (MCC_ChannelInfo* info)
{
    volatile int result;
    u8           count;

    result = 0;
    for (count = 0; count &lt; 16; count++)
    {
        channelInfo[count] = info[count].info;
    }
    DCFlushRange (channelInfo, 0x40);
    while ((result = HIOWrite (0x700, channelInfo, 0x40)) != 1)
    {
        count -= 1;
        if (count == 0)
        {
            break;
        }
    }
    if (result != 0)
    {
        SetChannelInfoDirty (1);
        result = NotifyCompulsorily (0, 5, 0xAU);
    }
    return result;
}

static void
SetChannelInfoDirty (int dirty)
{
    gIsChannelinfoDirty = dirty;
}

static void
ClearChannelInfo (int i)
{
    gChannelInfo[i].info.firstBlock = 0;
    gChannelInfo[i].info.blockLength = 0;
    gChannelInfo[i].info.connect = 0;
    gChannelInfo[i].info.isLocked = 0;
    gChannelInfo[i].eventMask = 0;
    gChannelInfo[i].callbackEvent = NULL;
    gChannelInfo[i].isStreamDone = 0;
}

static void
MakeMemoryMap (u8* map)
{
    u8 iMap;
    u8 jMap;

    memset (map, 0, 0x10);
    for (iMap = 0; iMap &lt; 16; iMap++)
    {
        if (gChannelInfo[iMap].info.connect)
        {
            for (jMap = 0; jMap &lt; gChannelInfo[iMap].info.blockLength; jMap++)
            {
                if (jMap + gChannelInfo[iMap].info.firstBlock &lt; 0x10)
                {
                    map[gChannelInfo[iMap].info.firstBlock + jMap] = iMap + 1;
                }
                else
                {
                    gLastError = 0xD;
                }
            }
        }
    }
    *map = 0xFF;
}

static int
IsChannelOpened (enum MCC_CHANNEL chID)
{
    u8 connectSide;

    if ((chID &lt;= 0) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        goto exit;
    }
    connectSide = 2;

    return (connectSide &amp; gChannelInfo[chID].info.connect) ? 1 : 0;

exit:;
    return 0;
}

static u8
SearchFreeBlocks (enum MCC_MODE mode, u8* index)
{
    u8 map[16];
    u8 iMap;
    u8 fIndex;
    u8 fSize;
    u8 fCount;

    MakeMemoryMap (map);
    fCount = 0;
    fIndex = 0;
    fSize = (mode == 0) ? 0x10 : 0;

    for (iMap = 0; iMap &lt;= 16; iMap++)
    {
        if (map[iMap] || iMap == 16)
        {
            if (fCount != 0)
            {
                if (mode == 0)
                {
                    if (fSize &gt; fCount)
                    {
                        fSize = fCount;
                        fIndex = iMap - fCount;
                    }
                }
                else if (mode == 1)
                {
                    if (fSize &lt; fCount)
                    {
                        fSize = fCount;
                        fIndex = iMap - fCount;
                    }
                }
                else if (mode == 2)
                {
                    fSize += fCount;
                }
                fCount = 0;
            }
        }
        else
        {
            fCount += 1;
        }
    }
    if (index)
    {
        *index = fIndex;
    }
    return fSize;
}

static int
NotifyCompulsorily (enum MCC_CHANNEL chID, u32 notify, u32 timeout)
{
    u32          status;
    u32          notifyData;
    volatile u32 tickStart;
    volatile u32 tickCur;
    volatile u32 tickSec;
#ifndef DEBUG
    int unused;                           // fake but blah
#endif

    status = 0;
    tickStart = OSGetTick();

    notifyData = (chID &lt;&lt; 0x18);
    notifyData |= (notify &amp; 0x10000000);
    notifyData |= (notify &amp; 0xFFFFFF);

    while (1)
    {
        if (!HIOReadStatus (&amp;status))
        {
            mccDebugPrint (&quot;ERROR:HIOReadStatus\n&quot;);
        }
        if ((status &amp; 2) == 0)
        {
            break;
        }
        tickCur = OSGetTick();
        tickSec = (tickStart &lt; tickCur) ? tickCur - tickStart : (-1 - tickStart) + tickCur;
        tickSec = OSTicksToSeconds (tickSec);
        if (timeout == 0 || tickSec &gt; timeout)
        {
            break;
        }
    }
    if (!HIOWriteMailbox (notifyData))
    {
        gLastError = 6;
        goto exit;
    }
    return 1;
exit:;
    return 0;
}

static int
NotifyInit (void)
{
    return NotifyCompulsorily (0, 1, 0U);
}

static int
NotifyInitDone (void)
{
    return NotifyCompulsorily (0, 2, 0U);
}

static int
NotifyChannelEvent (enum MCC_CHANNEL chID, u32 notify)
{
#ifndef DEBUG
    int unused[2];                        // fake but blah
#endif

    if (LoadChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
        gLastError = 0xB;
    }
    else if (IsChannelOpened (chID) == 0)
    {
        mccDebugPrint (&quot;Error:Channel is not opened.\n&quot;);
        gLastError = 0x12;
    }
    else if (NotifyCompulsorily (chID, notify, 0xAU) != 0)
    {
        return 1;
    }
    return 0;
}

static int
WaitAMinute (int timeout, volatile int* flag, int value)
{
    u32 tickStart;
    u32 tickDist;

    tickStart = OSGetTick();
    while (*flag != value)
    {
        tickDist = OSGetTick() - tickStart;
        tickDist = (tickDist &amp; 0x80000000) ? (0x80000000 - tickStart) + OSGetTick() : tickDist;
        if (OSTicksToSeconds (tickDist) &gt;= timeout)
        {
            mccDebugPrint (&quot;Error:Time is over.\n&quot;);
            return 0;
        }
    }
    return 1;
}

static void
MailboxCheck (void)
{
    u32 mailbox;
    int isNotify;
    u8  chID;
    u32 value;
    int bDoCall;
#ifndef DEBUG
    int unused[3];                        // fake but blah
#endif

    mailbox = 0;
    if (HIOReadMailbox (&amp;mailbox) == 0)
    {
        mccDebugPrint (&quot;Error:Could not read mailbox.\n&quot;);
        gLastError = 5;
        return;
    }
    isNotify = (mailbox &amp; 0x10000000) != 0;
    chID = (mailbox &gt;&gt; 0x18U) &amp; 0xF;
    value = (mailbox &amp; 0xFFFFFF);
    if (chID == 0)
    {
        bDoCall = 1;
        switch (value)
        {
            case 2:
                gMccInitialized = 1;
                gMccSession = 1;
                gOtherSideInitDone = 1;
                break;
            case 3:
                NotifyCompulsorily (0, 4, 0xAU);
                break;
            case 1:
                gMccSession = 0;
                break;
            case 4:
                if (gPingFlag == 0)
                {
                    bDoCall = 0;
                }
                gPingFlag = 0;
                break;
            case 5:
                SetChannelInfoDirty (1);
                break;
            default:
                if (value == 8U)
                {
                    bDoCall = 0;
                }
                else
                {
                    value = 0;
                }
                break;
        }
        if ((bDoCall != 0) &amp;&amp; gCallbackSysEvent)
        {
            gCallbackSysEvent (value);
        }
    }
    else
    {
        if (LoadChannelInfo (gChannelInfo) == 0)
        {
            mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
            gLastError = 0xB;
            return;
        }
        if (IsChannelOpened (chID) != 0)
        {
            if (!!isNotify)
            {
                if (gChannelInfo[chID].callbackEvent)
                {
                    gChannelInfo[chID].callbackEvent (chID, 0x100, value);
                }
            }
            else
            {
                switch (value)
                {
                    case 0x40:
                    case 0x80:
                        mccDebugPrint (
                            &quot;ERROR: MCC_EVENT_READ_DONE_INSIDE / &quot;
                            &quot;MCC_EVENT_WRITE_DONE_INSIDE received.&quot;);
                        break;
                    case 0x1:
                    case 0x2:
                    case 0x4:
                    case 0x8:
                    case 0x10:
                    case 0x20:
                        if (gChannelInfo[chID].callbackEvent)
                        {
                            gChannelInfo[chID].callbackEvent (chID, value, 0);
                        }
                        break;
                    default:
                        if (gChannelInfo[chID].callbackEvent)
                        {
                            gChannelInfo[chID].callbackEvent (chID, 0, 0);
                        }
                        break;
                }
            }
        }
    }
}

static void
MCCExiCallback (void)
{
    MailboxCheck();
}

static void
MCCTxCallback (void)
{
    AsyncResourceStateDone();
}

static void
MCCRxCallback (void)
{
    AsyncResourceStateDone();
}

static int
mccInitializeCheck (u8 timeout)
{
    int dmyFlag;
    int i;
#ifndef DEBUG
    int unused[3];                        // fake but blah
#endif

    dmyFlag = 0;
    if (InitializeCodeCheck() == 0)
    {
        if (gMccInitialized != 0)
        {
            if (gMccSession == 0)
            {
                SetChannelInfoDirty (1);
                for (i = 0; i &lt; 16; i++)
                {
                    ClearChannelInfo (i);
                }
                if (FlushChannelInfo (gChannelInfo) == 0)
                {
                    mccDebugPrint (&quot;Error:Could not flush channelInfo.\n&quot;);
                    gLastError = 0xA;
                    return 0;
                }
            }
            return 1;
        }
        InitializeCodeSet();
        if (FlushChannelInfo (gChannelInfo) == 0)
        {
            mccDebugPrint (&quot;Error:Could not flush channelInfo.\n&quot;);
            gLastError = 0xA;
        }
        else if ((timeout != 0) &amp;&amp; (WaitAMinute (timeout, &amp;gOtherSideInitDone, 1) == 0))
        {
            InitializeCodeClear();
            mccDebugPrint (&quot;Error:Time is over.\n&quot;);
            gLastError = 2;
            return 0;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        InitializeCodeClear();
        if (NotifyInitDone() == 0)
        {
            gLastError = 4;
        }
        else
        {
            if (gCallbackSysEvent)
            {
                gCallbackSysEvent (2);
            }
            gMccInitialized = 1;
            gMccSession = 1;
            return 1;
        }
    }
    return 0;
}

int
MCCInit (enum MCC_EXI exiChannel, u8 timeout, MCC_CBSysEvent callbackSysEvent)
{
    int dmyFlag;
    u8  adapterMode;
    u32 mailbox;
    u32 status;
    int i;
#ifndef DEBUG
    int unused[3];                        // fake but blah
#endif

    mccDebugPrint (&quot;MCCInit\n&quot;);
    if (gMccInitialized != 0)
    {
        SetChannelInfoDirty (1);
        return mccInitializeCheck (timeout);
    }
    if (!((exiChannel == 0) || (exiChannel == 1) || (exiChannel == 2)))
    {
        mccDebugPrint (&quot;[MCC] Error: Exi channel is out of range.\n&quot;);
        gLastError = 4;
        return 0;
    }
    if (HIOInit (exiChannel, MCCExiCallback) == 0)
    {
        mccDebugPrint (&quot;Error:Initialized Host I/O\n&quot;);
        gLastError = 4;
    }
    else
    {
        dmyFlag = 0;
        adapterMode = GetUsbAdapterMode();
        adapterMode = SetUsbAdapterMode (1);
        mailbox = 0;
        status = 0;
        if ((HIOReadStatus (&amp;status) != 0) &amp;&amp; (status &amp; 1))
        {
            HIOReadMailbox (&amp;mailbox);
        }
        WaitAMinute (1, &amp;dmyFlag, 1);
        if (NotifyInit() == 0)
        {
            gLastError = 4;
        }
        else
        {
            gCallbackSysEvent = callbackSysEvent;
            gLastError = 0;
            SetChannelInfoDirty (1);
            for (i = 0; i &lt; 16; i++)
            {
                ClearChannelInfo (i);
            }
            AsyncResourceClearState();
            return mccInitializeCheck (timeout);
        }
    }
    return 0;
}

void
MCCExit (void)
{
    u8 chID;

    if (gMccInitialized == 0)
    {
        gLastError = 1;
    }
    else
    {
        mccDebugPrint (&quot;MCCExit\n&quot;);
        for (chID = 1; chID &lt; 16; chID++)
        {
            if (IsChannelOpened (chID) != 0)
            {
                MCCClose (chID);
            }
        }
        gLastError = 0;
    }
    gMccInitialized = 0;
    gMccSession = 0;
}

int
MCCPing (void)
{
    mccDebugPrint (&quot;MCCPing\n&quot;);
    if (gMccInitialized == 0)
    {
        gLastError = 1;
    }
    else
    {
        gPingFlag = 1;
        gLastError = 0;
        return NotifyCompulsorily (0, 3, 0xAU);
    }
    return 0;
}

int
MCCEnumDevices (MCC_CBEnumDevices callbackEnumDevices)
{
    if (callbackEnumDevices == NULL)
    {
        gLastError = 0xD;
    }
    if (HIOEnumDevices (callbackEnumDevices) == 0)
    {
        gLastError = 0xD;
    }
    else
    {
        gLastError = 0;
        return 1;
    }
    return 0;
}

u8
MCCGetFreeBlocks (enum MCC_MODE mode)
{
#ifndef DEBUG
    int unused[3];                        // fake but blah
#endif

    mccDebugPrint (&quot;MCCGetFreeBlocks\n&quot;);
    if (gMccInitialized == 0)
    {
        gLastError = 1;
    }
    else if (!((mode == 0) || (mode == 1) || (mode == 2)))
    {
        gLastError = 0xD;
    }
    else
    {
        if (LoadChannelInfo (gChannelInfo) == 0)
        {
            mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
            gLastError = 0xB;
        }
        else
        {
            gLastError = 0;
            return SearchFreeBlocks (mode, NULL);
        }
    }
    return 0;
}

u8
MCCGetLastError (void)
{
    mccDebugPrint (&quot;MCCGetFreeBlocks\n&quot;); 
    return gLastError;
}

int
MCCGetChannelInfo (enum MCC_CHANNEL chID, MCC_Info* info)
{
#ifndef DEBUG
    int unused[3];                        // fake but blah
#endif

    mccDebugPrint (&quot;MCCGetChannelInfo\n&quot;);
    if (gMccInitialized == 0)
    {
        gLastError = 1;
    }
    else if ((chID &lt;= 0) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
    }
    else if (!info)
    {
        mccDebugPrint (&quot;Error:Bad parameter channelInfo.\n&quot;);
        gLastError = 0xD;
    }
    else
    {
        if (LoadChannelInfo (gChannelInfo) == 0)
        {
            mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
            gLastError = 0xB;
        }
        else
        {
            memcpy (info, &amp;gChannelInfo[chID].info, sizeof (MCC_Info));
            gLastError = 0;
            return 1;
        }
    }
    return 0;
}

int
MCCGetConnectionStatus (enum MCC_CHANNEL chID, enum MCC_CONNECT* connect)
{
    MCC_Info info;
#ifndef DEBUG
    int unused[2];                        // fake but blah
#endif

    mccDebugPrint (&quot;MCCGetConnectionStatus\n&quot;);
    if (gMccInitialized == 0)
    {
        gLastError = 1;
        return 0;
    }
    if ((chID &lt; 1) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        return 0;
    }
    if (AsyncResourceIsBusy() != 0)
    {
        gLastError = 0x15;
        return 0;
    }
    if (!connect)
    {
        mccDebugPrint (&quot;Error:Parameter error.\n&quot;);
        gLastError = 0xD;
    }
    else
    {
        if (MCCGetChannelInfo (chID, &amp;info) != 0)
        {
            *connect = info.connect;
            gLastError = 0;
            return 1;
        }
    }
    return 0;
}

int
MCCNotify (enum MCC_CHANNEL chID, u32 notify)
{
    enum MCC_CONNECT connect;
#ifndef DEBUG
    int unused[3];                        // fake but blah
#endif

    mccDebugPrint (&quot;MCCNotify\n&quot;);
    if (gMccInitialized == 0)
    {
        gLastError = 1;
    }
    else if ((chID &lt;= 0) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        ;
    }
    else if (LoadChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
        gLastError = 0xB;
    }
    else if (MCCGetConnectionStatus (chID, &amp;connect) == 0)
    {
        gLastError = 9;
    }
    else
    {
        if (connect != 3)
        {
            mccDebugPrint (&quot;Error:Channel is not opened.\n&quot;);
            gLastError = 0x12;
        }
        else
        {
            notify |= 0x10000000;
            return NotifyCompulsorily (chID, notify, 0xAU);
        }
    }
    return 0;
}

u32
MCCSetChannelEventMask (enum MCC_CHANNEL chID, u32 event)
{
    u32 oldMask;
#ifndef DEBUG
    int unused[2];                        // fake but blah
#endif

    oldMask = 0xFFFFFFFF;
    if (gMccInitialized == 0)
    {
        gLastError = 1;
    }
    else if ((chID &lt;= 0) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
    }
    else if (LoadChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
        gLastError = 0xB;
    }
    else if (IsChannelOpened (chID) == 0)
    {
        mccDebugPrint (&quot;Error:This channel is closed.&quot;);
        gLastError = 0x12;
    }
    else
    {
        oldMask = gChannelInfo[chID].eventMask;
        gChannelInfo[chID].eventMask = (u16)event;
    }
    return oldMask;
}

int
MCCOpen (enum MCC_CHANNEL chID, u8 blockSize, MCC_CBEvent callbackEvent)
{
    u8 connectSide;
    u8 blockIndex;
#ifndef DEBUG
    int unused2[2];
#endif
    u8 freeBlocks;
#ifndef DEBUG
    int unused[6];                        // fake but blah
#endif

    mccDebugPrint (&quot;MCCOpen\n&quot;);
    if (gMccInitialized == 0)
    {
        gLastError = 1;
        return 0;
    }
    if ((chID &lt; 1) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        return 0;
    }
    if (AsyncResourceIsBusy() != 0)
    {
        gLastError = 0x15;
        return 0;
    }
    if (blockSize == 0)
    {
        gLastError = 0xF;
        return 0;
    }
    if ((chID &lt;= 0) || (chID &gt;= 0x10))
    {
        mccDebugPrint (&quot;Error:Invalid channel.\n&quot;);
        gLastError = 0xE;
        goto exit;
    }
    else
    {
        connectSide = 2;
        if (LoadChannelInfo (gChannelInfo) == 0)
        {
            mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
            gLastError = 0xB;
            goto exit;
        }
        else if (!gChannelInfo[chID].info.connect)
        {
            freeBlocks = SearchFreeBlocks (1, &amp;blockIndex);
            if (blockSize &gt; freeBlocks)
            {
                mccDebugPrint (&quot;Error:Not enough free blocks.\n&quot;);
                gLastError = 0xC;
                goto exit;
            }
            else
            {
                gChannelInfo[chID].info.firstBlock = blockIndex;
                gChannelInfo[chID].info.blockLength = blockSize;
                gChannelInfo[chID].info.connect = connectSide;
                gChannelInfo[chID].info.isLocked = 0;
                gChannelInfo[chID].eventMask = 0;
                gChannelInfo[chID].callbackEvent = callbackEvent;
                gChannelInfo[chID].isStreamDone = 0;
                if (FlushChannelInfo (gChannelInfo) == 0)
                {
                    mccDebugPrint (&quot;Error:Could not flush channelInfo.\n&quot;);
                    gLastError = 0xA;
                    goto exit;
                }
                gLastError = 0;
                return 1;
            }
        }
    }
    if (gChannelInfo[chID].info.connect &amp; connectSide)
    {
        mccDebugPrint (&quot;Error:Already opened.\n&quot;);
        gLastError = 0x11;
        goto exit;
    }
    else if (blockSize != gChannelInfo[chID].info.blockLength)
    {
        mccDebugPrint (&quot;Error:Block size error.\n&quot;);
        gLastError = 0xD;
        goto exit;
    }
    gChannelInfo[chID].info.connect = 3;
    gChannelInfo[chID].callbackEvent = callbackEvent;
    if (FlushChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not flush channelInfo.\n&quot;);
        gLastError = 0xA;
        goto exit;
    }
    if (~(gChannelInfo[chID].eventMask) &amp; 1)
    {
        NotifyCompulsorily (chID, 1, 0xAU);
        if (gChannelInfo[chID].callbackEvent)
        {
            gChannelInfo[chID].callbackEvent (chID, 1, 0);
        }
    }
    gLastError = 0;
    return 1;
exit:;
    return 0;
}

int
MCCClose (enum MCC_CHANNEL chID)
{
    u8 connectSide;
#ifndef DEBUG
    int unused[4];                        // fake but blah
#endif

    connectSide = 2;
    mccDebugPrint (&quot;MCCClose\n&quot;);
    if (gMccInitialized == 0)
    {
        gLastError = 1;
        return 0;
    }
    if ((chID &lt; 1) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        return 0;
    }
    if (AsyncResourceIsBusy() != 0)
    {
        gLastError = 0x15;
        return 0;
    }
    if (LoadChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
        gLastError = 0xB;
        goto exit;
    }
    if (IsChannelOpened (chID) == 0)
    {
        mccDebugPrint (&quot;Error:This channel is closed.&quot;);
        gLastError = 0x12;
        goto exit;
    }
    gChannelInfo[chID].info.connect &amp;= ~connectSide;
    if (gChannelInfo[chID].info.connect == 0)
    {
        ClearChannelInfo (chID);
    }
    if (FlushChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not flush channelInfo.\n&quot;);
        gLastError = 0xA;
        goto exit;
    }
    if (gChannelInfo[chID].info.connect != 0)
    {
        if (~(gChannelInfo[chID].eventMask) &amp; 2)
        {
            NotifyCompulsorily (chID, 2, 0xAU);
            if (gChannelInfo[chID].callbackEvent)
            {
                gChannelInfo[chID].callbackEvent (chID, 2, 0);
            }
        }
    }
    gLastError = 0;
    return 1;
exit:;
    return 0;
}

int
MCCLock (enum MCC_CHANNEL chID)
{
#ifndef DEBUG
    int unused[7];                        // fake but blah
#endif

    mccDebugPrint (&quot;MCCLock\n&quot;);

    if (gMccInitialized == 0)
    {
        gLastError = 1;
        return 0;
    }
    if ((chID &lt; 1) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        return 0;
    }
    if (AsyncResourceIsBusy() != 0)
    {
        gLastError = 0x15;
        return 0;
    }
    if (LoadChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
        gLastError = 0xB;
        goto exit;
    }
    if (IsChannelOpened (chID) == 0)
    {
        mccDebugPrint (&quot;Error:This channel is closed.&quot;);
        gLastError = 0x12;
        goto exit;
    }
    if (gChannelInfo[chID].info.isLocked == 1)
    {
        mccDebugPrint (&quot;Error:This channel is already locked.&quot;);
        gLastError = 0x13;
        goto exit;
    }
    gChannelInfo[chID].info.isLocked = 1;
    if (FlushChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not flush channelInfo.\n&quot;);
        gLastError = 0xA;
        goto exit;
    }
    if (~(gChannelInfo[chID].eventMask) &amp; 4)
    {
        NotifyChannelEvent (chID, 4);
    }
    gLastError = 0;
    return 1;
exit:;
    return 0;
}

int
MCCUnlock (enum MCC_CHANNEL chID)
{
#ifndef DEBUG
    int unused[7];                        // fake but blah
#endif

    mccDebugPrint (&quot;MCCUnlock\n&quot;);

    if (gMccInitialized == 0)
    {
        gLastError = 1;
        return 0;
    }
    if ((chID &lt; 1) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        return 0;
    }
    if (AsyncResourceIsBusy() != 0)
    {
        gLastError = 0x15;
        return 0;
    }
    if (LoadChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
        gLastError = 0xB;
        goto exit;
    }
    if (IsChannelOpened (chID) == 0)
    {
        mccDebugPrint (&quot;Error:This channel is closed.&quot;);
        gLastError = 0x12;
        goto exit;
    }
    if (gChannelInfo[chID].info.isLocked == 0)
    {
        mccDebugPrint (&quot;Error:This channel is already unlocked.&quot;);
        gLastError = 0x14;
        goto exit;
    }
    gChannelInfo[chID].info.isLocked = 0;
    if (FlushChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not flush channelInfo.\n&quot;);
        gLastError = 0xA;
        goto exit;
    }
    if (~(gChannelInfo[chID].eventMask) &amp; 8)
    {
        NotifyChannelEvent (chID, 8);
    }
    gLastError = 0;
    return 1;
exit:
    return 0;
}

int
MCCRead (enum MCC_CHANNEL chID, u32 offset, void* data, s32 size, enum MCC_SYNC_STATE async)
{
#ifndef DEBUG
    int unused[11];                       // fake but blah
#endif

    mccDebugPrint (&quot;MCCRead\n&quot;);
    if (gMccInitialized == 0)
    {
        gLastError = 1;
        return 0;
    }
    if ((chID &lt; 1) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        return 0;
    }
    if (!((async == 1) || (async == 0)))
    {
        gLastError = 0xD;
        return 0;
    }
    if ((offset &amp; 3) || ((u32)data &amp; 0x1F) || (size % 32) != 0)
    {
        gLastError = 0xD;
        return 0;
    }
    if (AsyncResourceIsBusy() != 0)
    {
        gLastError = 0x15;
        return 0;
    }
    if (LoadChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
        gLastError = 0xB;
        goto exit;
    }
    if (IsChannelOpened (chID) == 0)
    {
        mccDebugPrint (&quot;Error:This channel is closed.&quot;);
        gLastError = 0x12;
        goto exit;
    }
    if (offset &gt; gChannelInfo[chID].info.blockLength &lt;&lt; 0xD)
    {
        mccDebugPrint (&quot;Error:Invarid offset&quot;);
        gLastError = 0x10;
        goto exit;
    }
    if ((offset + size) &gt; gChannelInfo[chID].info.blockLength &lt;&lt; 0xD)
    {
        mccDebugPrint (&quot;Error:Invarid data size.&quot;);
        gLastError = 0xF;
        goto exit;
    }
    if (async == 1)
    {
        if (MCCCheckAsyncDone() == 0)
        {
            mccDebugPrint (&quot;Error:Channel busy.&quot;);
            gLastError = 0x15;
            goto exit;
        }
        AsyncResourceStateBusy (chID, 0U);
        if (HIOReadAsync (offset + (gChannelInfo[chID].info.firstBlock &lt;&lt; 0xD),
                          data,
                          size,
                          MCCRxCallback) == 0)
        {
            mccDebugPrint (&quot;Error:Read data error.&quot;);
            gLastError = 7;
            goto exit;
        }
        DCInvalidateRange (data, size);
        gLastError = 0;
        return 1;
    }
    if (HIORead (offset + (gChannelInfo[chID].info.firstBlock &lt;&lt; 0xD), data, size) == 0)
    {
        mccDebugPrint (&quot;Error:Read data error.&quot;);
        gLastError = 7;
        goto exit;
    }
    DCInvalidateRange (data, size);
    if (~(gChannelInfo[chID].eventMask) &amp; 0x10)
    {
        NotifyChannelEvent (chID, 0x10);
    }
    if (~(gChannelInfo[chID].eventMask) &amp; 0x40 &amp;&amp; gChannelInfo[chID].callbackEvent)
    {
        gChannelInfo[chID].callbackEvent (chID, 0x40, 0);
    }
    gLastError = 0;
    return 1;
exit:;
    return 0;
}

int
MCCWrite (enum MCC_CHANNEL chID, u32 offset, void* data, s32 size, enum MCC_SYNC_STATE async)
{
#ifndef DEBUG
    int unused[11];                       // fake but blah
#endif
    mccDebugPrint (&quot;MCCWrite\n&quot;);

    if (gMccInitialized == 0)
    {
        gLastError = 1;
        return 0;
    }
    if ((chID &lt; 1) || (chID &gt;= 0x10))
    {
        gLastError = 0xE;
        return 0;
    }
    if (!((async == 1) || (async == 0)))
    {
        gLastError = 0xD;
        return 0;
    }
    if ((offset &amp; 3) || ((u32)data &amp; 0x1F) || (size % 32) != 0)
    {
        gLastError = 0xD;
        return 0;
    }
    if (AsyncResourceIsBusy() != 0)
    {
        gLastError = 0x15;
        return 0;
    }
    if (LoadChannelInfo (gChannelInfo) == 0)
    {
        mccDebugPrint (&quot;Error:Could not update channelInfo.\n&quot;);
        gLastError = 0xB;
        goto exit;
    }
    if (IsChannelOpened (chID) == 0)
    {
        mccDebugPrint (&quot;Error:This channel is closed.&quot;);
        gLastError = 0x12;
        goto exit;
    }
    if (gChannelInfo[chID].info.isLocked == 1)
    {
        mccDebugPrint (&quot;Error:This channel was locked.&quot;);
        gLastError = 0x13;
        goto exit;
    }
    if (offset &gt; (gChannelInfo[chID].info.blockLength &lt;&lt; 0xD))
    {
        mccDebugPrint (&quot;Error:Invarid offset&quot;);
        gLastError = 0x10;
        goto exit;
    }
    if (offset + size &gt; (gChannelInfo[chID].info.blockLength &lt;&lt; 0xD))
    {
        mccDebugPrint (&quot;Error:Invarid data size.&quot;);
        gLastError = 0xF;
        goto exit;
    }
    if (async == 1)
    {
        if (MCCCheckAsyncDone() == 0)
        {
            mccDebugPrint (&quot;Error:Channel busy.&quot;);
            gLastError = 0x15;
            goto exit;
        }
        AsyncResourceStateBusy (chID, 0x100U);
        DCFlushRange (data, size);
        if (HIOWriteAsync (offset + (gChannelInfo[chID].info.firstBlock &lt;&lt; 0xD),
                           data,
                           size,
                           MCCTxCallback) == 0)
        {
            mccDebugPrint (&quot;Error:Write data error.&quot;);
            gLastError = 8;
            goto exit;
        }
        gLastError = 0;
        return 1;
    }
    DCFlushRange (data, size);
    if (HIOWrite (offset + (gChannelInfo[chID].info.firstBlock &lt;&lt; 0xD), data, size) == 0)
    {
        mccDebugPrint (&quot;Error:Write data error.&quot;);
        gLastError = 8;
        goto exit;
    }
    if (~(gChannelInfo[chID].eventMask) &amp; 0x20)
    {
        NotifyChannelEvent (chID, 0x20);
    }
    if (~(gChannelInfo[chID].eventMask) &amp; 0x80 &amp;&amp; gChannelInfo[chID].callbackEvent)
    {
        gChannelInfo[chID].callbackEvent (chID, 0x80, 0);
    }
    gLastError = 0;
    return 1;
exit:
    return 0;
}

int
MCCCheckAsyncDone ()
{
    u16 stat;
    u16 mode;
    u8  chID;
#ifndef DEBUG
    int unused[5];                        // fake but blah
#endif

    if (gMccInitialized == 0)
    {
        gLastError = 1;
        return 0;
    }
    stat = AsyncResourceGetStat();
    if (stat == 0x1000)
    {
        return 0;
    }
    else if (stat &amp;&amp; stat == 0x2000)
    {
        mode = AsyncResourceGetMode();
        chID = AsyncResourceGetChannel();
        AsyncResourceClearState();
        if (mode == 0)
        {
            if (~(gChannelInfo[chID].eventMask) &amp; 0x10)
            {
                NotifyChannelEvent (chID, 0x10);
            }
            if (~(gChannelInfo[chID].eventMask) &amp; 0x40 &amp;&amp; gChannelInfo[chID].callbackEvent)
            {
                gChannelInfo[chID].callbackEvent (chID, 0x40, 0);
            }
        }
        else
        {
            if (~(gChannelInfo[chID].eventMask) &amp; 0x20)
            {
                NotifyChannelEvent (chID, 0x20);
            }
            if (~(gChannelInfo[chID].eventMask) &amp; 0x80 &amp;&amp; gChannelInfo[chID].callbackEvent)
            {
                gChannelInfo[chID].callbackEvent (chID, 0x80, 0);
            }
        }
    }
    return 1;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>