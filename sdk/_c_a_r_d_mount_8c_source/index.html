<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File CARDMount.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-cardmountc">File CARDMount.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_2dfa3b55db09c289c0394a464581d568/"><strong>card</strong></a> <strong>&gt;</strong> <a href="../_c_a_r_d_mount_8c/"><strong>CARDMount.c</strong></a></p>
<p><a href="../_c_a_r_d_mount_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin.h&gt;
#include &lt;dolphin/card.h&gt;
#include &lt;dolphin/exi.h&gt;

#include &quot;../os/OSPrivate.h&quot;
#include &quot;CARDPrivate.h&quot;
#include &quot;dolphin/os/OSAlarm.h&quot;

static u32 SectorSizeTable[8] = {
    8 * 1024, 16 * 1024, 32 * 1024, 64 * 1024, 128 * 1024, 256 * 1024, 0, 0,
};

static u32 LatencyTable[8] = {
    4, 8, 16, 32, 64, 128, 256, 512,
};

// functions
static s32  DoMount (s32 chan);
static void DoUnmount (s32 chan, s32 v);

BOOL
CARDProbe (s32 chan)
{
    return EXIProbe (chan);
}

s32
CARDProbeEx (s32 chan, s32* memSize, s32* sectorSize)
{
    u32          id;
    CARDControl* card;
    BOOL         enabled;
    s32          result;
    s32          probe;

    if (chan &lt; 0 || 2 &lt;= chan)
    {
        return CARD_RESULT_FATAL_ERROR;
    }

    card    = &amp;__CARDBlock[chan];
    enabled = OSDisableInterrupts();
    probe   = EXIProbeEx (chan);
    if (probe == -1)
    {
        result = CARD_RESULT_NOCARD;
    }
    else if (probe == 0)
    {
        result = CARD_RESULT_BUSY;
    }
    else if (card-&gt;attached)
    {
        if (card-&gt;mountStep &lt; 1)
        {
            result = CARD_RESULT_BUSY;
        }
        else
        {
            if (memSize != 0)
            {
                *memSize = card-&gt;size;
            }
            if (sectorSize != 0)
            {
                *sectorSize = card-&gt;sectorSize;
            }
            result = CARD_RESULT_READY;
        }
    }

    else if ((EXIGetState (chan) &amp; 8))
    {
        result = CARD_RESULT_WRONGDEVICE;
    }
    else if (!EXIGetID (chan, 0, &amp;id))
    {
        result = CARD_RESULT_BUSY;
    }
    else if ((id &amp; 0xFFFF0000) || (id &amp; 3))
    {
        result = CARD_RESULT_WRONGDEVICE;
    }
    else
    {
        if (memSize != 0)
        {
            *memSize = (s32)(id &amp; 0xfc);
        }
        if (sectorSize != 0)
        {
            *sectorSize = (s32)SectorSizeTable[(id &amp; 0x00003800) &gt;&gt; 11];
        }
        result = CARD_RESULT_READY;
    }

    OSRestoreInterrupts (enabled);

    return result;
}

static s32
DoMount (s32 chan)
{
    CARDControl* card;
    u32          id;
    u8           status;
    s32          result;
    OSSramEx*    sram;
    int          i;
    u8           checkSum;
    int          step;

    ASSERTLINE (0xFE, 0 &lt;= chan &amp;&amp; chan &lt; 2);

    card = &amp;__CARDBlock[chan];
    if (card-&gt;mountStep == 0)
    {
        result = __CARDReadNintendoID (chan, &amp;id);
        if (result &lt; 0)
        {
            goto error;
        }

        card-&gt;size       = (u16)(id &amp; 0xFC);
        card-&gt;sectorSize = (s32)SectorSizeTable[(id &amp; 0x00003800) &gt;&gt; 11];
        card-&gt;cBlock     = (u16)((card-&gt;size * 1024 * 1024 / 8) / card-&gt;sectorSize);
        card-&gt;latency    = (s32)LatencyTable[(id &amp; 0x00000700) &gt;&gt; 8];

        if (card-&gt;sectorSize == 0 || card-&gt;cBlock &lt; 8)
        {
            result = -2;
            goto error;
        }
        result = __CARDClearStatus (chan);
        if (result &lt; 0)
        {
            goto error;
        }
        result = __CARDReadStatus (chan, &amp;status);
        if (result &lt; 0)
        {
            goto error;
        }
        if (!EXIProbe (chan))
        {
            result = CARD_RESULT_NOCARD;
            goto error;
        }

        if (!(status &amp; 0x40))
        {
            result = __CARDUnlock (chan, card-&gt;id);
            if (result &lt; 0)
            {
                goto error;
            }

            checkSum = 0;
            sram     = __OSLockSramEx();
            for (i = 0; i &lt; 12; i++)
            {
                sram-&gt;flashID[chan][i]  = card-&gt;id[i];
                checkSum               += card-&gt;id[i];
            }
            sram-&gt;flashIDCheckSum[chan] = (u8)~checkSum;
            __OSUnlockSramEx (TRUE);

            return result;
        }
        else
        {
            card-&gt;mountStep = 1;

            checkSum        = 0;
            sram            = __OSLockSramEx();
            for (i = 0; i &lt; 12; i++) { checkSum += sram-&gt;flashID[chan][i]; }

            __OSUnlockSramEx (FALSE);
            if (sram-&gt;flashIDCheckSum[chan] != (u8)~checkSum)
            {
                result = CARD_RESULT_IOERROR;
                goto error;
            }
        }
    }

    if (card-&gt;mountStep == 1)
    {
        card-&gt;mountStep = 2;

        result          = __CARDEnableInterrupt (chan, TRUE);
        if (result &lt; 0)
        {
            goto error;
        }

        EXISetExiCallback (chan, __CARDExiHandler);
        EXIUnlock (chan);
        DCInvalidateRange (card-&gt;workArea, CARD_WORKAREA_SIZE);
    }

    step   = card-&gt;mountStep - 2;
    result = __CARDRead (chan,
                         (u32)card-&gt;sectorSize * step,
                         CARD_SYSTEM_BLOCK_SIZE,
                         (u8*)card-&gt;workArea + (CARD_SYSTEM_BLOCK_SIZE * step),
                         __CARDMountCallback);
    if (result &lt; 0)
    {
        __CARDPutControlBlock (card, result);
    }

    return result;

error:
    EXIUnlock (chan);
    DoUnmount (chan, result);

    return result;
}

void
__CARDMountCallback (s32 chan, s32 result)
{
    CARDControl* card;
    CARDCallback callback;

    ASSERTLINE (0x181, 0 &lt;= chan &amp;&amp; chan &lt; 2);

    card = &amp;__CARDBlock[chan];
    switch (result)
    {
        case CARD_RESULT_READY:
            if (++card-&gt;mountStep &lt; CARD_MAX_MOUNT_STEP)
            {
                result = DoMount (chan);
                if (0 &lt;= result)
                {
                    return;
                }
            }
            else
            {
                result = __CARDVerify (card);
            }
            break;
        case CARD_RESULT_UNLOCKED:
            result = DoMount (chan);
            if (result &gt;= 0)
            {
                return;
            }
            break;
        case CARD_RESULT_IOERROR:
        case CARD_RESULT_NOCARD:
            DoUnmount (chan, result);
            break;
    }

    callback          = card-&gt;apiCallback;
    card-&gt;apiCallback = NULL;
    __CARDPutControlBlock (card, result);
    ASSERTLINE (0x1AB, callback);
    callback (chan, result);
}

s32
CARDMountAsync (s32          chan,
                void*        workArea,
                CARDCallback detachCallback,
                CARDCallback attachCallback)
{
    CARDControl* card;
    BOOL         enabled;

    ASSERTLINE (0x1CB, workArea &amp;&amp; ((u32)workArea % 32 == 0));
    ASSERTLINE (0x1CC, 0 &lt;= chan &amp;&amp; chan &lt; 2);

    if (chan &lt; 0 || 2 &lt;= chan)
    {
        return CARD_RESULT_FATAL_ERROR;
    }

    card    = &amp;__CARDBlock[chan];

    enabled = OSDisableInterrupts();
    if (card-&gt;result == CARD_RESULT_BUSY)
    {
        OSRestoreInterrupts (enabled);
        return CARD_RESULT_BUSY;
    }

    if (!card-&gt;attached &amp;&amp; (EXIGetState (chan) &amp; 0x08))
    {
        OSRestoreInterrupts (enabled);
        return CARD_RESULT_WRONGDEVICE;
    }

    card-&gt;result      = CARD_RESULT_BUSY;
    card-&gt;workArea    = workArea;
    card-&gt;extCallback = detachCallback;
    card-&gt;apiCallback = attachCallback ? attachCallback : __CARDDefaultApiCallback;
    card-&gt;exiCallback = 0;

    if (!card-&gt;attached &amp;&amp; !EXIAttach (chan, __CARDExtHandler))
    {
        card-&gt;result = CARD_RESULT_NOCARD;
        OSRestoreInterrupts (enabled);
        return CARD_RESULT_NOCARD;
    }

    card-&gt;mountStep = 0;
    card-&gt;attached  = TRUE;
    EXISetExiCallback (chan, 0);
    OSCancelAlarm (&amp;card-&gt;alarm);

    card-&gt;currentDir = 0;
    card-&gt;currentFat = 0;

    OSRestoreInterrupts (enabled);

    card-&gt;unlockCallback = __CARDMountCallback;
    if (!EXILock (chan, 0, __CARDUnlockedHandler))
    {
        return CARD_RESULT_READY;
    }

    card-&gt;unlockCallback = 0;

    return DoMount (chan);
}

s32
CARDMount (s32 chan, void* workArea, CARDCallback detachCallback)
{
    s32 result = CARDMountAsync (chan, workArea, detachCallback, __CARDSyncCallback);

    if (result &lt; 0)
    {
        return result;
    }
    return __CARDSync (chan);
}

static void
DoUnmount (s32 chan, s32 result)
{
    CARDControl* card;
    BOOL         enabled;

    ASSERTLINE (0x22F, 0 &lt;= chan &amp;&amp; chan &lt; 2);

    card    = &amp;__CARDBlock[chan];
    enabled = OSDisableInterrupts();
    if (card-&gt;attached)
    {
        EXISetExiCallback (chan, 0);
        EXIDetach (chan);
        OSCancelAlarm (&amp;card-&gt;alarm);
        card-&gt;attached  = FALSE;
        card-&gt;result    = result;
        card-&gt;mountStep = 0;
    }

    OSRestoreInterrupts (enabled);
}

s32
CARDUnmount (s32 chan)
{
    CARDControl* card;
    s32          result;

    ASSERTLINE (0x252, 0 &lt;= chan &amp;&amp; chan &lt; 2);

    result = __CARDGetControlBlock (chan, &amp;card);
    if (result &lt; 0)
    {
        return result;
    }
    DoUnmount (chan, CARD_RESULT_NOCARD);

    return CARD_RESULT_READY;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>