<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File DEMOPuts.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-demoputsc">File DEMOPuts.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_12b9b9f3614a19f67fa121459aa56b48/"><strong>demo</strong></a> <strong>&gt;</strong> <a href="../_d_e_m_o_puts_8c/"><strong>DEMOPuts.c</strong></a></p>
<p><a href="../_d_e_m_o_puts_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/demo.h&gt;
#include &lt;dolphin/gx.h&gt;
#include &lt;dolphin/mtx.h&gt;

#include &lt;dolphin.h&gt;

#include &quot;DEMOPrivate.h&quot;

extern u32 DEMOFontBitmap[]; // size: 0x0, address: 0x0

// .bss
static struct _GXTexObj fontTexObj; // size: 0x20, address: 0x0

// .sbss
static s32                  fontShift; // size: 0x4, address: 0x0
static struct OSFontHeader* FontData;  // size: 0x4, address: 0x4
static void*                LastSheet; // size: 0x4, address: 0x8
static s16                  FontSize;  // size: 0x2, address: 0xC
static s16                  FontSpace; // size: 0x2, address: 0xE

// functions
static void DrawFontChar (int x, int y, int z, int xChar, int yChar);
static void LoadSheet (void* image, enum _GXTexMapID texMapID);

void
DEMOSetFontType (DMFontType attr)
{
    switch (attr)
    {
        case DM_FT_RVS:
            GXSetBlendMode (2, 0, 0, 0xC);
            break;
        case DM_FT_XLU:
            GXSetBlendMode (1, 1, 1, 0);
            break;
        case DM_FT_OPQ:
        default:
            GXSetBlendMode (1, 1, 0, 0);
            break;
    }
}

void
DEMOLoadFont (enum _GXTexMapID texMap, enum _GXTexMtx texMtx, DMTexFlt texFlt)
{
    float fontTMtx[3][4];
    u16   width;
    u16   height;

    width = 64;
    height = 0x1800 / width;
    GXInitTexObj (&amp;fontTexObj, (void*)DEMOFontBitmap, width, (u16)height, 0, 0, 0, 0);
    fontShift = 1;
    if (texFlt == 0)
    {
        GXInitTexObjLOD (&amp;fontTexObj, 0, 0, 0, 0, 0, 0.0f, 0.0f, 0.0f);
        fontShift = 0;
    }
    GXLoadTexObj (&amp;fontTexObj, texMap);
    MTXScale (fontTMtx, 1.0f / (width - !fontShift), 1.0f / ((u16)height - !fontShift), 1.0f);
    GXLoadTexMtxImm (fontTMtx, texMtx, 1);
    GXSetNumTexGens (1);
    GXSetTexCoordGen (0, 1, 4, texMtx);
}

void
DEMOSetupScrnSpc (s32 width, long height, float depth)
{
    float pMtx[4][4];
    float mMtx[3][4];

    MTXOrtho (pMtx, 0.0f, height, 0.0f, width, 0.0f, -depth);
    GXSetProjection (pMtx, 1);
    MTXIdentity (mMtx);
    GXLoadPosMtxImm (mMtx, 0);
    GXSetCurrentMtx (0);
}

void
DEMOInitCaption (s32 font_type, long width, long height)
{
    DEMOSetupScrnSpc (width, height, 100.0f);
    GXSetZMode (1, 7, 1);
    GXSetNumChans (0);
    GXSetNumTevStages (1);
    GXSetTevOp (0, 3);
    GXSetTevOrder (0, 0, 0, 0xFF);
    DEMOLoadFont (0, 0x1E, 0);
    DEMOSetFontType (font_type);
}

void
DEMOPuts (s16 x, s16 y, s16 z, char* string)
{
    char* str;
    s32   s;
    s32   t;
    s32   c;
    s32   w;
    s32   len;
    s32   i;

    str = string;
    GXClearVtxDesc();
    GXSetVtxDesc (9, 1);
    GXSetVtxDesc (0xD, 1);
    GXSetVtxAttrFmt (0, 9, 1, 3, 0);
    GXSetVtxAttrFmt (0, 0xD, 1, 3, 1);

    // calc len
    len = 0;
    while (1)
    {
        c = *(str++);
        if ((c &gt;= 0x20) &amp;&amp; (c &lt;= 0x7F))
        {
            len++;
            continue;
        }

        if (len &gt; 0)
        {
            GXBegin (0x80, 0, len * 4);
            for (i = 0; i &lt; len; i++)
            {
                w = string[i] - 0x20;
                s = fontShift + ((w % 8) * 0x10);
                t = fontShift + ((w / 8) * 0x10);
                GXPosition3s16 (x + (i * 8), y, z);
                GXTexCoord2s16 (s, t);
                GXPosition3s16 (x + (i * 8) + 8, y, z);
                GXTexCoord2s16 (s + 0x10, t);
                GXPosition3s16 (x + (i * 8) + 8, y + 8, z);
                GXTexCoord2s16 (s + 0x10, t + 0x10);
                GXPosition3s16 (x + (i * 8), y + 8, z);
                GXTexCoord2s16 (s, t + 0x10);
            }
            GXEnd();
            len = 0;
        }

        string = str;
        if (c == 0xA)
        {
            y += 0x8;
        }
        else
        {
            break;
        }
    }
}

void
DEMOPrintf (s16 x, s16 y, s16 z, char* fmt, ...)
{
    va_list vlist;
    s8      buf[256];

    va_start (vlist, fmt);
    vsprintf (buf, fmt, vlist);
    DEMOPuts (x, y, z, buf);
    va_end (vlist);
}

struct OSFontHeader*
DEMOInitROMFont ()
{
    if (OSGetFontEncode() == 1)
    {
        FontData = OSAllocFromHeap (__OSCurrHeap, 0x120F00);
    }
    else
    {
        FontData = OSAllocFromHeap (__OSCurrHeap, 0x20120);
    }
    if (!FontData)
    {
        OSPanic (__FILE__, 0x19D, &quot;Ins. memory to load ROM font.&quot;);
    }
    if (OSInitFont (FontData) == 0)
    {
        OSPanic (__FILE__, 0x1A1, &quot;ROM font is available in boot ROM ver 0.8 or later.&quot;);
    }
    FontSize = FontData-&gt;cellWidth * 0x10;
    FontSpace = -0x10;
    return FontData;
}

void
DEMOSetROMFontSize (s16 size, s16 space)
{
    FontSize = size * 0x10;
    FontSpace = space * 0x10;
}

static void
DrawFontChar (int x, int y, int z, int xChar, int yChar)
{
    s16 posLeft = x;
    s16 posRight = posLeft + ((FontSize * FontData-&gt;cellWidth) / FontData-&gt;cellWidth);
    s16 posBottom = y;
    s16 posTop =
        y - ((FontData-&gt;cellHeight * ((FontData-&gt;cellHeight * FontSize) / FontData-&gt;cellWidth)) /
             FontData-&gt;cellHeight);
    s16 texLeft = xChar;
    s16 texTop = yChar;
    s16 texRight = (xChar + FontData-&gt;cellWidth);
    s16 texBottom = (yChar + FontData-&gt;cellHeight);

    GXBegin (0x80, 0, 4);
    GXPosition3s16 (posLeft, posTop, z);
    GXTexCoord2s16 (texLeft, texTop);
    GXPosition3s16 (posRight, posTop, z);
    GXTexCoord2s16 (texRight, texTop);
    GXPosition3s16 (posRight, posBottom, z);
    GXTexCoord2s16 (texRight, texBottom);
    GXPosition3s16 (posLeft, posBottom, z);
    GXTexCoord2s16 (texLeft, texBottom);
    GXEnd();
}

static void
LoadSheet (void* image, enum _GXTexMapID texMapID)
{
    float            mtx[3][4];
    struct _GXTexObj texObj;

    if (LastSheet != image)
    {
        LastSheet = image;
        GXInitTexObj (&amp;texObj,
                      image,
                      FontData-&gt;sheetWidth,
                      FontData-&gt;sheetHeight,
                      FontData-&gt;sheetFormat,
                      0,
                      0,
                      0);
        GXInitTexObjLOD (&amp;texObj, 1, 1, 0, 0, 0, 0.0f, 0.0f, 0.0f);
        GXLoadTexObj (&amp;texObj, texMapID);
        MTXScale (mtx, 1.0f / FontData-&gt;sheetWidth, 1.0f / FontData-&gt;sheetHeight, 1.0f);
        GXLoadTexMtxImm (mtx, 0x1E, 1);
        GXSetNumTexGens (1);
        GXSetTexCoordGen (0, 1, 4, 0x1E);
    }
}

int
DEMORFPuts (s16 x, s16 y, s16 z, char* string)
{
    s32   cx;
    void* image;
    s32   xChar;
    s32   yChar;
    s32   width;

    ASSERTLINE (0x210, FontData);
    LastSheet = NULL;
    GXClearVtxDesc();
    GXSetVtxDesc (9, 1);
    GXSetVtxDesc (0xD, 1);
    GXSetVtxAttrFmt (0, 9, 1, 3, 4);
    GXSetVtxAttrFmt (0, 0xD, 1, 3, 0);

    x *= 0x10;
    y *= 0x10;
    z *= 0x10;

    width = 0;
    while (*string != 0)
    {
        if (*string == 0xA)
        {
            width = 0;
            y += FontData-&gt;leading * 0x10;
            string++;
        }
        else
        {
            string = OSGetFontTexture (string, &amp;image, &amp;xChar, &amp;yChar, &amp;cx);
            LoadSheet (image, 0);
            DrawFontChar (x + width, y, z, xChar, yChar);
            width = FontSpace + ((FontSize * cx) / FontData-&gt;cellWidth) + width;
        }
    }
    return (width + 0xF) / 16;
}

int
DEMORFPutsEx (s16 x, s16 y, s16 z, char* string, s16 maxWidth, int length)
{
    s32   cx;
    void* image;
    s32   xChar;
    s32   yChar;
    s32   width;
    char* end;

    ASSERTLINE (0x23D, FontData);
    LastSheet = NULL;
    GXClearVtxDesc();
    GXSetVtxDesc (9, 1);
    GXSetVtxDesc (0xD, 1);
    GXSetVtxAttrFmt (0, 9, 1, 3, 4);
    GXSetVtxAttrFmt (0, 0xD, 1, 3, 0);

    x *= 0x10;
    y *= 0x10;
    z *= 0x10;
    maxWidth *= 0x10;

    end = (char*)&amp;string[length];
    width = 0;
    while (*string &amp;&amp; string &lt; end)
    {
        if (*string == 0xA)
        {
            width = 0;
            y += FontData-&gt;leading * 0x10;
            string++;
        }
        else
        {
            string = OSGetFontTexture (string, &amp;image, &amp;xChar, &amp;yChar, &amp;cx);
            if (maxWidth &lt; width + (FontSize * cx / FontData-&gt;cellWidth) + FontSpace)
            {
                width = 0;
                y += FontData-&gt;leading * 0x10;
            }
            LoadSheet (image, 0);
            DrawFontChar (x + width, y, z, xChar, yChar);
            width = FontSpace + (FontSize * cx / FontData-&gt;cellWidth) + width;
        }
    }
    return (width + 0xF) / 16;
}

int
DEMORFPrintf (s16 x, s16 y, s16 z, char* fmt, ...)
{
    va_list vlist;
    s8      buf[256];

    va_start (vlist, fmt);
    vsprintf (buf, fmt, vlist);
    DEMORFPuts (x, y, z, buf);
}

char*
DEMODumpROMFont (char* string)
{
    u32   image[288];
    void* temp;
    int   i;
    int   j;
    s32   width;

    ASSERTLINE (0x295, FontData);

    if (OSGetFontEncode() == 1)
    {
        temp = (void*)((u32)FontData + 0xD3F00);
    }
    else
    {
        temp = (void*)((u32)FontData + 0x1D120);
    }
    temp = (void*)((u32)temp &amp; 0xFFFFFFE0);
    OSLoadFont (FontData, temp);
    string = OSGetFontTexel (string, &amp;image[0], 0, 0xC, &amp;width);
    for (i = 0; i &lt; 0x30; i++)
    {
        j = (i % 8) + ((i / 8) * 0x30);
        OSReport (&quot;%08x%08x%08x%08x%08x%08x\n&quot;,
                  image[j],
                  image[j + 8],
                  image[j + 0x10],
                  image[j + 0x18],
                  image[j + 0x20],
                  image[j + 0x28]);
    }
    OSReport (&quot;\nwidth %d\n&quot;, width);
    OSInitFont (FontData);
    return string;
}

int
DEMOGetRFTextWidth (char* string)
{
    s32 cx;
    s32 width;

    ASSERTLINE (0x2C3, FontData);
    width = 0;
    while (*string != 0)
    {
        string = OSGetFontWidth (string, &amp;cx);
        width = FontSpace + ((FontSize * cx) / FontData-&gt;cellWidth) + width;
    }
    return (width + 0xF) / 16;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>