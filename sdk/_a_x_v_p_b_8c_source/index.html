<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File AXVPB.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-axvpbc">File AXVPB.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_284807f63fc993a939ff676a07eb86c2/"><strong>ax</strong></a> <strong>&gt;</strong> <a href="../_a_x_v_p_b_8c/"><strong>AXVPB.c</strong></a></p>
<p><a href="../_a_x_v_p_b_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/ax.h&gt;

#include &lt;dolphin.h&gt;

#include &quot;AXPrivate.h&quot;

static u32 __AXSrcCycles[5] = { 0x00000DF8, 0x00000F78, 0x000014B8, 0x000019F8, 0x000019F8 };

static u32 __AXMixCycles[32] = {
    0x000005BE, 0x00000B7C, 0x00000B7C, 0x0000113A, 0x000008B6, 0x00000E74, 0x00000E74, 0x00001432,
    0x000009A6, 0x0000134C, 0x0000134C, 0x00001CF2, 0x00000E97, 0x0000183D, 0x0000183D, 0x000021E3,
    0x00000B7C, 0x00001432, 0x00000B7C, 0x00001432, 0x00000B7C, 0x00000B7C, 0x00000B7C, 0x00000B7C,
    0x0000134C, 0x000021E3, 0x0000134C, 0x000021E3, 0x0000134C, 0x000021E3, 0x0000134C, 0x000021E3
};

static AXPB          __AXPB[AX_MAX_VOICES] ALIGN (32);
static AXPBITDBUFFER __AXITD[AX_MAX_VOICES] ALIGN (32);
static AXPBU         __AXUpdates[AX_MAX_VOICES] ALIGN (32);
static AXVPB         __AXVPB[AX_MAX_VOICES];

static u32 __AXMaxDspCycles;
static u32 __AXRecDspCycles;
static u32 __AXNumVoices;

u32
__AXGetNumVoices (void)
{
    return __AXNumVoices;
}

void
__AXServiceVPB (AXVPB* pvpb)
{
    AXPB* ppbDsp;
    AXPB* ppbUser;
    u32   sync;

    ASSERTLINE (0xA1, (pvpb-&gt;index &gt;= 0) &amp;&amp; (pvpb-&gt;index &lt; AX_MAX_VOICES));
    __AXNumVoices += 1;
    ppbDsp = &amp;__AXPB[pvpb-&gt;index];
    ppbUser = &amp;pvpb-&gt;pb;
    sync = pvpb-&gt;sync;
    if (sync == 0)
    {
        ppbUser-&gt;state = ppbDsp-&gt;state;
        ppbUser-&gt;ve.currentVolume = ppbDsp-&gt;ve.currentVolume;
        ppbUser-&gt;addr.currentAddressHi = ppbDsp-&gt;addr.currentAddressHi;
        ppbUser-&gt;addr.currentAddressLo = ppbDsp-&gt;addr.currentAddressLo;
        return;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYALL)
    {
        // copy the whole PB struct. (size: 0xC0)
        u32* src;
        u32* dst;
        src = (void*)ppbUser;
        dst = (void*)ppbDsp;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        if (pvpb-&gt;updateCounter != 0)
        {
            u32 count;
            src = (void*)&amp;__AXUpdates[pvpb-&gt;index];
            dst = (void*)pvpb-&gt;updateData;
            for (count = pvpb-&gt;updateCounter; count; count--)
            {
                *(dst) = *(src);
                dst += 1;
                src += 1;
            }
        }
        return;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYSELECT)
    {
        ppbDsp-&gt;srcSelect = ppbUser-&gt;srcSelect;
        ppbDsp-&gt;coefSelect = ppbUser-&gt;coefSelect;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYMXRCTRL)
    {
        ppbDsp-&gt;mixerCtrl = ppbUser-&gt;mixerCtrl;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYSTATE)
    {
        ppbDsp-&gt;state = ppbUser-&gt;state;
    }
    else
    {
        ppbUser-&gt;state = ppbDsp-&gt;state;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYTYPE)
    {
        ppbDsp-&gt;type = ppbUser-&gt;type;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYAXPBMIX)
    {
        // copy AXPBMIX.
        u16* src;
        u16* dst;
        src = (void*)&amp;ppbUser-&gt;mix;
        dst = (void*)&amp;ppbDsp-&gt;mix;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
    }
    if (sync &amp; AX_SYNC_FLAG_COPYTSHIFT)
    {
        ppbDsp-&gt;itd.targetShiftL = ppbUser-&gt;itd.targetShiftL;
        ppbDsp-&gt;itd.targetShiftR = ppbUser-&gt;itd.targetShiftR;
    }
    else if (sync &amp; AX_SYNC_FLAG_COPYITD)
    {
        // copy ITD struct.
        u16* src;
        u16* dst;
        u32* dst_;
        src = (void*)&amp;ppbUser-&gt;itd;
        dst = (void*)&amp;ppbDsp-&gt;itd;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        src += 1;
        dst_ = pvpb-&gt;itdBuffer;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
        dst += 1;
        *(dst) = 0;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYUPDATE)
    {
        // copy UPDATE struct.
        u16* src;
        u16* dst;
        dst = (void*)&amp;ppbDsp-&gt;update;
        src = (void*)&amp;ppbUser-&gt;update;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        if (pvpb-&gt;updateCounter)
        {
            u32* src_;
            u32* dst_;
            u32  count;

            dst_ = (void*)&amp;__AXUpdates[pvpb-&gt;index];
            src_ = (void*)&amp;pvpb-&gt;updateData;

            for (count = pvpb-&gt;updateCounter; count; count--)
            {
                *(dst_) = *(src_);
                dst_ += 1;
                src_ += 1;
            }
        }
    }
    if (sync &amp; AX_SYNC_FLAG_COPYDPOP)
    {
        // copy DPOP struct.
        u16* src;
        u16* dst;
        dst = (u16*)&amp;ppbDsp-&gt;dpop;
        src = (u16*)&amp;ppbUser-&gt;dpop;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
    }
    if (sync &amp; AX_SYNC_FLAG_SWAPVOL)
    {
        ppbUser-&gt;ve.currentVolume = ppbDsp-&gt;ve.currentVolume;
        ppbDsp-&gt;ve.currentDelta = ppbUser-&gt;ve.currentDelta;
    }
    else if (sync &amp; AX_SYNC_FLAG_COPYVOL)
    {
        ppbDsp-&gt;ve.currentVolume = ppbUser-&gt;ve.currentVolume;
        ppbDsp-&gt;ve.currentDelta = ppbUser-&gt;ve.currentDelta;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYFIR)
    {
        // copy FIR struct.
        u16* src;
        u16* dst;
        dst = (void*)&amp;ppbDsp-&gt;fir;
        src = (void*)&amp;ppbUser-&gt;fir;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
    }
    if (sync &amp; (AX_SYNC_FLAG_COPYLOOP | AX_SYNC_FLAG_COPYLOOPADDR | AX_SYNC_FLAG_COPYENDADDR |
                AX_SYNC_FLAG_COPYCURADDR))
    {
        if (sync &amp; AX_SYNC_FLAG_COPYLOOP)
        {
            ppbDsp-&gt;addr.loopFlag = ppbUser-&gt;addr.loopFlag;
        }
        if (sync &amp; AX_SYNC_FLAG_COPYLOOPADDR)
        {
            *(u32*)&amp;ppbDsp-&gt;addr.loopAddressHi = *(u32*)&amp;ppbUser-&gt;addr.loopAddressHi;
        }
        if (sync &amp; AX_SYNC_FLAG_COPYENDADDR)
        {
            *(u32*)&amp;ppbDsp-&gt;addr.endAddressHi = *(u32*)&amp;ppbUser-&gt;addr.endAddressHi;
        }
        if (sync &amp; AX_SYNC_FLAG_COPYCURADDR)
        {
            *(u32*)&amp;ppbDsp-&gt;addr.currentAddressHi = *(u32*)&amp;ppbUser-&gt;addr.currentAddressHi;
        }
    }
    else if (sync &amp; AX_SYNC_FLAG_COPYADDR)
    {
        // copy ADDR struct.
        u32* src;
        u32* dst;
        dst = (void*)&amp;ppbDsp-&gt;addr;
        src = (void*)&amp;ppbUser-&gt;addr;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
    }
    if (sync &amp; AX_SYNC_FLAG_COPYADPCM)
    {
        // copy ADPCM struct.
        u32* src;
        u32* dst;
        dst = (void*)&amp;ppbDsp-&gt;adpcm;
        src = (void*)&amp;ppbUser-&gt;adpcm;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYRATIO)
    {
        ppbDsp-&gt;src.ratioHi = ppbUser-&gt;src.ratioHi;
        ppbDsp-&gt;src.ratioLo = ppbUser-&gt;src.ratioLo;
    }
    else if (sync &amp; AX_SYNC_FLAG_COPYSRC)
    {
        // copy SRC struct.
        u16* src;
        u16* dst;
        dst = (void*)&amp;ppbDsp-&gt;src;
        src = (void*)&amp;ppbUser-&gt;src;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
    }
    if (sync &amp; AX_SYNC_FLAG_COPYADPCMLOOP)
    {
        // copy ADPCMLOOP struct.
        u16* src;
        u16* dst;
        dst = (void*)&amp;ppbDsp-&gt;adpcmLoop;
        src = (void*)&amp;ppbUser-&gt;adpcmLoop;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
    }
}

void
__AXDumpVPB (AXVPB* pvpb)
{
    AXPB* ppbDsp;

    ppbDsp = &amp;__AXPB[pvpb-&gt;index];
    if (ppbDsp-&gt;state == 1)
    {
        __AXDepopVoice (ppbDsp);
    }
    pvpb-&gt;pb.state = ppbDsp-&gt;state = ppbDsp-&gt;update.updNum[0] = ppbDsp-&gt;update.updNum[1] =
        ppbDsp-&gt;update.updNum[2] = ppbDsp-&gt;update.updNum[3] = ppbDsp-&gt;update.updNum[4] = 0;
    __AXPushCallbackStack (pvpb);
}

void
__AXSyncPBs (u32 lessDspCycles)
{
    u32    cycles;
    u32    i;
    AXVPB* pvpb;

    __AXNumVoices = 0;
    DCInvalidateRange (__AXPB, sizeof (__AXPB));
    DCInvalidateRange (__AXITD, sizeof (__AXITD));
    cycles = (__AXGetCommandListCycles() + 0x10000) - 0x55F0 + lessDspCycles;
    for (i = 31; i; i--)
    {
        for (pvpb = __AXGetStackHead (i); pvpb; pvpb = pvpb-&gt;next)
        {
            if (pvpb-&gt;depop != 0U)
            {
                __AXDepopVoice (&amp;__AXPB[pvpb-&gt;index]);
            }
            if ((pvpb-&gt;pb.state == 1) || (pvpb-&gt;updateCounter != 0U))
            {
                cycles = __AXSrcCycles[pvpb-&gt;pb.src.ratioHi] + __AXMixCycles[pvpb-&gt;pb.mixerCtrl] +
                         0x8C + cycles;
                if (__AXMaxDspCycles &gt; cycles)
                {
                    __AXServiceVPB (pvpb);
                }
                else
                {
                    __AXDumpVPB (pvpb);
                }
            }
            else
            {
                __AXServiceVPB (pvpb);
            }
            pvpb-&gt;sync = 0;
            pvpb-&gt;depop = 0;
            pvpb-&gt;updateMS = pvpb-&gt;updateCounter = 0;
            pvpb-&gt;updateWrite = pvpb-&gt;updateData;
        }
    }
    __AXRecDspCycles = cycles;
    for (pvpb = __AXGetStackHead (0); pvpb; pvpb = pvpb-&gt;next)
    {
        if (pvpb-&gt;depop != 0U)
        {
            __AXDepopVoice (&amp;__AXPB[pvpb-&gt;index]);
        }
        pvpb-&gt;depop = 0;
        __AXPB[pvpb-&gt;index].state = __AXPB[pvpb-&gt;index].update.updNum[0] =
            __AXPB[pvpb-&gt;index].update.updNum[1] = __AXPB[pvpb-&gt;index].update.updNum[2] =
                __AXPB[pvpb-&gt;index].update.updNum[3] = __AXPB[pvpb-&gt;index].update.updNum[4] = 0;
    }
    DCFlushRange (__AXPB, sizeof (__AXPB));
    DCFlushRange (__AXITD, sizeof (__AXITD));
    DCFlushRange (__AXUpdates, sizeof (__AXUpdates));
}

AXPB*
__AXGetPBs (void)
{
    return __AXPB;
}

void
__AXSetPBDefault (AXVPB* p)
{
    p-&gt;pb.state = 0;
    p-&gt;pb.itd.flag = 0;
    p-&gt;sync = 0xA4;
    p-&gt;updateMS = p-&gt;updateCounter = 0;
    p-&gt;updateWrite = p-&gt;updateData;
    p-&gt;pb.update.updNum[0] = p-&gt;pb.update.updNum[1] = p-&gt;pb.update.updNum[2] =
        p-&gt;pb.update.updNum[3] = p-&gt;pb.update.updNum[4] = 0;
}

void
__AXVPBInit (void)
{
    u32            i;
    AXPB*          ppb;
    AXPBITDBUFFER* ppbi;
    AXPBU*         ppbu;
    AXVPB*         pvpb;

#ifdef DEBUG
    OSReport (&quot;Initializing AXVPB code module¥n&quot;);
#endif
    __AXMaxDspCycles = OS_BUS_CLOCK / 400;
    __AXRecDspCycles = 0U;
    memset (__AXPB, 0, sizeof (__AXPB));
    memset (__AXITD, 0, sizeof (__AXITD));
    memset (__AXVPB, 0, sizeof (__AXVPB));
    for (i = 0; i &lt; AX_MAX_VOICES; i++)
    {
        ppb = &amp;__AXPB[i];
        ppbi = &amp;__AXITD[i];
        ppbu = &amp;__AXUpdates[i];
        pvpb = &amp;__AXVPB[i];
        ASSERTLINE (0x2F6, (u32)ppb ^ 0x1F);
        ASSERTLINE (0x2F7, (u32)ppbi ^ 0x1F);
        ASSERTLINE (0x2F8, (u32)ppbu ^ 0x1F);
        pvpb-&gt;index = i;
        pvpb-&gt;updateWrite = pvpb-&gt;updateData;
        pvpb-&gt;itdBuffer = ppbi;
        __AXSetPBDefault (pvpb);
        if (i == 0x3F)
        {
            pvpb-&gt;pb.nextHi = pvpb-&gt;pb.nextLo = ppb-&gt;nextHi = ppb-&gt;nextLo = 0;
        }
        else
        {
            pvpb-&gt;pb.nextHi = (u16)((u32)((char*)ppb + 0xC0) &gt;&gt; 16);
            pvpb-&gt;pb.nextLo = (u16)((u32)((char*)ppb + 0xC0));
            ppb-&gt;nextHi = (u16)((u32)((char*)ppb + 0xC0) &gt;&gt; 16);
            ppb-&gt;nextLo = (u16)((u32)((char*)ppb + 0xC0));
        }
        pvpb-&gt;pb.currHi = (u16)(((u32)ppb) &gt;&gt; 16);
        pvpb-&gt;pb.currLo = (u16)((u32)ppb);
        ppb-&gt;currHi = (u16)(((u32)ppb) &gt;&gt; 16);
        ppb-&gt;currLo = (u16)((u32)ppb);
        pvpb-&gt;pb.itd.bufferHi = (u16)(((u32)ppbi) &gt;&gt; 16);
        pvpb-&gt;pb.itd.bufferLo = (u16)((u32)ppbi);
        ppb-&gt;itd.bufferHi = (u16)(((u32)ppbi) &gt;&gt; 16);
        ppb-&gt;itd.bufferLo = (u16)((u32)ppbi);
        pvpb-&gt;pb.update.dataHi = (u16)(((u32)ppbu) &gt;&gt; 16);
        pvpb-&gt;pb.update.dataLo = (u16)((u32)ppbu);
        ppb-&gt;update.dataHi = (u16)(((u32)ppbu) &gt;&gt; 16);
        ppb-&gt;update.dataLo = (u16)((u32)ppbu);
        __AXPushFreeStack (pvpb);
    }
    DCFlushRange (__AXPB, sizeof (__AXPB));
}

void
__AXVPBQuit (void)
{
#ifdef DEBUG
    OSReport (&quot;Shutting down AXVPB code module¥n&quot;);
#endif
}

void
AXSetVoiceSrcType (AXVPB* p, u32 type)
{
    int   old;
    AXPB* ppb;

    ASSERTLINE (0x35E, p);
    ASSERTLINE (0x35F, type &lt;= AX_SRC_TYPE_4TAP_16K);
    old = OSDisableInterrupts();
    ppb = &amp;p-&gt;pb;
    switch (type)
    {
        case AX_SRC_TYPE_NONE:
            ppb-&gt;srcSelect = 2;
            break;
        case AX_SRC_TYPE_LINEAR:
            ppb-&gt;srcSelect = 1;
            break;
        case AX_SRC_TYPE_4TAP_8K:
            ppb-&gt;srcSelect = 0;
            ppb-&gt;coefSelect = 0;
            break;
        case AX_SRC_TYPE_4TAP_12K:
            ppb-&gt;srcSelect = 0;
            ppb-&gt;coefSelect = 1;
            break;
        case AX_SRC_TYPE_4TAP_16K:
            ppb-&gt;srcSelect = 0;
            ppb-&gt;coefSelect = 2;
            break;
    }
    p-&gt;sync |= AX_SYNC_FLAG_COPYSELECT;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceState (AXVPB* p, u16 state)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.state = state;
    p-&gt;sync |= AX_SYNC_FLAG_COPYSTATE;
    if (state == 0)
    {
        p-&gt;depop = 1;
    }
    OSRestoreInterrupts (old);
}

void
AXSetVoiceType (AXVPB* p, u16 type)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.type = type;
    p-&gt;sync |= AX_SYNC_FLAG_COPYTYPE;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceMix (AXVPB* p, AXPBMIX* mix)
{
    int  old;
    u16  mixerCtrl;
    u16* dst;
    u16* src;

    src = (u16*)&amp;mix; 
    dst = (u16*)&amp;p-&gt;pb.mix;

    old = OSDisableInterrupts();

    {
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
    }
    mixerCtrl = 0;
    if (__AXClMode == 4)
    {
        if ((mix-&gt;vAuxAL != 0) || (mix-&gt;vAuxAR != 0))
        {
            mixerCtrl |= 1;
        }
        if ((mix-&gt;vAuxBL != 0) || (mix-&gt;vAuxBR != 0))
        {
            mixerCtrl |= 16;
        }
        if ((mix-&gt;vDeltaL != 0) || (mix-&gt;vDeltaR != 0) || (mix-&gt;vDeltaAuxAL != 0) ||
            (mix-&gt;vDeltaAuxAR != 0) || (mix-&gt;vDeltaAuxAS != 0) || (mix-&gt;vDeltaAuxBL != 0) ||
            (mix-&gt;vDeltaAuxBR != 0))
        {
            mixerCtrl |= 8;
        }
    }
    else
    {
        if ((mix-&gt;vAuxAL != 0) || (mix-&gt;vAuxAR != 0))
        {
            mixerCtrl |= 1;
        }
        if ((mix-&gt;vAuxBL != 0) || (mix-&gt;vAuxBR != 0))
        {
            mixerCtrl |= 2;
        }
        if ((mix-&gt;vS != 0) || (mix-&gt;vAuxAS != 0) || (mix-&gt;vAuxBS != 0))
        {
            mixerCtrl |= 4;
        }
        if ((mix-&gt;vDeltaL != 0) || (mix-&gt;vDeltaR != 0) || (mix-&gt;vDeltaS != 0) ||
            (mix-&gt;vDeltaAuxAL != 0) || (mix-&gt;vDeltaAuxAR != 0) || (mix-&gt;vDeltaAuxAS != 0) ||
            (mix-&gt;vDeltaAuxBL != 0) || (mix-&gt;vDeltaAuxBR != 0) || (mix-&gt;vDeltaAuxBS != 0))
        {
            mixerCtrl |= 8;
        }
    }
    p-&gt;pb.mixerCtrl = mixerCtrl;
    p-&gt;sync |= (AX_SYNC_FLAG_COPYAXPBMIX | AX_SYNC_FLAG_COPYMXRCTRL);
    OSRestoreInterrupts (old);
}

void
AXSetVoiceItdOn (AXVPB* p)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.itd.flag = 1;
    p-&gt;pb.itd.shiftL = p-&gt;pb.itd.shiftR = p-&gt;pb.itd.targetShiftL = p-&gt;pb.itd.targetShiftR = 0;
    p-&gt;sync &amp;= ~(AX_SYNC_FLAG_COPYTSHIFT);
    p-&gt;sync |= AX_SYNC_FLAG_COPYITD;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceItdTarget (AXVPB* p, u16 lShift, u16 rShift)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.itd.targetShiftL = lShift;
    p-&gt;pb.itd.targetShiftR = rShift;
    p-&gt;sync |= AX_SYNC_FLAG_COPYTSHIFT;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceUpdateIncrement (AXVPB* p)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;updateMS++;
    p-&gt;sync |= AX_SYNC_FLAG_COPYUPDATE;
    ASSERTMSGLINE (0x431, p-&gt;updateMS &lt;= 4, &quot;PB updates cannot exceed 5ms¥n&quot;);
    OSRestoreInterrupts (old);
}

void
AXSetVoiceUpdateWrite (AXVPB* p, u16 param, u16 data)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;updateCounter += 2;
    ASSERTMSGLINE (0x43F, p-&gt;updateCounter &lt;= 128, &quot;PB update block exceeded 128 words¥n&quot;);
    *(p-&gt;updateWrite) = param;
    p-&gt;updateWrite += 1;
    *(p-&gt;updateWrite) = data;
    p-&gt;updateWrite += 1;
    p-&gt;sync |= AX_SYNC_FLAG_COPYUPDATE;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceDpop (AXVPB* p, AXPBDPOP* dpop)
{
    int  old;
    u16* dst;
    u16* src;

    dst = (void*)&amp;p-&gt;pb.dpop;
    src = (void*)dpop;

    old = OSDisableInterrupts();
    {
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
    }
    p-&gt;sync |= AX_SYNC_FLAG_COPYDPOP;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceVe (AXVPB* p, AXPBVE* ve)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.ve.currentVolume = ve-&gt;currentVolume;
    p-&gt;pb.ve.currentDelta = ve-&gt;currentDelta;
    p-&gt;sync |= AX_SYNC_FLAG_COPYVOL;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceVeDelta (AXVPB* p, s16 delta)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.ve.currentDelta = delta;
    p-&gt;sync |= AX_SYNC_FLAG_SWAPVOL;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceFir (AXVPB* p, AXPBFIR* fir)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.fir.numCoefs = fir-&gt;numCoefs;
    p-&gt;pb.fir.coefsHi = fir-&gt;coefsHi;
    p-&gt;pb.fir.coefsLo = fir-&gt;coefsLo;
    p-&gt;sync |= AX_SYNC_FLAG_COPYFIR;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceAddr (AXVPB* p, AXPBADDR* addr)
{
    int  old;
    u32* dst;
    u32* src;

    dst = (void*)&amp;p-&gt;pb.addr;
    src = (void*)addr;

    old = OSDisableInterrupts();
    {
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
    }
    switch (addr-&gt;format)
    {
        case 0:
            ASSERTMSGLINE (0x4BA,
                           (addr-&gt;loopAddressLo &amp; 0xF) &gt; 1,
                           &quot;*** loop address on ADPCM frame header! ***¥n&quot;);
            ASSERTMSGLINE (0x4BF,
                           (addr-&gt;endAddressLo &amp; 0xF) &gt; 1,
                           &quot;*** end address on ADPCM frame header! ***¥n&quot;);
            ASSERTMSGLINE (0x4C4,
                           (addr-&gt;currentAddressLo &amp; 0xF) &gt; 1,
                           &quot;*** current address on ADPCM frame header! ***¥n&quot;);
            break;
        case 10:
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0x08000000;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            break;
        case 25:
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            *(dst) = 0x01000000;
            dst += 1;
            *(dst) = 0;
            dst += 1;
            break;
        default:
            ASSERTMSGLINE (0x4F0, 0, &quot;unknown addr-&gt;formaqt in PB¥n&quot;);
            break;
    }
    p-&gt;sync &amp;= ~(AX_SYNC_FLAG_COPYLOOP | AX_SYNC_FLAG_COPYLOOPADDR | AX_SYNC_FLAG_COPYENDADDR |
                 AX_SYNC_FLAG_COPYCURADDR);
    p-&gt;sync |= (AX_SYNC_FLAG_COPYADDR | AX_SYNC_FLAG_COPYADPCM);
    OSRestoreInterrupts (old);
}

void
AXSetVoiceLoop (AXVPB* p, u16 loop)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.addr.loopFlag = loop;
    p-&gt;sync |= AX_SYNC_FLAG_COPYLOOP;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceLoopAddr (AXVPB* p, u32 addr)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.addr.loopAddressHi = (addr &gt;&gt; 0x10U);
    p-&gt;pb.addr.loopAddressLo = (addr);
    p-&gt;sync |= AX_SYNC_FLAG_COPYLOOPADDR;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceEndAddr (AXVPB* p, u32 addr)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.addr.endAddressHi = (addr &gt;&gt; 0x10U);
    p-&gt;pb.addr.endAddressLo = (addr);
    p-&gt;sync |= AX_SYNC_FLAG_COPYENDADDR;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceCurrentAddr (AXVPB* p, u32 addr)
{
    int old;

    old = OSDisableInterrupts();
    p-&gt;pb.addr.currentAddressHi = (addr &gt;&gt; 0x10U);
    p-&gt;pb.addr.currentAddressLo = (addr);
    p-&gt;sync |= AX_SYNC_FLAG_COPYCURADDR;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceAdpcm (AXVPB* p, AXPBADPCM* adpcm)
{
    int  old;
    u32* dst;
    u32* src;

    dst = (void*)&amp;p-&gt;pb.adpcm;
    src = (void*)adpcm;

    old = OSDisableInterrupts();

    {
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
    }
    p-&gt;sync |= AX_SYNC_FLAG_COPYADPCM;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceSrc (AXVPB* p, AXPBSRC* src_)
{
    int  old;
    u16* dst;
    u16* src;

    dst = (void*)&amp;p-&gt;pb.src;
    src = (void*)src_;

    old = OSDisableInterrupts();
    {
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
    }
    p-&gt;sync &amp;= ~(AX_SYNC_FLAG_COPYRATIO);
    p-&gt;sync |= AX_SYNC_FLAG_COPYSRC;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceSrcRatio (AXVPB* p, float ratio)
{
    u32 r;
    int old;

    old = OSDisableInterrupts();
    r = 65536.0f * ratio;
    if (r &gt; 0x40000)
    {
        r = 0x40000;
    }
    p-&gt;pb.src.ratioHi = ((u32)r &gt;&gt; 0x10);
    p-&gt;pb.src.ratioLo = ((u32)r);
    p-&gt;sync |= AX_SYNC_FLAG_COPYRATIO;
    OSRestoreInterrupts (old);
}

void
AXSetVoiceAdpcmLoop (AXVPB* p, AXPBADPCMLOOP* adpcmloop)
{
    int  old;
    u16* dst;
    u16* src;

    dst = (void*)&amp;p-&gt;pb.adpcmLoop;
    src = (void*)adpcmloop;
    old = OSDisableInterrupts();
    {
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
        *(dst) = *(src);
        dst += 1;
        src += 1;
    }
    p-&gt;sync |= AX_SYNC_FLAG_COPYADPCMLOOP;
    OSRestoreInterrupts (old);
}

void
AXSetMaxDspCycles (u32 cycles)
{
    __AXMaxDspCycles = cycles;
}

u32
AXGetMaxDspCycles (void)
{
    return __AXMaxDspCycles;
}

u32
AXGetDspCycles (void)
{
    return __AXRecDspCycles;
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>