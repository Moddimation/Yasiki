<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File GXSave.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-gxsavec">File GXSave.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_b80c028b3e970eff7f2a07684ffcf104/"><strong>gx</strong></a> <strong>&gt;</strong> <a href="../_g_x_save_8c/"><strong>GXSave.c</strong></a></p>
<p><a href="../_g_x_save_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#if DEBUG

#include &lt;dolphin/gx.h&gt;
#include &lt;dolphin/os.h&gt;

#include &quot;GXPrivate.h&quot;

static u8* dlist;
static u32 dlistSize;
static u32 bytesRead;

void __GXShadowIndexState (u32 idx_reg, u32 reg_data);

static u8
__ReadMem (void* ptr, u32 sz)
{
    u8* src;
    u8* dst;
    u32 i;

    if (sz &gt; dlistSize - bytesRead)
    {
        return FALSE;
    }

    src = dlist;
    dst = ptr;
    for (i = 0; i &lt; sz; i++)
    {
        *dst++ = *src++;
    }
    bytesRead += sz;
    dlist += sz;
    return TRUE;
}

inline void
DPF (...)
{
    u8 unused[4];
}

static void
__SaveCPRegs (u8 reg, u8 vatIdx, u32 data)
{
    s32 idx;

    DPF (&quot;\tCP Stream Regs[0x%x] = 0x%x\n&quot;, reg, data);
    switch (reg)
    {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
            break;
        case 5:
            __GXData-&gt;vcdLo = data;
            break;
        case 6:
            __GXData-&gt;vcdHi = data;
            break;
        case 7:
            __GXData-&gt;vatA[vatIdx &amp; 0xFF] = data;
            break;
        case 8:
            __GXData-&gt;vatB[vatIdx &amp; 0xFF] = data;
            break;
        case 9:
            __GXData-&gt;vatC[vatIdx &amp; 0xFF] = data;
            break;
        case 10:
            idx = vatIdx - 0x15;
            if ((idx &gt;= 0) &amp;&amp; (idx &lt; 4))
            {
                __GXData-&gt;indexBase[idx] = data;
            }
            break;
        case 11:
            idx = vatIdx - 0x15;
            if ((idx &gt;= 0) &amp;&amp; (idx &lt; 4))
            {
                __GXData-&gt;indexStride[idx] = data;
            }
            break;
        default:
            OSReport (&quot;GX DisplayList: Invalid CP Stream Register Address 0x%x\n&quot;, reg);
            break;
    }
}

static u32 vtxCompSize[5] = { 1, 1, 2, 2, 4 };
static int clrCompSize[6] = { 2, 3, 4, 2, 3, 4 };

static u32
GetAttrSize (u8 vatIdx, u32 attrIdx)
{
    u32 vcd;
    u32 vat;
    u32 nc;

    switch (attrIdx)
    {
        case 0:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 0) ? 1 : 0;
        case 1:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 1) ? 1 : 0;
        case 2:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 2) ? 1 : 0;
        case 3:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 3) ? 1 : 0;
        case 4:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 4) ? 1 : 0;
        case 5:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 5) ? 1 : 0;
        case 6:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 6) ? 1 : 0;
        case 7:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 7) ? 1 : 0;
        case 8:
            return GET_REG_FIELD (__GXData-&gt;vcdLo, 1, 8) ? 1 : 0;
        case 9:
            vcd = __GXData-&gt;vcdLo;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 9))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return ((vat &amp; 1) + 2) * vtxCompSize[(vat &gt;&gt; 1) &amp; 7];
            }
            break;
        case 10:
            vcd = __GXData-&gt;vcdLo;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            if ((vat &gt;&gt; 9) &amp; 1)
            {
                nc = 8;
            }
            else
            {
                nc = 3;
            }
            switch (GET_REG_FIELD (vcd, 2, 11))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 9) &amp; 1) + nc) * vtxCompSize[(vat &gt;&gt; 10) &amp; 7];
            }
            break;
        case 11:
            switch (GET_REG_FIELD (__GXData-&gt;vcdLo, 2, 13))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    vat = __GXData-&gt;vatA[vatIdx];
                    return clrCompSize[(vat &gt;&gt; 14) &amp; 7];
            }
            break;
        case 12:
            switch (GET_REG_FIELD (__GXData-&gt;vcdLo, 2, 15))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    vat = __GXData-&gt;vatA[vatIdx];
                    return clrCompSize[(vat &gt;&gt; 18) &amp; 7];
            }
            break;
        case 13:
            vcd = __GXData-&gt;vcdHi;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 0))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 21) &amp; 1) + 1) * vtxCompSize[(vat &gt;&gt; 22) &amp; 7];
            }
            break;
        case 14:
            vcd = __GXData-&gt;vcdHi;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 2))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 0) &amp; 1) + 1) * vtxCompSize[(vat &gt;&gt; 1) &amp; 7];
            }
            break;
        case 15:
            vcd = __GXData-&gt;vcdHi;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 4))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 9) &amp; 1) + 1) * vtxCompSize[(vat &gt;&gt; 10) &amp; 7];
            }
            break;
        case 16:
            vcd = __GXData-&gt;vcdHi;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 6))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 18) &amp; 1) + 1) * vtxCompSize[(vat &gt;&gt; 19) &amp; 7];
            }
            break;
        case 17:
            vcd = __GXData-&gt;vcdHi;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 8))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 27) &amp; 1) + 1) * vtxCompSize[(vat &gt;&gt; 28) &amp; 7];
            }
            break;
        case 18:
            vcd = __GXData-&gt;vcdHi;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 10))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 5) &amp; 1) + 1) * vtxCompSize[(vat &gt;&gt; 6) &amp; 7];
            }
            break;
        case 19:
            vcd = __GXData-&gt;vcdHi;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 12))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 14) &amp; 1) + 1) * vtxCompSize[(vat &gt;&gt; 15) &amp; 7];
            }
            break;
        case 20:
            vcd = __GXData-&gt;vcdHi;
            vat = __GXData-&gt;vatA[vatIdx &amp; 0xFF];
            switch (GET_REG_FIELD (vcd, 2, 14))
            {
                case 0:
                    return 0;
                case 2:
                    return 1;
                case 3:
                    return 2;
                case 1:
                    return (((vat &gt;&gt; 23) &amp; 1) + 1) * vtxCompSize[(vat &gt;&gt; 24) &amp; 7];
            }
            break;
    }
    return 0;
}

static void
__ParseVertexData (u8 vatIdx)
{
    u16    vcnt;
    GXAttr attrIdx;
    u32    vsize;

    if (__ReadMem (&amp;vcnt, 2))
    {
        vsize = 0;
        for (attrIdx = 0; attrIdx &lt; 26; attrIdx++)
        {
            if (attrIdx != 25)
            {
                vsize += GetAttrSize (vatIdx, attrIdx);
            }
        }
        vsize *= vcnt;
        dlist += vsize;
        bytesRead += vsize;
    }
}

void
__GXShadowDispList (void* list, u32 nbytes)
{
    u8  cmd;
    u8  cmdOp;
    u8  vatIdx;
    u32 reg32;
    u32 d32;
    u8  reg8;
    u32 i;
    u32 addr;
    u32 cnt;

    if (__gxVerif-&gt;verifyLevel == GX_WARN_NONE)
    {
        return;
    }

    dlist = list;
    dlistSize = nbytes;
    bytesRead = 0;
    while (dlistSize &gt; bytesRead)
    {
        if (!__ReadMem (&amp;cmd, 1))
        {
            return;
        }
        cmdOp = (u32)GET_REG_FIELD ((u32)cmd, 5, 3);
        vatIdx = cmd &amp; 7;
        switch (cmdOp)
        {
            case 0:
            case 9:
                break;
            case 16:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
                __GXVerifyState (vatIdx);
                __ParseVertexData (vatIdx);
                break;
            case 1:
                if (__ReadMem (&amp;reg8, 1) &amp;&amp; __ReadMem (&amp;d32, 4))
                {
                    __SaveCPRegs (reg8, vatIdx, d32);
                }
                break;
            case 2:
                if (__ReadMem (&amp;reg32, 4))
                {
                    cnt = GET_REG_FIELD (reg32, 4, 16) + 1;
                    addr = (u16)reg32;
                    DPF (&quot;\tXFReg = 0x%x, Cnt = %d\n&quot;, addr, cnt);
                    for (i = 0; i &lt; cnt; i++)
                    {
                        if (__ReadMem (&amp;d32, 4))
                        {
                            DPF (&quot;\tXFData = 0x%x\n&quot;, d32);
                            VERIF_MTXLIGHT (addr, d32);
                            addr++;
                        }
                    }
                }
                break;
            case 4:
            case 5:
            case 6:
            case 7:
                if (__ReadMem (&amp;reg32, 4))
                {
                    DPF (&quot;\tXF_INDEX_LOAD: = 0x%x\n&quot;, reg32);
                    __GXShadowIndexState (cmdOp, reg32);
                }
                break;
            case 8:
                OSReport (&quot;GX DisplayList: Nested Display Lists\n&quot;);
                return;
            case 12:
            case 13:
                if (__ReadMem (&amp;reg32, 4))
                {
                    DPF (&quot;\tSU Bypass = 0x%x\n&quot;, reg32);
                    __gxVerif-&gt;rasRegs[(reg32 &gt;&gt; 24) &amp; 0xFF] = reg32;
                }
                break;
            default:
                OSReport (&quot;GX DisplayList: Bad Display List Command: %d\n&quot;, cmdOp);
                break;
        }
    }
}

void
__GXShadowIndexState (u32 idx_reg, u32 reg_data)
{
    u32* basePtr;
    u32* memAddr;
    u32  cnt;
    u32  stride;
    u32  addr;
    u32  data;
    u32  index;
    u32  i;

    i = idx_reg - 4;
    basePtr = OSPhysicalToCached (__GXData-&gt;indexBase[i]);
    stride = __GXData-&gt;indexStride[i];
    addr = reg_data &amp; 0xFFF;
    cnt = (reg_data &gt;&gt; 12) &amp; 0xF;
    index = reg_data &gt;&gt; 16;
    memAddr = (u32*)((u8*)basePtr + (index * stride));

    while (cnt-- != 0)
    {
        data = *memAddr;
        VERIF_MTXLIGHT (addr, data);
        memAddr = (u32*)((u8*)memAddr + stride);
        addr++;
    }

    &amp;data; // needed to match
}

void
__GXPrintShadowState (void)
{
    u32 i;
    u32 j;

    OSReport (&quot;CP State:\n&quot;);
    OSReport (&quot;\tvcdLo = 0x%x\n&quot;, __GXData-&gt;vcdLo);
    OSReport (&quot;\tvcdHi = 0x%x\n&quot;, __GXData-&gt;vcdHi);
    OSReport (&quot;\thasBiNrms = 0x%x\n&quot;, __GXData-&gt;hasBiNrms);
    for (i = 0; i &lt; 8; i++)
    {
        OSReport (&quot;\tVertex Format %d:\n&quot;, i);
        OSReport (&quot;\t\tvatA = 0x%x\n&quot;, __GXData-&gt;vatA[i]);
        OSReport (&quot;\t\tvatB = 0x%x\n&quot;, __GXData-&gt;vatB[i]);
        OSReport (&quot;\t\tvatC = 0x%x\n&quot;, __GXData-&gt;vatC[i]);
    }
    OSReport (&quot;\n-------------------------------------\n&quot;);
    OSReport (&quot;XF Pos/Tex Matrix State:\n&quot;);
    for (i = 0; i &lt; 256; i += 4)
    {
        if (__gxVerif-&gt;xfMtxDirty[i])
        {
            OSReport (&quot;\tXF_MATRIX[%d] = &quot;, i);
            OSReport (&quot;%f, %f, %f, %f\n&quot;,
                      *(f32*)&amp;__gxVerif-&gt;xfMtx[i],
                      *(f32*)&amp;__gxVerif-&gt;xfMtx[i + 1],
                      *(f32*)&amp;__gxVerif-&gt;xfMtx[i + 2],
                      *(f32*)&amp;__gxVerif-&gt;xfMtx[i + 3]);
        }
    }
    OSReport (&quot;\n-------------------------------------\n&quot;);
    OSReport (&quot;XF Normal Matrix State:\n&quot;);
    for (i = 0; i &lt; 96; i += 3)
    {
        if (__gxVerif-&gt;xfNrmDirty[i])
        {
            OSReport (&quot;\tXF_NRM_MTX[%d] = &quot;, i);
            OSReport (&quot;%f, %f, %f\n&quot;,
                      *(f32*)&amp;__gxVerif-&gt;xfMtx[i],
                      *(f32*)&amp;__gxVerif-&gt;xfMtx[i + 1],
                      *(f32*)&amp;__gxVerif-&gt;xfMtx[i + 2]);
        }
    }
    OSReport (&quot;\n-------------------------------------\n&quot;);
    OSReport (&quot;XF Light State:\n&quot;);
    for (i = 0; i &lt; 128; i += 16)
    {
        if (__gxVerif-&gt;xfLightDirty[i])
        {
            OSReport (&quot;\tXF_LIGHT[%d]:\n&quot;, i &gt;&gt; 4);
            for (j = 0; j &lt; 4; j++)
            {
                OSReport (&quot;\t\tparam[%d] = 0x%x\n&quot;, j, __gxVerif-&gt;xfLight[i + j]);
            }
            for (j = 4; j &lt; 16; j++)
            {
                OSReport (&quot;\t\tparam[%d] = %Lg\n&quot;, j, *(f32*)&amp;__gxVerif-&gt;xfLight[i + j]);
            }
        }
    }
    OSReport (&quot;\n-------------------------------------\n&quot;);
    OSReport (&quot;XF Register State:\n&quot;);
    for (i = 0; i &lt; 80; i++)
    {
        if (__gxVerif-&gt;xfRegsDirty[i])
        {
            OSReport (&quot;\tXF_REG[0x%x] = 0x%x (%f)\n&quot;,
                      i,
                      __gxVerif-&gt;xfRegs[i],
                      *(f32*)&amp;__gxVerif-&gt;xfRegs[i]);
        }
    }
    OSReport (&quot;\n-------------------------------------\n&quot;);
    OSReport (&quot;Raster Registers State:\n&quot;);
    for (i = 0; i &lt; 256; i++)
    {
        OSReport (&quot;\tRAS_REG[0x%x] = 0x%x\n&quot;, i, __gxVerif-&gt;rasRegs[i]);
    }
    OSReport (&quot;\n-------------------------------------\n&quot;);
}
#endif
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>