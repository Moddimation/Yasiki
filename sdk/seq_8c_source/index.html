<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File seq.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-seqc">File seq.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_0c56b33aa00ddb0e63af648508d6e3f4/"><strong>decomp</strong></a> <strong>&gt;</strong> <a href="../dir_7403dcf2df2f5392613493bf2b736904/"><strong>DolphinSDK</strong></a> <strong>&gt;</strong> <a href="../dir_84dd7f8d193350365bcacfbd02904e42/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../dir_099eac09ed7894d1733885fc00e718ed/"><strong>dolphin</strong></a> <strong>&gt;</strong> <a href="../dir_5d353e38bc710c008caaf00d8b6cf945/"><strong>seq</strong></a> <strong>&gt;</strong> <a href="../seq_8c/"><strong>seq.c</strong></a></p>
<p><a href="../seq_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &lt;dolphin/seq.h&gt;

#include &lt;dolphin.h&gt;

static u8 __SEQMidiEventLength[128] = {
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static SEQSEQUENCE* __SEQSequenceList;

// functions
static void __SEQPushSequenceList (SEQSEQUENCE* sequence);
static void __SEQRemoveSequenceFromList (SEQSEQUENCE* sequence);
static u32  __SEQGetIntTrack (SEQTRACK* track);
static void __SEQHandleSysExEvent (SEQTRACK* track);
static void __SEQSetTicksPerFrame (SEQTRACK* track, float bps);
static void __SEQTempoMetaEvent (SEQTRACK* track);
static void __SEQTrackEnd (SEQTRACK* track);
static void __SEQHandleMetaEvent (SEQTRACK* track);
static void __SEQHandleSynthEvent (struct SYNSYNTH* synth, SEQTRACK* track);
static void __SEQRunEvent (struct SYNSYNTH* synth, SEQTRACK* track);
static void __SEQInitTracks (SEQSEQUENCE* sequence, u8* read, int tracks);
static void __SEQReadHeader (SEQSEQUENCE* sequence, u8* midiStream);

static void
__SEQPushSequenceList (SEQSEQUENCE* sequence)
{
    int old;

    old = OSDisableInterrupts();
    if (__SEQSequenceList)
    {
        sequence-&gt;next = __SEQSequenceList;
    }
    else
    {
        sequence-&gt;next = NULL;
    }
    __SEQSequenceList = sequence;
    OSRestoreInterrupts (old);
}

static void
__SEQRemoveSequenceFromList (SEQSEQUENCE* sequence)
{
    int          old;
    SEQSEQUENCE* thisSequence;
    SEQSEQUENCE* next;

    old = OSDisableInterrupts();
    thisSequence = __SEQSequenceList;
    __SEQSequenceList = NULL;

    while (thisSequence)
    {
        next = thisSequence-&gt;next;
        if (thisSequence != sequence)
        {
            __SEQPushSequenceList (thisSequence);
        }
        thisSequence = next;
    }
    OSRestoreInterrupts (old);
}

static u32
__SEQGetIntTrack (SEQTRACK* track)
{
    u32 value;

    ASSERTLINE (0x6F, track);
    for (value = *track-&gt;current &amp; 0x7F; *track-&gt;current &amp; 0x80;
         value = (value &lt;&lt; 7) + (*track-&gt;current &amp; 0x7F))
    {
        track-&gt;current += 1;
    }
    track-&gt;current += 1;
    return value;
}

static void
__SEQHandleSysExEvent (SEQTRACK* track)
{
    u32 length;

    ASSERTLINE (0x86, track);
    length = __SEQGetIntTrack (track);
    track-&gt;current += length;
}

static void
__SEQSetTicksPerFrame (SEQTRACK* track, float bps)
{
    SEQSEQUENCE* sequence;

    ASSERTLINE (0x94, track);
    sequence = track-&gt;sequence;
    track-&gt;beatsPerSec = bps;
    track-&gt;ticksPerFrame = (65536.0f * (160.0f / ((32000.0f / bps) / sequence-&gt;timeFormat)));
}

static void
__SEQTempoMetaEvent (SEQTRACK* track)
{
    u32   data;
    float beatsPerSec;

    data = *track-&gt;current;
    track-&gt;current += 1;
    data = (*track-&gt;current + (data * 0xFF));
    track-&gt;current += 1;
    data = (*track-&gt;current + (data * 0xFF));
    track-&gt;current += 1;
    beatsPerSec = 1000000 / (f32)data;
    __SEQSetTicksPerFrame (track, beatsPerSec);
}

static void
__SEQTrackEnd (SEQTRACK* track)
{
    SEQSEQUENCE* sequence;

    ASSERTLINE (0xBE, track);
    sequence = track-&gt;sequence;
    sequence-&gt;tracksRunning--;
    track-&gt;state = 0;
    if (sequence-&gt;tracksRunning == 0)
    {
        sequence-&gt;end = 1;
    }
}

static void
__SEQHandleMetaEvent (SEQTRACK* track)
{
    u8  type;
    u32 length;
    int unused;

    length; // dumb fix
    ASSERTLINE (0xD1, track);
    type = *track-&gt;current;
    track-&gt;current += 1;
    switch (type)
    {
        case 0x2F:
            __SEQTrackEnd (track);
            return;
        case 0x51:
            __SEQGetIntTrack (track);
            __SEQTempoMetaEvent (track);
            return;
        default:
            length = __SEQGetIntTrack (track);
            track-&gt;current += length;
            return;
    }
}

static void
__SEQHandleSynthEvent (struct SYNSYNTH* synth, SEQTRACK* track)
{
    u8   ch[3];
    u32  bytes;
    void (*callback) (void*, u8);

    bytes = __SEQMidiEventLength[track-&gt;status - 0x80];
    ch[0] = track-&gt;status;
    switch (bytes)
    {
        case 0:
            break;
        case 1:
            ch[1] = *track-&gt;current;
            track-&gt;current += 1;
            break;
        case 2:
            ch[1] = *track-&gt;current;
            track-&gt;current += 1;
            ch[2] = *track-&gt;current;
            track-&gt;current += 1;
            break;
    }
    if (ch[0] &amp; 0xB0)
    {
        callback = ((SEQSEQUENCE*)track-&gt;sequence)-&gt;callback[ch[1]];
        if (callback)
        {
            callback (track, ch[1]);
        }
    }
    SYNMidiInput (synth, ch);
}

static void
__SEQRunEvent (struct SYNSYNTH* synth, SEQTRACK* track)
{
    u8 event;

    ASSERTLINE (0x126, synth);
    ASSERTLINE (0x127, track);
    event = *track-&gt;current;
    if (event &gt;= 0x80)
    {
        track-&gt;status = event;
        track-&gt;current += 1;
    }
    switch (track-&gt;status)
    {
        case 0xF7:
        case 0xF0:
            __SEQHandleSysExEvent (track);
            break;
        case 0xFF:
            __SEQHandleMetaEvent (track);
            break;
        default:
            __SEQHandleSynthEvent (synth, track);
            break;
    }
    if (track-&gt;current &gt;= track-&gt;end)
    {
        __SEQTrackEnd (track);
    }
}

static void
__SEQInitTracks (SEQSEQUENCE* sequence, u8* read, int tracks)
{
    int       i;
    u8*       p;
    u32       chunk;
    u32       bytes;
    SEQTRACK* track;

    i = 0;
    p = read;
    while (tracks)
    {
        while (1)
        {
            chunk = *(u32*)p;
            p += 4;
            bytes = *(u32*)p;
            p += 4;
            if (chunk == 'MTrk')
            {
                track = &amp;sequence-&gt;track[i];
                track-&gt;sequence = sequence;
                track-&gt;start = p;
                track-&gt;end = &amp;p[bytes];
                track-&gt;current = p;
                track-&gt;defaultTicksPerFrame =
                    (u32)(65536.0f * (160.0f / (16000.0f / (f32)sequence-&gt;timeFormat)));
                track-&gt;state = 0;
                p += bytes;
                break;
            }
            p += bytes;
        }
        tracks--;
        i++;
    }
}

static void
__SEQReadHeader (SEQSEQUENCE* sequence, u8* midiStream)
{
    u8* read;
    u32 bytes;
    u32 fileType;

    read = midiStream;
    ASSERTMSGLINE (0x188, *(u32*)read == 'MThd', &quot;!!!midiStream is not a valid MIDI file짜n!!!&quot;);
    read += 4;
    bytes = *(u32*)read;
    read += 4;
    fileType = *(u16*)read;
    read += 2;
    sequence-&gt;nTracks = *(u16*)read;
    read += 2;
    sequence-&gt;timeFormat = *(s16*)read;
    read += 2;
    ASSERTMSGLINE (0x197, sequence-&gt;timeFormat &gt;= 0, &quot;!!!SEQ does not support SMPTE time!!!짜n&quot;);
    bytes -= 6;
    read += bytes;
    switch (fileType)
    {
        case 0:
            sequence-&gt;nTracks = 1;
            __SEQInitTracks (sequence, read, 1);
            break;
        case 1:
            ASSERTMSGLINE (0x1AD,
                           sequence-&gt;nTracks &lt; 0x40,
                           &quot;exceeded SEQ_MAX_TRACKS, please increase SEQ_MAX_TRACKS짜n&quot;);
            __SEQInitTracks (sequence, read, sequence-&gt;nTracks);
            break;
        default:
            ASSERTMSGLINE (0x1B5, 0, &quot;!!!Invalid MIDI file type짜n!!!&quot;);
            break;
    }
    sequence-&gt;tracksRunning = sequence-&gt;nTracks;
}

void
SEQInit (void)
{
    __SEQSequenceList = NULL;
}

void
SEQQuit (void)
{
    __SEQSequenceList = NULL;
}

void
SEQRunAudioFrame (void)
{
    SEQSEQUENCE* sequence;
    u32          i;
    SEQTRACK*    track;
    u32          ticks;

    for (sequence = __SEQSequenceList; sequence; sequence = sequence-&gt;next)
    {
        if ((sequence-&gt;state == 1) || (sequence-&gt;state == 2))
        {
            for (i = 0; i &lt; sequence-&gt;nTracks; i++)
            {
                track = &amp;sequence-&gt;track[i];
                if ((track-&gt;state == 1) || (track-&gt;state == 2))
                {
                    ticks = track-&gt;ticksPerFrame;
                    if (track-&gt;delay &gt; ticks)
                    {
                        track-&gt;delay -= ticks;
                    }
                    else
                    {
                        while (ticks &gt;= track-&gt;delay)
                        {
                            ticks -= track-&gt;delay;
                            __SEQRunEvent (&amp;sequence-&gt;synth, track);
                            if (track-&gt;state != 0U)
                            {
                                track-&gt;delay = __SEQGetIntTrack (track) &lt;&lt; 0x10;
                            }
                            else
                            {
                                break;
                            }
                        }
                        track-&gt;delay -= ticks;
                    }
                }
            }
        }
        if (sequence-&gt;end != 0U)
        {
            if (sequence-&gt;state == 2U)
            {
                SEQSetState (sequence, 0);
                SEQSetState (sequence, 2);
            }
            else
            {
                SEQSetState (sequence, 0);
            }
        }
    }
}

void
SEQAddSequence (SEQSEQUENCE* sequence,
                u32*         midiStream,
                void*        wt,
                u32          aramBase,
                u32          priorityVoiceAlloc,
                u32          priorityNoteOn,
                u32          priorityNoteRelease)
{
    int i;

    ASSERTLINE (0x225, sequence);
    ASSERTLINE (0x226, midiStream);
    ASSERTLINE (0x227, wt);
    ASSERTLINE (0x228, aramBase);
    ASSERTLINE (0x229, (priorityVoiceAlloc &lt; 32) &amp;&amp; (priorityVoiceAlloc &gt; 0));
    ASSERTLINE (0x22A, (priorityNoteOn &lt; 32) &amp;&amp; (priorityNoteOn &gt; 0));
    ASSERTLINE (0x22B, (priorityNoteRelease &lt; 32) &amp;&amp; (priorityNoteRelease &gt; 0));
    SYNInitSynth (&amp;sequence-&gt;synth,
                  wt,
                  aramBase,
                  priorityVoiceAlloc,
                  priorityNoteOn,
                  priorityNoteRelease);
    sequence-&gt;state = 0;
    for (i = 0; i &lt; 0x80; i++)
    {
        sequence-&gt;callback[i] = 0;
    }
    __SEQReadHeader (sequence, (u8*)midiStream);
    __SEQPushSequenceList (sequence);
}

void
SEQRemoveSequence (SEQSEQUENCE* sequence)
{
    ASSERTLINE (0x24B, sequence);
    __SEQRemoveSequenceFromList (sequence);
    SYNQuitSynth (&amp;sequence-&gt;synth);
}

void
SEQRegisterControllerCallback (SEQSEQUENCE* sequence, u8 controller, void (*callback) (void*, u16))
{
    ASSERTLINE (0x25E, sequence);
    ASSERTLINE (0x25F, controller &lt; 128);
    ASSERTLINE (0x260, callback);
    sequence-&gt;callback[controller] = callback;
}

void
SEQSetState (SEQSEQUENCE* sequence, u32 state)
{
    int i;

    ASSERTLINE (0x26D, sequence);

    switch (state)
    {
        case 1:
        case 2:
            if (sequence-&gt;state == 0)
            {
                int old;

                old = OSDisableInterrupts();
                for (i = 0; i &lt; sequence-&gt;nTracks; i++)
                {
                    SEQTRACK* track = &amp;sequence-&gt;track[i];
                    track-&gt;current = track-&gt;start;
                    track-&gt;ticksPerFrame = track-&gt;defaultTicksPerFrame;
                    track-&gt;delay = __SEQGetIntTrack (track) &lt;&lt; 0x10;
                    track-&gt;state = 1;
                }
                sequence-&gt;tracksRunning = sequence-&gt;nTracks;
                OSRestoreInterrupts (old);
            }
            sequence-&gt;end = 0;
            break;
        case 0:
        case 3:
            {
                int old;
                u8  ch[3];

                for (i = 0; i &lt; 16; i++)
                {
                    old = OSDisableInterrupts();
                    ch[0] = (i | 0xB0);
                    ch[1] = 0x7B;
                    ch[2] = 0;
                    SYNMidiInput (&amp;sequence-&gt;synth, ch);
                    OSRestoreInterrupts (old);
                }
                break;
            }
    }
    sequence-&gt;state = state;
}

u32
SEQGetState (SEQSEQUENCE* sequence)
{
    ASSERTLINE (0x2B1, sequence);
    return sequence-&gt;state;
}

void
SEQSetTempo (SEQSEQUENCE* sequence, u32 trackIndex, float bpm)
{
    int i;

    ASSERTLINE (0x2BC, sequence);
    ASSERTLINE (0x2BD, (trackIndex &lt; sequence-&gt;nTracks) || (trackIndex == SEQ_ALL_TRACKS));
    if (trackIndex == -1)
    {
        for (i = 0; i &lt; sequence-&gt;nTracks; i++)
        {
            __SEQSetTicksPerFrame (&amp;sequence-&gt;track[i], bpm / 60.0f);
        }
        return;
    }
    __SEQSetTicksPerFrame (&amp;sequence-&gt;track[trackIndex], bpm / 60.0f);
}

f32
SEQGetTempo (SEQSEQUENCE* sequence, u32 trackIndex)
{
    ASSERTLINE (0x2D2, sequence);
    ASSERTLINE (0x2D3, trackIndex &lt; sequence-&gt;nTracks);
    return 60.0f * sequence-&gt;track[trackIndex].beatsPerSec;
}

void
SEQSetVolume (SEQSEQUENCE* sequence, s32 dB)
{
    ASSERTLINE (0x2DE, sequence);
    SYNSetMasterVolume (&amp;sequence-&gt;synth, dB);
}

s32
SEQGetVolume (SEQSEQUENCE* sequence)
{
    ASSERTLINE (0x2E9, sequence);
    SYNGetMasterVolume (&amp;sequence-&gt;synth);
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>