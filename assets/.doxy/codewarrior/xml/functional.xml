<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="functional" kind="file" language="C++">
    <compoundname>functional</compoundname>
    <includedby refid="functional_8h" local="no">functional.h</includedby>
    <includedby refid="hashmmap_8h" local="no">hashmmap.h</includedby>
    <invincdepgraph>
      <node id="1">
        <label>functional</label>
        <link refid="functional"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>functional.h</label>
        <link refid="functional_8h"/>
      </node>
      <node id="3">
        <label>hashmmap.h</label>
        <link refid="hashmmap_8h"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*<sp/><sp/>Metrowerks<sp/>Standard<sp/>Library<sp/><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*<sp/><sp/>$Date:<sp/>1999/12/09<sp/>17:58:49<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>$Revision:<sp/>1.12.4.1<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>$NoKeywords:<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>Portions<sp/>Copyright<sp/>1995-1999<sp/>Metrowerks,<sp/>Inc.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>**<sp/><sp/>functional</highlight></codeline>
<codeline><highlight class="normal"><sp/>**/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_FUNCTIONAL</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>_FUNCTIONAL</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mslconfig&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>RC_INVOKED</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#pragma<sp/>options<sp/>align=native</highlight></codeline>
<codeline><highlight class="normal">#if<sp/>defined(__CFM68K__)<sp/>&amp;&amp;<sp/>!defined(__USING_STATIC_LIBS__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#pragma<sp/>import<sp/>on</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_CPP_NAMESPACE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>namespace<sp/>std<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>lib.base,<sp/>base:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>unary_function</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Arg<sp/><sp/><sp/><sp/>argument_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Result<sp/>result_type;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg1,<sp/>class<sp/>Arg2,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>binary_function</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Arg1<sp/><sp/><sp/>first_argument_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Arg2<sp/><sp/><sp/>second_argument_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Result<sp/>result_type;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>lib.arithmetic.operations,<sp/>arithmetic<sp/>operations:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>plus</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>plus</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">T</highlight></codeline>
<codeline><highlight class="normal">plus&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>x<sp/>+<sp/>y;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>minus</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>minus</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">T</highlight></codeline>
<codeline><highlight class="normal">minus&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>x<sp/>-<sp/>y;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>multiplies</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>multiplies</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">T</highlight></codeline>
<codeline><highlight class="normal">multiplies&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>x<sp/>*<sp/>y;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>divides</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>divides</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">T</highlight></codeline>
<codeline><highlight class="normal">divides&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>x<sp/>/<sp/>y;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>modulus</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>modulus</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">T</highlight></codeline>
<codeline><highlight class="normal">modulus&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>x<sp/>%<sp/>y;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>negate</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>negate</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>unary_function&lt;T,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>operator()(const<sp/>T&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">T</highlight></codeline>
<codeline><highlight class="normal">negate&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>-x;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>lib.comparisons,<sp/>comparisons:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>equal_to</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>equal_to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">equal_to&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x<sp/>==<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>not_equal_to</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>not_equal_to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">not_equal_to&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x<sp/>!=<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>greater</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>greater</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">greater&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x<sp/>&gt;<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>less</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>less</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">less&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x<sp/>&lt;<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>greater_equal</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>greater_equal</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">greater_equal&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x<sp/>&gt;=<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>less_equal</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>less_equal</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">less_equal&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x<sp/>&lt;=<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>lib.logical.operations,<sp/>logical<sp/>operations:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>logical_and</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>logical_and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">logical_and&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x<sp/>&amp;&amp;<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>logical_or</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>logical_or</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>binary_function&lt;T,<sp/>T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">logical_or&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x,<sp/>const<sp/>T&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x<sp/>||<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>logical_not</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>logical_not</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>unary_function&lt;T,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>T&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">logical_not&lt;T&gt;::operator()(const<sp/>T&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>lib.negators,<sp/>negators:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>unary_negate</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>unary_negate</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>unary_function&lt;typename<sp/>Predicate::argument_type,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>unary_negate(const<sp/>Predicate&amp;<sp/>pred);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>typename<sp/>Predicate::argument_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Predicate<sp/>pred_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">unary_negate&lt;Predicate&gt;::unary_negate(const<sp/>Predicate&amp;<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>pred_(pred)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">unary_negate&lt;Predicate&gt;::operator()(const<sp/>typename<sp/>Predicate::argument_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!pred_(x));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">unary_negate&lt;Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">not1(const<sp/>Predicate&amp;<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>unary_negate&lt;Predicate&gt;(pred);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>binary_negate</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>binary_negate</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>binary_function&lt;typename<sp/>Predicate::first_argument_type,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>Predicate::second_argument_type,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>binary_negate(const<sp/>Predicate&amp;<sp/>pred);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>operator()(const<sp/>typename<sp/>Predicate::first_argument_type&amp;<sp/><sp/>x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>typename<sp/>Predicate::second_argument_type&amp;<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Predicate<sp/>pred_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">binary_negate&lt;Predicate&gt;::binary_negate(const<sp/>Predicate&amp;<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>pred_(pred)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">binary_negate&lt;Predicate&gt;::operator()(const<sp/>typename<sp/>Predicate::first_argument_type&amp;<sp/><sp/>x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>typename<sp/>Predicate::second_argument_type&amp;<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!pred_(x,<sp/>y));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">binary_negate&lt;Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal">not2(const<sp/>Predicate&amp;<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>binary_negate&lt;Predicate&gt;(pred);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>lib.binders,<sp/>binders:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>binder1st</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Operation&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>binder1st</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>unary_function&lt;typename<sp/>Operation::second_argument_type,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>Operation::result_type&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binder1st(const<sp/>Operation&amp;<sp/>x,<sp/>const<sp/>typename<sp/>Operation::first_argument_type&amp;<sp/>y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>Operation::result_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator()(const<sp/>typename<sp/>Operation::second_argument_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Operation<sp/>op;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>Operation::first_argument_type<sp/>value;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Operation&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">binder1st&lt;Operation&gt;::binder1st(const<sp/>Operation&amp;<sp/>x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>typename<sp/>Operation::first_argument_type&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>op(x),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>value(y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Operation&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>Operation::result_type</highlight></codeline>
<codeline><highlight class="normal">binder1st&lt;Operation&gt;::operator()(const<sp/>typename<sp/>Operation::second_argument_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>op(value,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#if<sp/>!defined(__MWERKS__)<sp/>||<sp/>(defined(__MWERKS__)<sp/>&amp;&amp;<sp/>__MWERKS__<sp/>&gt;<sp/>0x2400)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Operation,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binder1st&lt;Operation&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bind1st(const<sp/>Operation&amp;<sp/>op,<sp/>const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>binder1st&lt;Operation&gt;(op,<sp/>typename<sp/>Operation::first_argument_type(x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Operation,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binder1st&lt;Operation&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bind1st(const<sp/>Operation&amp;<sp/>op,<sp/>const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>binder1st&lt;Operation&gt;(op,<sp/>Operation::first_argument_type(x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>binder2nd</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Operation&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>binder2nd</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>unary_function&lt;typename<sp/>Operation::first_argument_type,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>Operation::result_type&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binder2nd(const<sp/>Operation&amp;<sp/>x,<sp/>const<sp/>typename<sp/>Operation::second_argument_type&amp;<sp/>y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>Operation::result_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator()(const<sp/>typename<sp/>Operation::first_argument_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Operation<sp/>op;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>Operation::second_argument_type<sp/>value;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Operation&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">binder2nd&lt;Operation&gt;::binder2nd(const<sp/>Operation&amp;<sp/>x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>typename<sp/>Operation::second_argument_type&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>op(x),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>value(y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Operation&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>Operation::result_type</highlight></codeline>
<codeline><highlight class="normal">binder2nd&lt;Operation&gt;::operator()(const<sp/>typename<sp/>Operation::first_argument_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>op(x,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#if<sp/>!defined(__MWERKS__)<sp/>||<sp/>(defined(__MWERKS__)<sp/>&amp;&amp;<sp/>__MWERKS__<sp/>&gt;<sp/>0x2400)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Operation,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binder2nd&lt;Operation&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bind2nd(const<sp/>Operation&amp;<sp/>op,<sp/>const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>binder2nd&lt;Operation&gt;(op,<sp/>typename<sp/>Operation::second_argument_type(x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Operation,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>binder2nd&lt;Operation&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bind2nd(const<sp/>Operation&amp;<sp/>op,<sp/>const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>binder2nd&lt;Operation&gt;(op,<sp/>Operation::second_argument_type(x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>lib.function.pointer.adaptors,<sp/>adaptors:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>pointer_to_unary_function</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>pointer_to_unary_function</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>unary_function&lt;Arg,<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>pointer_to_unary_function(Result<sp/>(*f)(Arg));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Result<sp/>operator()(Arg<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Result<sp/>(*f_)(Arg);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">pointer_to_unary_function&lt;Arg,<sp/>Result&gt;::pointer_to_unary_function(Result<sp/>(*f)(Arg))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>f_(f)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">Result</highlight></codeline>
<codeline><highlight class="normal">pointer_to_unary_function&lt;Arg,<sp/>Result&gt;::operator()(Arg<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>f_(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">pointer_to_unary_function&lt;Arg,<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">ptr_fun(Result<sp/>(*f)(Arg))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>pointer_to_unary_function&lt;Arg,<sp/>Result&gt;(f);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>pointer_to_binary_function</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg1,<sp/>class<sp/>Arg2,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>pointer_to_binary_function</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>binary_function&lt;Arg1,<sp/>Arg2,<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>pointer_to_binary_function(Result<sp/>(*f)(Arg1,<sp/>Arg2));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Result<sp/>operator()(Arg1<sp/>x,<sp/>Arg2<sp/>y)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Result<sp/>(*f_)(Arg1,<sp/>Arg2);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg1,<sp/>class<sp/>Arg2,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">pointer_to_binary_function&lt;Arg1,<sp/>Arg2,<sp/>Result&gt;::pointer_to_binary_function(Result<sp/>(*f)(Arg1,<sp/>Arg2))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>f_(f)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg1,<sp/>class<sp/>Arg2,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">Result</highlight></codeline>
<codeline><highlight class="normal">pointer_to_binary_function&lt;Arg1,<sp/>Arg2,<sp/>Result&gt;::operator()(Arg1<sp/>x,<sp/>Arg2<sp/>y)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>f_(x,<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Arg1,<sp/>class<sp/>Arg2,<sp/>class<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">pointer_to_binary_function&lt;Arg1,<sp/>Arg2,<sp/>Result&gt;</highlight></codeline>
<codeline><highlight class="normal">ptr_fun(Result<sp/>(*f)(Arg1,<sp/>Arg2))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>pointer_to_binary_function&lt;Arg1,<sp/>Arg2,<sp/>Result&gt;(f);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>lib.member.pointer.adaptors,<sp/>adaptors:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>mem_fun_t</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>mem_fun_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>unary_function&lt;T*,<sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>mem_fun_t(S<sp/>(T::*mf)());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S<sp/>operator()(T*<sp/>p)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S<sp/>(T::*mf_)();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">mem_fun_t&lt;S,<sp/>T&gt;::mem_fun_t(S<sp/>(T::*mf)())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>mf_(mf)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">S</highlight></codeline>
<codeline><highlight class="normal">mem_fun_t&lt;S,<sp/>T&gt;::operator()(T*<sp/>p)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(p-&gt;*mf_)();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>mem_fun1_t</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>mem_fun1_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>binary_function&lt;T*,<sp/>A,<sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>mem_fun1_t(S<sp/>(T::*mf)(A));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S<sp/>operator()(T*<sp/>p,<sp/>A<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S<sp/>(T::*mf_)(A);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">mem_fun1_t&lt;S,<sp/>T,<sp/>A&gt;::mem_fun1_t(S<sp/>(T::*mf)(A))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>mf_(mf)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">S</highlight></codeline>
<codeline><highlight class="normal">mem_fun1_t&lt;S,<sp/>T,<sp/>A&gt;::operator()(T*<sp/>p,<sp/>A<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(p-&gt;*mf_)(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>mem_fun</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">mem_fun_t&lt;S,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">mem_fun(S<sp/>(T::*f)())</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>mem_fun_t&lt;S,<sp/>T&gt;(f);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">mem_fun1_t&lt;S,<sp/>T,<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">mem_fun(S<sp/>(T::*f)(A))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>mem_fun1_t&lt;S,<sp/>T,<sp/>A&gt;(f);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>mem_fun_ref_t</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>mem_fun_ref_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>unary_function&lt;T,<sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>mem_fun_ref_t(S<sp/>(T::*mf)());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S<sp/>operator()(T&amp;<sp/>p)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S<sp/>(T::*mf_)();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">mem_fun_ref_t&lt;S,<sp/>T&gt;::mem_fun_ref_t(S<sp/>(T::*mf)())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>mf_(mf)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">S</highlight></codeline>
<codeline><highlight class="normal">mem_fun_ref_t&lt;S,<sp/>T&gt;::operator()(T&amp;<sp/>p)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(p.*mf_)();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>mem_fun1_ref_t</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>mem_fun1_ref_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>public<sp/>binary_function&lt;T,<sp/>A,<sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>mem_fun1_ref_t(S<sp/>(T::*mf)(A));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S<sp/>operator()(T&amp;<sp/>p,<sp/>A<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S<sp/>(T::*mf_)(A);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">mem_fun1_ref_t&lt;S,<sp/>T,<sp/>A&gt;::mem_fun1_ref_t(S<sp/>(T::*mf)(A))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>mf_(mf)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">S</highlight></codeline>
<codeline><highlight class="normal">mem_fun1_ref_t&lt;S,<sp/>T,<sp/>A&gt;::operator()(T&amp;<sp/>p,<sp/>A<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(p.*mf_)(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>mem_fun_ref</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">mem_fun_ref_t&lt;S,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">mem_fun_ref(S<sp/>(T::*f)())</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>mem_fun_ref_t&lt;S,<sp/>T&gt;(f);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">mem_fun1_ref_t&lt;S,<sp/>T,<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal">mem_fun_ref(S<sp/>(T::*f)(A))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>mem_fun1_ref_t&lt;S,<sp/>T,<sp/>A&gt;(f);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#if<sp/>!defined(__MWERKS__)<sp/>||<sp/>(defined(__MWERKS__)<sp/>&amp;&amp;<sp/>__MWERKS__<sp/>&gt;<sp/>0x2400)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>const_mem_fun_t</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>const_mem_fun_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>unary_function&lt;T*,<sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>const_mem_fun_t(S<sp/>(T::*mf)()<sp/>const);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/>operator()(const<sp/>T*<sp/>p)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/>(T::*mf_)()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun_t&lt;S,<sp/>T&gt;::const_mem_fun_t(S<sp/>(T::*mf)()<sp/>const)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>mf_(mf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun_t&lt;S,<sp/>T&gt;::operator()(const<sp/>T*<sp/>p)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(p-&gt;*mf_)();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>const_mem_fun1_t</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>const_mem_fun1_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>binary_function&lt;T*,<sp/>A,<sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>const_mem_fun1_t(S<sp/>(T::*mf)(A)<sp/>const);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/>operator()(const<sp/>T*<sp/>p,<sp/>A<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/>(T::*mf_)(A)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun1_t&lt;S,<sp/>T,<sp/>A&gt;::const_mem_fun1_t(S<sp/>(T::*mf)(A)<sp/>const)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>mf_(mf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun1_t&lt;S,<sp/>T,<sp/>A&gt;::operator()(const<sp/>T*<sp/>p,<sp/>A<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(p-&gt;*mf_)(x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>mem_fun</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun_t&lt;S,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mem_fun(S<sp/>(T::*f)()<sp/>const)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_mem_fun_t&lt;S,<sp/>T&gt;(f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun1_t&lt;S,<sp/>T,<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mem_fun(S<sp/>(T::*f)(A)<sp/>const)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_mem_fun1_t&lt;S,<sp/>T,<sp/>A&gt;(f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>const_mem_fun_ref_t</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>const_mem_fun_ref_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>unary_function&lt;T,<sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>const_mem_fun_ref_t(S<sp/>(T::*mf)()<sp/>const);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/>operator()(const<sp/>T&amp;<sp/>p)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/>(T::*mf_)()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun_ref_t&lt;S,<sp/>T&gt;::const_mem_fun_ref_t(S<sp/>(T::*mf)()<sp/>const)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>mf_(mf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun_ref_t&lt;S,<sp/>T&gt;::operator()(const<sp/>T&amp;<sp/>p)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(p.*mf_)();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>const_mem_fun1_ref_t</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>const_mem_fun1_ref_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>binary_function&lt;T,<sp/>A,<sp/>S&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>const_mem_fun1_ref_t(S<sp/>(T::*mf)(A)<sp/>const);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/>operator()(const<sp/>T&amp;<sp/>p,<sp/>A<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun1_ref_t&lt;S,<sp/>T,<sp/>A&gt;::const_mem_fun1_ref_t(S<sp/>(T::*mf)(A)<sp/>const)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>mf_(mf)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>S</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun1_ref_t&lt;S,<sp/>T,<sp/>A&gt;::operator()(const<sp/>T&amp;<sp/>p,<sp/>A<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(p.*mf_)(x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>mem_fun_ref</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun_ref_t&lt;S,<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mem_fun_ref(S<sp/>(T::*f)()<sp/>const)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_mem_fun_ref_t&lt;S,<sp/>T&gt;(f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>S,<sp/>class<sp/>T,<sp/>class<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_mem_fun1_ref_t&lt;S,<sp/>T,<sp/>A&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mem_fun_ref(S<sp/>(T::*f)(A)<sp/>const)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_mem_fun1_ref_t&lt;S,<sp/>T,<sp/>A&gt;(f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_CPP_NAMESPACE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>//<sp/>namespace<sp/>std<sp/></highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#if<sp/>defined(__CFM68K__)<sp/>&amp;&amp;<sp/>!defined(__USING_STATIC_LIBS__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#pragma<sp/>import<sp/>reset</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>options<sp/>align=reset</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>RC_INVOKED</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_FUNCTIONAL</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>971221<sp/>Changed<sp/>filename<sp/>from<sp/>functional.h<sp/>to<sp/>functional</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>971221<sp/>Made<sp/>include<sp/>guards<sp/>standard</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>971230<sp/>added<sp/>RC_INVOKED<sp/>wrapper</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>980401<sp/>rewrote<sp/>all<sp/>mem_fun<sp/>stuff</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>980731<sp/>added<sp/>select2nd<sp/>per<sp/>customer<sp/>request</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>980923<sp/>Put<sp/>in<sp/>a<sp/>few<sp/>typename<sp/>fixes</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990505<sp/>Rewrote</highlight></codeline>
    </programlisting>
    <location file="decomp/CodeWarrior/PowerPC_EABI_Support/Msl/MSL_C++/MSL_Common/Include/functional"/>
  </compounddef>
</doxygen>
