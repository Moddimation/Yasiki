<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="set" kind="file" language="C++">
    <compoundname>set</compoundname>
    <includedby refid="set_8h" local="no">set.h</includedby>
    <invincdepgraph>
      <node id="1">
        <label>set</label>
        <link refid="set"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>set.h</label>
        <link refid="set_8h"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*<sp/><sp/>Metrowerks<sp/>Standard<sp/>Library<sp/><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*<sp/><sp/>$Date:<sp/>1999/12/09<sp/>17:59:45<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>$Revision:<sp/>1.10.2.1<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>$NoKeywords:<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>Portions<sp/>Copyright<sp/>1995-1999<sp/>Metrowerks,<sp/>Inc.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>**<sp/><sp/>set<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>hh<sp/>971223<sp/>Changed<sp/>filename<sp/>from<sp/>set.h<sp/>to<sp/>set</highlight></codeline>
<codeline><highlight class="normal"><sp/>**/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_SET</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>_SET</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mslconfig&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;tree.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;functional&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>RC_INVOKED</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#pragma<sp/>options<sp/>align=native</highlight></codeline>
<codeline><highlight class="normal">#if<sp/>defined(__CFM68K__)<sp/>&amp;&amp;<sp/>!defined(__USING_STATIC_LIBS__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#pragma<sp/>import<sp/>on</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_CPP_NAMESPACE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>namespace<sp/>std<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>set</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare<sp/>=<sp/>less&lt;Key&gt;,<sp/>class<sp/>Allocator<sp/>=<sp/>allocator&lt;Key&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>set</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>types:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Key<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Key<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Compare<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_compare;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Compare<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_compare;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Allocator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_reference<sp/><sp/><sp/>const_reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::size_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::difference_type<sp/><sp/><sp/>difference_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::pointer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_pointer<sp/><sp/><sp/><sp/><sp/>const_pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>_STD::reverse_iterator&lt;iterator&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>_STD::reverse_iterator&lt;const_iterator&gt;<sp/>const_reverse_iterator;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>__tree&lt;value_type,<sp/>value_compare,<sp/>allocator_type&gt;<sp/>tree_type;</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>struct<sp/>debug_view</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug_view*<sp/>left_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug_view*<sp/>right_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug_view*<sp/>parent_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;bidirectional_iterator_tag,<sp/>value_type,<sp/>difference_type,<sp/>const_pointer,<sp/>const_reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>*i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>i_.operator-&gt;();}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{++i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{iterator<sp/>tmp(*this);<sp/>++i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator<sp/>--<sp/>()<sp/>{--i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator<sp/>--<sp/>(int)<sp/>{iterator<sp/>tmp(*this);<sp/>--i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>==(const<sp/>iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>i_<sp/>==<sp/>rhs.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>==(const<sp/>const_iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>const_iterator(*this)<sp/>==<sp/>rhs;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>!=(const<sp/>iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>i_<sp/>!=<sp/>rhs.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>!=(const<sp/>const_iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/><sp/>const_iterator(*this)<sp/>!=<sp/>rhs;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_type::iterator<sp/>i_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator(const<sp/>tree_type::iterator&amp;<sp/>i)<sp/>:<sp/>i_(i)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator<sp/>tree_type::iterator()<sp/>const<sp/>{return<sp/>i_;}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>set::const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;bidirectional_iterator_tag,<sp/>value_type,<sp/>difference_type,<sp/>const_pointer,<sp/>const_reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(const<sp/>set::iterator&amp;<sp/>i)<sp/>:<sp/>i_(i)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>*i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>i_.operator-&gt;();}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{++i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{const_iterator<sp/>tmp(*this);<sp/>++i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator<sp/>--<sp/>()<sp/>{--i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator<sp/>--<sp/>(int)<sp/>{const_iterator<sp/>tmp(*this);<sp/>--i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>==(const<sp/>const_iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>i_<sp/>==<sp/>rhs.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>==(const<sp/>set::iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>*this<sp/>==<sp/>const_iterator(rhs);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>!=(const<sp/>const_iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>i_<sp/>!=<sp/>rhs.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>!=(const<sp/>set::iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>*this<sp/>!=<sp/>const_iterator(rhs);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_type::const_iterator<sp/>i_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(const<sp/>tree_type::const_iterator&amp;<sp/>i)<sp/>:<sp/>i_(i)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator<sp/>tree_type::const_iterator()<sp/>const<sp/>{return<sp/>i_;}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>set;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>set::iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.set.cons<sp/>construct/copy/destroy:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>set(const<sp/>Compare&amp;<sp/>comp<sp/>=<sp/>Compare(),<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>set(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Compare&amp;<sp/>comp<sp/>=<sp/>Compare(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>tree_(first,<sp/>last,<sp/>false,<sp/>comp,<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>set(const_iterator<sp/>first,<sp/>const_iterator<sp/>last,<sp/>const<sp/>Compare&amp;<sp/>comp<sp/>=<sp/>Compare(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>set(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last,<sp/>const<sp/>Compare&amp;<sp/>comp<sp/>=<sp/>Compare(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>allocator_type<sp/>get_allocator()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>iterators:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reverse_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>rbegin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>rbegin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reverse_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>rend();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>rend()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>capacity:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>empty()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/><sp/><sp/><sp/><sp/>size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/><sp/><sp/><sp/><sp/>max_size()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>modifiers:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pair&lt;iterator,bool&gt;<sp/>insert(const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_.insert_one(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(const_iterator<sp/>first,<sp/>const_iterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>erase(iterator<sp/>position);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>erase(const<sp/>key_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>erase(iterator<sp/>first,<sp/>iterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>swap(set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>clear();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>observers:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>key_compare<sp/><sp/><sp/>key_comp()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>value_compare<sp/>value_comp()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>set<sp/>operations:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/>find(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>count(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/>lower_bound(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/>upper_bound(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pair&lt;iterator,iterator&gt;<sp/>equal_range(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_type<sp/>tree_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>specialized<sp/>algorithms:</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">swap(set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>set&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>multiset</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare<sp/>=<sp/>less&lt;Key&gt;,<sp/>class<sp/>Allocator<sp/>=<sp/>allocator&lt;Key&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>multiset</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>types:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Key<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Key<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Compare<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key_compare;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Compare<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_compare;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Allocator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_reference<sp/><sp/><sp/>const_reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::size_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::difference_type<sp/><sp/><sp/>difference_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::pointer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_pointer<sp/><sp/><sp/><sp/><sp/>const_pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>_STD::reverse_iterator&lt;iterator&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>_STD::reverse_iterator&lt;const_iterator&gt;<sp/>const_reverse_iterator;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>__tree&lt;value_type,<sp/>value_compare,<sp/>allocator_type&gt;<sp/>tree_type;</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>struct<sp/>debug_view</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug_view*<sp/>left_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug_view*<sp/>right_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug_view*<sp/>parent_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;bidirectional_iterator_tag,<sp/>value_type,<sp/>difference_type,<sp/>const_pointer,<sp/>const_reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>*i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>i_.operator-&gt;();}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{++i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{iterator<sp/>tmp(*this);<sp/>++i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator<sp/>--<sp/>()<sp/>{--i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator<sp/>--<sp/>(int)<sp/>{iterator<sp/>tmp(*this);<sp/>--i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>==(const<sp/>iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>i_<sp/>==<sp/>rhs.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>==(const<sp/>const_iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>const_iterator(*this)<sp/>==<sp/>rhs;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>!=(const<sp/>iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>i_<sp/>!=<sp/>rhs.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>!=(const<sp/>const_iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>const_iterator(*this)<sp/>!=<sp/>rhs;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_type::iterator<sp/>i_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator(const<sp/>tree_type::iterator&amp;<sp/>i)<sp/>:<sp/>i_(i)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator<sp/>tree_type::iterator()<sp/>const<sp/>{return<sp/>i_;}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>multiset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>multiset::const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;bidirectional_iterator_tag,<sp/>value_type,<sp/>difference_type,<sp/>const_pointer,<sp/>const_reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(const<sp/>multiset::iterator&amp;<sp/>i)<sp/>:<sp/>i_(i)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>*i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>i_.operator-&gt;();}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{++i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{const_iterator<sp/>tmp(*this);<sp/>++i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator<sp/>--<sp/>()<sp/>{--i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator<sp/>--<sp/>(int)<sp/>{const_iterator<sp/>tmp(*this);<sp/>--i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>==(const<sp/>const_iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>i_<sp/>==<sp/>rhs.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>==(const<sp/>multiset::iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>*this<sp/>==<sp/>const_iterator(rhs);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>!=(const<sp/>const_iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>i_<sp/>!=<sp/>rhs.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator<sp/>!=(const<sp/>multiset::iterator&amp;<sp/>rhs)<sp/>const<sp/>{return<sp/>*this<sp/>!=<sp/>const_iterator(rhs);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_type::const_iterator<sp/>i_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(const<sp/>tree_type::const_iterator&amp;<sp/>i)<sp/>:<sp/>i_(i)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator<sp/>tree_type::const_iterator()<sp/>const<sp/>{return<sp/>i_;}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>multiset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>construct/copy/destroy:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>multiset(const<sp/>Compare&amp;<sp/>comp<sp/>=<sp/>Compare(),<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>multiset(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Compare&amp;<sp/>comp<sp/>=<sp/>Compare(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>tree_(first,<sp/>last,<sp/>true,<sp/>comp,<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>multiset(const_iterator<sp/>first,<sp/>const_iterator<sp/>last,<sp/>const<sp/>Compare&amp;<sp/>comp<sp/>=<sp/>Compare(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>multiset(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last,<sp/>const<sp/>Compare&amp;<sp/>comp<sp/>=<sp/>Compare(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>allocator_type<sp/>get_allocator()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>iterators:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reverse_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>rbegin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>rbegin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reverse_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>rend();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>rend()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>capacity:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>empty()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/><sp/><sp/><sp/><sp/>size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/><sp/><sp/><sp/><sp/>max_size()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>modifiers:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>insert(const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>insert(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_.insert_multi(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(const_iterator<sp/>first,<sp/>const_iterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>erase(iterator<sp/>position);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>erase(const<sp/>key_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>erase(iterator<sp/>first,<sp/>iterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>swap(multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>clear();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>observers:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>key_compare<sp/><sp/><sp/>key_comp()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>value_compare<sp/>value_comp()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>set<sp/>operations:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/>find(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>count(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/>lower_bound(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/>upper_bound(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pair&lt;iterator,iterator&gt;<sp/>equal_range(const<sp/>key_type&amp;<sp/>x)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_type<sp/>tree_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/>specialized<sp/>algorithms:</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">swap(multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x,<sp/>multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>set<sp/>implementation</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::set(const<sp/>Compare&amp;<sp/>comp,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>tree_(comp,<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::set(const_iterator<sp/>first,<sp/>const_iterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Compare&amp;<sp/>comp,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>tree_(first,<sp/>last,<sp/>false,<sp/>comp,<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::set(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Compare&amp;<sp/>comp,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>tree_(first,<sp/>last,<sp/>false,<sp/>comp,<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::allocator_type</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::get_allocator()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.get_allocator();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::begin()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.begin();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::begin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.begin();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::end()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.end();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::end()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.end();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::rbegin()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>reverse_iterator(end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::const_reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::rbegin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_reverse_iterator(end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::rend()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>reverse_iterator(begin());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::const_reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::rend()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_reverse_iterator(begin());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::empty()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.empty();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.size();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::max_size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.max_size();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">pair&lt;set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator,<sp/>bool&gt;</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::insert(const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pair&lt;tree_type::iterator,<sp/>bool&gt;<sp/>result<sp/>=<sp/>tree_.insert_one(x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>pair&lt;iterator,<sp/>bool&gt;(result.first,<sp/>result.second);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.insert_one(position,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::insert(const_iterator<sp/>first,<sp/>const_iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_.insert_one(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::insert(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_.insert_one(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::erase(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_.erase(position);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::erase(const<sp/>key_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.erase_one(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::erase(iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_.erase(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::swap(set&lt;Key,Compare,Allocator&gt;&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_.swap(x.tree_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::clear()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_.clear();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::key_compare</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::key_comp()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.value_comp();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::value_compare</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::value_comp()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.value_comp();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::find(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_cast&lt;tree_type&amp;&gt;(tree_).find(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::count(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.count_one(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::lower_bound(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_cast&lt;tree_type&amp;&gt;(tree_).lower_bound(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::upper_bound(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_cast&lt;tree_type&amp;&gt;(tree_).upper_bound(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">pair&lt;set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator,<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator&gt;</highlight></codeline>
<codeline><highlight class="normal">set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::equal_range(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pair&lt;tree_type::iterator,<sp/>tree_type::iterator&gt;<sp/>result<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_cast&lt;tree_type&amp;&gt;(tree_).equal_range(x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>pair&lt;iterator,<sp/>iterator&gt;(result.first,<sp/>result.second);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>x.size()<sp/>==<sp/>y.size()<sp/>&amp;&amp;<sp/>equal(x.begin(),<sp/>x.end(),<sp/>y.begin());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>!(x<sp/>==<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lexicographical_compare(x.begin(),<sp/>x.end(),<sp/>y.begin(),<sp/>y.end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>y<sp/>&lt;<sp/>x;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>!(x<sp/>&lt;<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>!(y<sp/>&lt;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">swap(set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>set&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>x.swap(y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>multiset<sp/>implementation</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::multiset(const<sp/>Compare&amp;<sp/>comp,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>tree_(comp,<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::multiset(const_iterator<sp/>first,<sp/>const_iterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Compare&amp;<sp/>comp,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>tree_(first,<sp/>last,<sp/>true,<sp/>comp,<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::multiset(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Compare&amp;<sp/>comp,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>tree_(first,<sp/>last,<sp/>true,<sp/>comp,<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::allocator_type</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::get_allocator()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.get_allocator();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::begin()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.begin();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::begin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.begin();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::end()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.end();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::end()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.end();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::rbegin()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>reverse_iterator(end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::const_reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::rbegin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_reverse_iterator(end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::rend()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>reverse_iterator(begin());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::const_reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::rend()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_reverse_iterator(begin());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::empty()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.empty();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.size();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::max_size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.max_size();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::insert(const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.insert_multi(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.insert_multi(position,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::insert(const_iterator<sp/>first,<sp/>const_iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_.insert_multi(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::insert(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tree_.insert_multi(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::erase(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_.erase(position);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::erase(const<sp/>key_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.erase_multi(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::erase(iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_.erase(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::swap(multiset&lt;Key,Compare,Allocator&gt;&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_.swap(x.tree_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::clear()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tree_.clear();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::key_compare</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::key_comp()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.value_comp();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::value_compare</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::value_comp()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.value_comp();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::find(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_cast&lt;tree_type&amp;&gt;(tree_).find(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::count(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>tree_.count_multi(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::lower_bound(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_cast&lt;tree_type&amp;&gt;(tree_).lower_bound(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::upper_bound(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_cast&lt;tree_type&amp;&gt;(tree_).upper_bound(x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">pair&lt;multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator,<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::iterator&gt;</highlight></codeline>
<codeline><highlight class="normal">multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;::equal_range(const<sp/>key_type&amp;<sp/>x)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pair&lt;tree_type::iterator,<sp/>tree_type::iterator&gt;<sp/>result<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_cast&lt;tree_type&amp;&gt;(tree_).equal_range(x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>pair&lt;iterator,<sp/>iterator&gt;(result.first,<sp/>result.second);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>x.size()<sp/>==<sp/>y.size()<sp/>&amp;&amp;<sp/>equal(x.begin(),<sp/>x.end(),<sp/>y.begin());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>!(x<sp/>==<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lexicographical_compare(x.begin(),<sp/>x.end(),<sp/>y.begin(),<sp/>y.end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>y<sp/>&lt;<sp/>x;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>!(x<sp/>&lt;<sp/>y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>!(y<sp/>&lt;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>Key,<sp/>class<sp/>Compare,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">swap(multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>multiset&lt;Key,<sp/>Compare,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>x.swap(y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_CPP_NAMESPACE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>//<sp/>namespace<sp/>std</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#if<sp/>defined(__CFM68K__)<sp/>&amp;&amp;<sp/>!defined(__USING_STATIC_LIBS__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#pragma<sp/>import<sp/>reset</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>options<sp/>align=reset</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>RC_INVOKED</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_SET</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>971220<sp/>fixed<sp/>MOD_INCLUDE</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>971223<sp/>Changed<sp/>filename<sp/>from<sp/>set.h<sp/>to<sp/>set</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>971223<sp/>Made<sp/>include<sp/>guards<sp/>standard</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>971223<sp/>added<sp/>alignment<sp/>wrapper</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>971230<sp/>added<sp/>RC_INVOKED<sp/>wrapper</highlight></codeline>
<codeline><highlight class="normal">//<sp/>DWA<sp/>980305<sp/>changed<sp/>iterator<sp/>to<sp/>const_iterator<sp/>in<sp/>multiset<sp/>constructor,<sp/>hh<sp/>980311<sp/>checked</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>981130<sp/>Rewrote</highlight></codeline>
    </programlisting>
    <location file="decomp/CodeWarrior/PowerPC_EABI_Support/Msl/MSL_C++/MSL_Common/Include/set"/>
  </compounddef>
</doxygen>
