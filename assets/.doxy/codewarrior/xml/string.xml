<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="string" kind="file" language="C++">
    <compoundname>string</compoundname>
    <includedby refid="_m_s_lstring_8cpp" local="no">MSLstring.cpp</includedby>
    <includedby refid="tree_8h" local="no">tree.h</includedby>
    <invincdepgraph>
      <node id="1">
        <label>string</label>
        <link refid="string"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>tree.h</label>
        <link refid="tree_8h"/>
      </node>
      <node id="2">
        <label>MSLstring.cpp</label>
        <link refid="_m_s_lstring_8cpp"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*<sp/><sp/>Metrowerks<sp/>Standard<sp/>Library<sp/><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*<sp/><sp/>$Date:<sp/>1999/12/09<sp/>17:59:46<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>$Revision:<sp/>1.20.4.1<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>$NoKeywords:<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>Portions<sp/>Copyright<sp/>1995-1999<sp/>Metrowerks,<sp/>Inc.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>**<sp/><sp/>string</highlight></codeline>
<codeline><highlight class="normal"><sp/>**/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_STRING</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mslconfig&gt;</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_WCHART</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#include<sp/>&lt;cwchar&gt;</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#include<sp/>&lt;cstdio&gt;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cstring&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;iosfwd&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;memory&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdexcept&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;iterator&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;algorithm&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;limits&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mutex.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>RC_INVOKED</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#pragma<sp/>options<sp/>align=native</highlight></codeline>
<codeline><highlight class="normal">#if<sp/>defined(__CFM68K__)<sp/>&amp;&amp;<sp/>!defined(__USING_STATIC_LIBS__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#pragma<sp/>import<sp/>on</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_CPP_NAMESPACE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>namespace<sp/>std<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>ios_base;</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;<sp/>class<sp/>ctype;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>_lib.char.traits_,<sp/>character<sp/>traits:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>char_traits</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>charT<sp/><sp/><sp/><sp/><sp/><sp/><sp/>char_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>int<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>streamoff<sp/><sp/><sp/>off_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>streampos<sp/><sp/><sp/>pos_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>mbstate_t<sp/><sp/><sp/>state_type;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>void<sp/>assign(char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>eq(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>lt(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>int<sp/>compare(const<sp/>char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>size_t<sp/>length(const<sp/>char_type*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>const<sp/>char_type*<sp/>find(const<sp/>char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>const<sp/>char_type&amp;<sp/>a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>move(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>copy(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>assign(char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>char_type<sp/>a);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>not_eof(const<sp/>int_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>char_type<sp/>to_char_type(const<sp/>int_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>to_int_type(const<sp/>char_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>eq_int_type(const<sp/>int_type&amp;<sp/>c1,<sp/>const<sp/>int_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>eof();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Implementation:<sp/>char_traits&lt;charT&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::assign(char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>c1<sp/>=<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::eq(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>==<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::lt(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>&lt;<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">int</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::compare(const<sp/>char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i,<sp/>++s1,<sp/>++s2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(lt(*s1,<sp/>*s2))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(lt(*s2,<sp/>*s1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">size_t</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::length(const<sp/>char_type*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>len<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(!eq(*s,<sp/>charT()))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++len;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>len;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">const<sp/>typename<sp/>char_traits&lt;charT&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::find(const<sp/>char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>const<sp/>char_type&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>char_type*<sp/>p<sp/>=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>i<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(!eq(*p,<sp/>a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>p;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>char_traits&lt;charT&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::move(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_type*<sp/>r<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(s1<sp/>&lt;<sp/>s2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(*s1++,<sp/>*s2++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(s2<sp/>&lt;<sp/>s1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s1<sp/>+=<sp/>n<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s2<sp/>+=<sp/>n<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>--i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(*s1--,<sp/>*s2--);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>r;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>char_traits&lt;charT&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::copy(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_type*<sp/>r<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(*s1++,<sp/>*s2++);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>r;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>char_traits&lt;charT&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::assign(char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>char_type<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_type*<sp/>r<sp/>=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(*s++,<sp/>a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>r;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>char_traits&lt;charT&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::not_eof(const<sp/>int_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>eq_int_type(c,<sp/>eof())<sp/>?<sp/>~eof()<sp/>:<sp/>c;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>char_traits&lt;charT&gt;::char_type</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::to_char_type(const<sp/>int_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>charT(c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>char_traits&lt;charT&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::to_int_type(const<sp/>char_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>int_type(c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::eq_int_type(const<sp/>int_type&amp;<sp/>c1,<sp/>const<sp/>int_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>==<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>charT&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>char_traits&lt;charT&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;charT&gt;::eof()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>EOF;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>char_traits&lt;char&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>char_traits&lt;char&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>char<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>char_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>int<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>streamoff<sp/><sp/><sp/>off_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>streampos<sp/><sp/><sp/>pos_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>mbstate_t<sp/><sp/><sp/>state_type;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>void<sp/>assign(char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>eq(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>lt(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>int<sp/>compare(const<sp/>char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>size_t<sp/>length(const<sp/>char_type*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>const<sp/>char_type*<sp/>find(const<sp/>char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>const<sp/>char_type&amp;<sp/>a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>move(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>copy(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>assign(char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>char_type<sp/>a);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>not_eof(const<sp/>int_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>char_type<sp/>to_char_type(const<sp/>int_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>to_int_type(const<sp/>char_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>eq_int_type(const<sp/>int_type&amp;<sp/>c1,<sp/>const<sp/>int_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>eof();</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Implementation:<sp/>char_traits&lt;char&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::assign(char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>c1<sp/>=<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::eq(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>==<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::lt(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>&lt;<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">int</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::compare(const<sp/>char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>memcmp(s1,<sp/>s2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">size_t</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::length(const<sp/>char_type*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>strlen(s);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">const<sp/>char_traits&lt;char&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::find(const<sp/>char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>const<sp/>char_type&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(const<sp/>char*)memchr(s,<sp/>to_int_type(a),<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::move(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(char*)memmove(s1,<sp/>s2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::copy(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(char*)memcpy(s1,<sp/>s2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::assign(char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>char_type<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(char*)memset(s,<sp/>to_int_type(a),<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::not_eof(const<sp/>int_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>c<sp/>==<sp/>eof()<sp/>?<sp/>~eof()<sp/>:<sp/>c;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::char_type</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::to_char_type(const<sp/>int_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(char)c;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::to_int_type(const<sp/>char_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>int_type((unsigned<sp/>char)c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::eq_int_type(const<sp/>int_type&amp;<sp/>c1,<sp/>const<sp/>int_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>==<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal">char_traits&lt;char&gt;::eof()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>EOF;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_WCHART</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>char_traits&lt;wchar_t&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>struct<sp/>char_traits&lt;wchar_t&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>wchar_t<sp/><sp/><sp/><sp/><sp/><sp/>char_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>wint_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/>int_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>streamoff<sp/><sp/><sp/><sp/>off_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>wstreampos<sp/><sp/><sp/>pos_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>mbstate_t<sp/><sp/><sp/><sp/>state_type;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>void<sp/>assign(char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>eq(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>lt(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>int<sp/>compare(const<sp/>char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>size_t<sp/>length(const<sp/>char_type*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>const<sp/>char_type*<sp/>find(const<sp/>char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>const<sp/>char_type&amp;<sp/>a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>move(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>copy(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>char_type*<sp/>assign(char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>char_type<sp/>a);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>not_eof(const<sp/>int_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>char_type<sp/>to_char_type(const<sp/>int_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>to_int_type(const<sp/>char_type&amp;<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>bool<sp/>eq_int_type(const<sp/>int_type&amp;<sp/>c1,<sp/>const<sp/>int_type&amp;<sp/>c2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>int_type<sp/>eof();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Implementation<sp/>char_traits&lt;wchar_t&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::assign(char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c1<sp/>=<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::eq(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>==<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::lt(const<sp/>char_type&amp;<sp/>c1,<sp/>const<sp/>char_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>&lt;<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::compare(const<sp/>char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>wmemcmp(s1,<sp/>s2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::length(const<sp/>char_type*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>wcslen(s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>char_traits&lt;wchar_t&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::find(const<sp/>char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>const<sp/>char_type&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(const<sp/>wchar_t*)wmemchr(s,<sp/>a,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::move(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(wchar_t*)wmemmove(s1,<sp/>s2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::copy(char_type*<sp/>s1,<sp/>const<sp/>char_type*<sp/>s2,<sp/>size_t<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(wchar_t*)wmemcpy(s1,<sp/>s2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::char_type*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::assign(char_type*<sp/>s,<sp/>size_t<sp/>n,<sp/>char_type<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(wchar_t*)wmemset(s,<sp/>a,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::not_eof(const<sp/>int_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>int_type(c<sp/>==<sp/>eof()<sp/>?<sp/>~eof()<sp/>:<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::char_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::to_char_type(const<sp/>int_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(wchar_t)c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::to_int_type(const<sp/>char_type&amp;<sp/>c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::eq_int_type(const<sp/>int_type&amp;<sp/>c1,<sp/>const<sp/>int_type&amp;<sp/>c2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>c1<sp/>==<sp/>c2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::int_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char_traits&lt;wchar_t&gt;::eof()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>WEOF;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_WCHART</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>_lib.basic.string_,<sp/>basic_string:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits<sp/>=<sp/>char_traits&lt;charT&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/>Allocator<sp/>=<sp/>allocator&lt;charT&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>basic_string</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>CharArray;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;bool<sp/>b&gt;<sp/>struct<sp/>chooser<sp/>{};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>_MSL_REBIND(CharArray)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray_allocator;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>types:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>traits::char_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Allocator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::size_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::difference_type<sp/>difference_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_reference<sp/>const_reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::pointer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_pointer<sp/><sp/><sp/>const_pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>pointer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>const_pointer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>_STD::reverse_iterator&lt;iterator&gt;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>_STD::reverse_iterator&lt;const_iterator&gt;<sp/>const_reverse_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>const<sp/>size_type<sp/>npos<sp/>=<sp/>size_type(-1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>_lib.string.cons_<sp/>construct/copy/destroy:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>basic_string(const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos<sp/>=<sp/>0,<sp/>size_type<sp/>n<sp/>=<sp/>npos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n,<sp/>const<sp/>Allocator&amp;<sp/>a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string(const<sp/>charT*<sp/>s,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string(size_type<sp/>n,<sp/>charT<sp/>c,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(CharArray_allocator(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(begin,<sp/>end,<sp/>a,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string<sp/>(const_iterator<sp/>begin,<sp/>const_iterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(begin,<sp/>end,<sp/>a,<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>~basic_string();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>operator=(const<sp/>basic_string&amp;<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>operator=(const<sp/>charT*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>operator=(charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>_lib.string.iterators_<sp/>iterators:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>begin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>end()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reverse_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>rbegin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>rbegin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reverse_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/>rend();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>rend()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>_lib.string.capacity_<sp/>capacity:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>length()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>max_size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>resize(size_type<sp/>n,<sp/>charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>resize(size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>capacity()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>reserve(size_type<sp/>res_arg<sp/>=<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>empty()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>_lib.string.access_<sp/>element<sp/>access:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reference<sp/>operator[](size_type<sp/>pos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator[](size_type<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reference<sp/>at(size_type<sp/>pos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/>at(size_type<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>_lib.string.modifiers_<sp/>modifiers:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>operator+=(const<sp/>basic_string&amp;<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>operator+=(const<sp/>charT*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>operator+=(charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>append(const<sp/>basic_string&amp;<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>append(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>append(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>append(const<sp/>charT*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>append(size_type<sp/>n,<sp/>charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>choose_append(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>append(const_iterator<sp/>first,<sp/>const_iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_append(first,<sp/>last,<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>push_back(charT<sp/>c);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>assign(const<sp/>basic_string&amp;<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>assign(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>assign(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>assign(const<sp/>charT*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>assign(size_type<sp/>n,<sp/>charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>choose_assign(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>assign(const_iterator<sp/>first,<sp/>const_iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_assign(first,<sp/>last,<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>insert(size_type<sp/>pos1,<sp/>const<sp/>basic_string&amp;<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>insert(size_type<sp/>pos1,<sp/>const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos2,<sp/>size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>insert(size_type<sp/>pos,<sp/>const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>insert(size_type<sp/>pos,<sp/>const<sp/>charT*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>insert(size_type<sp/>pos,<sp/>size_type<sp/>n,<sp/>charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>insert(iterator<sp/>p,<sp/>charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>insert(iterator<sp/>p,<sp/>size_type<sp/>n,<sp/>charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>p,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>replace(p,<sp/>p,<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>p,<sp/>const_iterator<sp/>first,<sp/>const_iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>replace(p,<sp/>p,<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>erase(size_type<sp/>pos<sp/>=<sp/>0,<sp/>size_type<sp/>n<sp/>=<sp/>npos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>erase(iterator<sp/>position);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>erase(iterator<sp/>first,<sp/>iterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(size_type<sp/>pos1,<sp/>size_type<sp/>n1,<sp/>const<sp/>basic_string&amp;<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(size_type<sp/>pos1,<sp/>size_type<sp/>n1,<sp/>const<sp/>basic_string&amp;<sp/>str,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>pos2,<sp/>size_type<sp/>n2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(size_type<sp/>pos,<sp/>size_type<sp/>n1,<sp/>const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(size_type<sp/>pos,<sp/>size_type<sp/>n1,<sp/>const<sp/>charT*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(size_type<sp/>pos,<sp/>size_type<sp/>n1,<sp/>size_type<sp/>n2,<sp/>charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>const<sp/>basic_string&amp;<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>const<sp/>charT*<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>size_type<sp/>n,<sp/>charT<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>InputIterator<sp/>j1,<sp/>InputIterator<sp/>j2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>choose_replace(size_type(i1<sp/>-<sp/>begin()),<sp/>size_type(i2<sp/>-<sp/>i1),<sp/>j1,<sp/>j2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>const_iterator<sp/>j1,<sp/>const_iterator<sp/>j2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_replace(size_type(i1<sp/>-<sp/>begin()),<sp/>size_type(i2<sp/>-<sp/>i1),<sp/>j1,<sp/>j2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>copy(charT*<sp/>s,<sp/>size_type<sp/>n,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>swap(basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>_lib.string.ops_<sp/>string<sp/>operations:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>charT*<sp/>c_str()<sp/>const;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>explicit</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>charT*<sp/>data()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>allocator_type<sp/>get_allocator()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find<sp/>(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find<sp/>(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find<sp/>(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find<sp/>(charT<sp/>c,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rfind(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rfind(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rfind(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rfind(charT<sp/>c,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_first_of(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_first_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_first_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_first_of(charT<sp/>c,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_last_of(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_last_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_last_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_last_of(charT<sp/>c,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_first_not_of(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_first_not_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_first_not_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_first_not_of(charT<sp/>c,<sp/>size_type<sp/>pos<sp/>=<sp/>0)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_last_not_of<sp/>(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_last_not_of<sp/>(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_last_not_of<sp/>(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>find_last_not_of<sp/>(charT<sp/>c,<sp/>size_type<sp/>pos<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string<sp/>substr(size_type<sp/>pos<sp/>=<sp/>0,<sp/>size_type<sp/>n<sp/>=<sp/>npos)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>compare(const<sp/>basic_string&amp;<sp/>str)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>compare(size_type<sp/>pos1,<sp/>size_type<sp/>n1,<sp/>const<sp/>basic_string&amp;<sp/>str)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>compare(size_type<sp/>pos1,<sp/>size_type<sp/>n1,<sp/>const<sp/>basic_string&amp;<sp/>str,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>pos2,<sp/>size_type<sp/>n2)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>compare(const<sp/>charT*<sp/>s)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>compare(size_type<sp/>pos1,<sp/>size_type<sp/>n1,<sp/>const<sp/>charT*<sp/>s)<sp/>const;<sp/><sp/>//<sp/>hh<sp/>990126</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>compare(size_type<sp/>pos1,<sp/>size_type<sp/>n1,<sp/>const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n2)<sp/>const;</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>CharArray</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::pointer<sp/>pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::size_type<sp/>size_type;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>construct/copy/destroy:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(Allocator(),<sp/>recommend(0)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refcount_(1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_(alloc_.allocate(alloc_.m_<sp/>+<sp/>1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*data_,<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray(const<sp/>Allocator&amp;<sp/>alloc,<sp/>size_type<sp/>capacity<sp/>=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(alloc,<sp/>recommend(capacity)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refcount_(1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_(alloc_.allocate(alloc_.m_<sp/>+<sp/>1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray(const<sp/>CharArray&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(rhs.alloc_,<sp/>recommend(rhs.size_)),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_(rhs.size_),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refcount_(1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_(alloc_.allocate(alloc_.m_<sp/>+<sp/>1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(data_,<sp/>rhs.data_,<sp/>size_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>~CharArray()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray&amp;<sp/>operator<sp/>=<sp/>(const<sp/>CharArray&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;rhs)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>&lt;<sp/>rhs.size_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>newsize<sp/>=<sp/>recommend(rhs.size_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>newdata<sp/>=<sp/>alloc_.allocate(newsize<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>newdata;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>newsize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>rhs.size_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(data_,<sp/>rhs.data_,<sp/>size_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>capacity</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>reserve(size_type<sp/>res_arg)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res_arg<sp/>&lt;<sp/>size_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_arg<sp/>=<sp/>size_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_arg<sp/>=<sp/>recommend(res_arg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res_arg<sp/>&lt;<sp/>alloc_.m_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>olddata<sp/>=<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>alloc_.allocate(res_arg<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(data_,<sp/>olddata,<sp/>size_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(olddata,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>res_arg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(res_arg<sp/>&gt;<sp/>alloc_.m_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>olddata<sp/>=<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>alloc_.allocate(res_arg<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(data_,<sp/>olddata,<sp/>size_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(olddata,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>res_arg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>capacity()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>refcounting</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>sharable()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>refcount_<sp/>!=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>is_unique()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>refcount_<sp/>&lt;=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>addRef(CharArray_allocator&amp;<sp/>alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(sharable())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++refcount_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>result<sp/>=<sp/>alloc.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc.construct(result,<sp/>*this);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc.deallocate(result,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>removeRef()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MSL_LOCK_MUTEX(lock,<sp/>mutex_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!sharable())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>invalidateReferences();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>--refcount_<sp/>==<sp/>0<sp/>?<sp/>this<sp/>:<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>makeUnique(size_type<sp/>n,<sp/>CharArray_allocator&amp;<sp/>alloc,<sp/>bool<sp/>copy<sp/>=<sp/>true)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MSL_LOCK_MUTEX(lock,<sp/>mutex_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(refcount_<sp/>&lt;=<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>result<sp/>=<sp/>alloc.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(result)<sp/>CharArray(alloc_,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--refcount_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(copy)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(result-&gt;data_,<sp/>data_,<sp/>min(n,<sp/>size_)<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result-&gt;size_<sp/>=<sp/>size_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc.deallocate(result,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>markUnsharable()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refcount_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>invalidateReferences()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refcount_<sp/>=<sp/>refcount_<sp/>&gt;<sp/>0<sp/>?<sp/>refcount_<sp/>:<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>access</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>pointer<sp/>data()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>data()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>allocator_type&amp;<sp/>get_allocator()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>alloc_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>size_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_EmptyMemberOpt&lt;Allocator,<sp/>size_type&gt;<sp/>alloc_;<sp/><sp/>//<sp/>m_<sp/>is<sp/>capacity</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>refcount_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_MSL_DECLARE_MUTEX(mutex_)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>size_type<sp/>recommend(size_type<sp/>capacity)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>capacity<sp/>+<sp/>3<sp/>-<sp/>capacity<sp/>%<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_EmptyMemberOpt&lt;CharArray_allocator,<sp/>CharArray*&gt;<sp/>alloc_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>CharArray<sp/>null_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pointer<sp/>__data()<sp/>{return<sp/>alloc_.m_-&gt;data();}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_pointer<sp/>__data()<sp/>const<sp/>{return<sp/>alloc_.m_-&gt;data();}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>size_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_EmptyMemberOpt&lt;Allocator,<sp/>size_type&gt;<sp/>alloc_;<sp/><sp/>//<sp/>m_<sp/>is<sp/>capacity</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pointer<sp/>data_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>pointer<sp/>__data()<sp/>{return<sp/>data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_pointer<sp/>__data()<sp/>const<sp/>{return<sp/>data_;}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>size_type<sp/>recommend(size_type<sp/>capacity)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>capacity<sp/>+<sp/>3<sp/>-<sp/>capacity<sp/>%<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>input_iterator_tag);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(ForwardIterator<sp/>begin,<sp/>ForwardIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>forward_iterator_tag);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_append(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_iterator_tag);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>forward_iterator_tag);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(static_cast&lt;size_type&gt;(begin),<sp/>static_cast&lt;charT&gt;(end),<sp/>a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(begin,<sp/>end,<sp/>a,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(begin<sp/>!=<sp/>end)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(alloc_.m_)<sp/>CharArray(a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*alloc_.m_-&gt;data(),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>begin<sp/>!=<sp/>end;<sp/>++begin)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*this<sp/>+=<sp/>*begin;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>null_.addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(ForwardIterator<sp/>begin,<sp/>ForwardIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>(size_type)distance(begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(alloc_.m_)<sp/>CharArray(a,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(begin,<sp/>end,<sp/>alloc_.m_-&gt;data());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>n),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>null_.addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(begin<sp/>!=<sp/>end)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>begin<sp/>!=<sp/>end;<sp/>++begin)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*this<sp/>+=<sp/>*begin;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(ForwardIterator<sp/>begin,<sp/>ForwardIterator<sp/>end,<sp/>const<sp/>Allocator&amp;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>(size_type)distance(begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>recommend(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>alloc_.allocate(n<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(begin,<sp/>end,<sp/>data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>n),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>alloc_.m_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>append(static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;charT&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_append(first,<sp/>last,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string<sp/>temp(first,<sp/>last,<sp/>get_allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>tempr<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_append(tempr.begin(),<sp/>tempr.end(),<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_append(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>(size_type)distance(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>curlen<sp/>=<sp/>size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(curlen<sp/>+<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>__data()<sp/>+<sp/>curlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>assign(static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;charT&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_assign(first,<sp/>last,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string<sp/>temp(first,<sp/>last,<sp/>get_allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>tempr<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_assign(tempr.begin(),<sp/>tempr.end(),<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>(size_type)distance(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(rlen,<sp/>false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>__data());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>replace(pos,<sp/>len,<sp/>static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;charT&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_replace(pos,<sp/>len,<sp/>first,<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string<sp/>temp(first,<sp/>last,<sp/>get_allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>tempr<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_replace(pos,<sp/>len,<sp/>tempr.begin(),<sp/>tempr.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>xlen<sp/>=<sp/>min(len,<sp/>size()<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>(size_type)distance(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>max_size()<sp/>||<sp/>size()<sp/>-<sp/>xlen<sp/>&gt;<sp/>max_size()<sp/>-<sp/>rlen)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::replace<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::replace<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>nlen<sp/>=<sp/>size()<sp/>-<sp/>xlen<sp/>+<sp/>rlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique()<sp/>||<sp/>nlen<sp/>&gt;<sp/>capacity())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(nlen<sp/>&gt;<sp/>capacity())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>must<sp/>do<sp/>with<sp/>copy</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>temp<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(temp)<sp/>CharArray(alloc_.m_-&gt;get_allocator(),<sp/>nlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data(),<sp/>alloc_.m_-&gt;data(),<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>temp-&gt;data()<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(temp-&gt;data()<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp-&gt;size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;removeRef();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(temp,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>temp<sp/>=<sp/>alloc_.allocate(recommend(nlen)<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp,<sp/>data_,<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>temp<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>data_<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(temp<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>recommend(nlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>must<sp/>do<sp/>inplace</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::move(alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::move(data_<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>data_<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>data_<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>init(const_pointer<sp/>begin,<sp/>const_pointer<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>random_access_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>init(size_type<sp/>n,<sp/>charT<sp/>c,<sp/>const<sp/>Allocator&amp;<sp/>a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>do_append(const_pointer<sp/>first,<sp/>const_pointer<sp/>last,<sp/>random_access_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>do_assign(const_pointer<sp/>first,<sp/>const_pointer<sp/>last,<sp/>random_access_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&amp;<sp/>do_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>const_pointer<sp/>first,<sp/>const_pointer<sp/>last,<sp/>random_access_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>change_size(size_type<sp/>n,<sp/>bool<sp/>copy<sp/>=<sp/>true);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::CharArray</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::null_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(const<sp/>charT*<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(charT<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>charT<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>_lib.string.special_:</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">swap(basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_IO</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_istream&lt;charT,traits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp;<sp/>is,<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_ostream&lt;charT,<sp/>traits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">operator<sp/>&lt;&lt;<sp/>(basic_ostream&lt;charT,<sp/>traits&gt;&amp;<sp/>os,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_IO</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Implementation</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::choose_init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(static_cast&lt;size_type&gt;(begin),<sp/>static_cast&lt;charT&gt;(end),<sp/>a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::choose_init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(begin,<sp/>end,<sp/>a,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(begin<sp/>!=<sp/>end)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(alloc_.m_)<sp/>CharArray(a);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*alloc_.m_-&gt;data(),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>begin<sp/>!=<sp/>end;<sp/>++begin)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*this<sp/>+=<sp/>*begin;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>null_.addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::init(ForwardIterator<sp/>begin,<sp/>ForwardIterator<sp/>end,<sp/>const<sp/>Allocator&amp;<sp/>a,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>(size_type)distance(begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(alloc_.m_)<sp/>CharArray(a,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(begin,<sp/>end,<sp/>alloc_.m_-&gt;data());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>n),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>null_.addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::init(InputIterator<sp/>begin,<sp/>InputIterator<sp/>end,<sp/>const<sp/>Allocator&amp;,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(begin<sp/>!=<sp/>end)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>begin<sp/>!=<sp/>end;<sp/>++begin)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*this<sp/>+=<sp/>*begin;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::init(ForwardIterator<sp/>begin,<sp/>ForwardIterator<sp/>end,<sp/>const<sp/>Allocator&amp;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>(size_type)distance(begin,<sp/>end);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>recommend(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>alloc_.allocate(n<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(begin,<sp/>end,<sp/>data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>n),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>alloc_.m_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::choose_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>append(static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;charT&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::choose_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_append(first,<sp/>last,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_append(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string<sp/>temp(first,<sp/>last,<sp/>get_allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>tempr<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_append(tempr.begin(),<sp/>tempr.end(),<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_append(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>(size_type)distance(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>curlen<sp/>=<sp/>size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(curlen<sp/>+<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>__data()<sp/>+<sp/>curlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>assign(static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;charT&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_assign(first,<sp/>last,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string<sp/>temp(first,<sp/>last,<sp/>get_allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>tempr<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_assign(tempr.begin(),<sp/>tempr.end(),<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>(size_type)distance(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(rlen,<sp/>false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>__data());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::choose_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>replace(pos,<sp/>len,<sp/>static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;charT&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::choose_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_replace(pos,<sp/>len,<sp/>first,<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string<sp/>temp(first,<sp/>last,<sp/>get_allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>tempr<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_replace(pos,<sp/>len,<sp/>tempr.begin(),<sp/>tempr.end(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,<sp/>ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>xlen<sp/>=<sp/>min(len,<sp/>size()<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>(size_type)distance(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>max_size()<sp/>||<sp/>size()<sp/>-<sp/>xlen<sp/>&gt;<sp/>max_size()<sp/>-<sp/>rlen)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::replace<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::replace<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>nlen<sp/>=<sp/>size()<sp/>-<sp/>xlen<sp/>+<sp/>rlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique()<sp/>||<sp/>nlen<sp/>&gt;<sp/>capacity())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(nlen<sp/>&gt;<sp/>capacity())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>must<sp/>do<sp/>with<sp/>copy</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>temp<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(temp)<sp/>CharArray(alloc_.m_-&gt;get_allocator(),<sp/>nlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data(),<sp/>alloc_.m_-&gt;data(),<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>temp-&gt;data()<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(temp-&gt;data()<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp-&gt;size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;removeRef();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(temp,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>temp<sp/>=<sp/>alloc_.allocate(recommend(nlen)<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp,<sp/>data_,<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>temp<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>data_<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(temp<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>recommend(nlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>must<sp/>do<sp/>inplace</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::move(alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::move(data_<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>data_<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(first,<sp/>last,<sp/>data_<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::basic_string(const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(CharArray_allocator(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>null_.addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::basic_string(const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>size_(0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_(a),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_(0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::basic_string(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(str.alloc_)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>strLen<sp/>=<sp/>str.size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>strLen)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;string<sp/>copy<sp/>constructor:<sp/>pos<sp/>&gt;<sp/>str<sp/>len&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;string<sp/>copy<sp/>constructor:<sp/>pos<sp/>&gt;<sp/>str<sp/>len\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>strLen<sp/>-<sp/>pos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rlen<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>==<sp/>strLen)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>str.alloc_.m_-&gt;addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(str.alloc_.m_-&gt;data()<sp/>+<sp/>pos,<sp/>str.alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>get_allocator(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(str.data_<sp/>+<sp/>pos,<sp/>str.data_<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>get_allocator(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::basic_string(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(CharArray_allocator(a))</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(a)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>strLen<sp/>=<sp/>str.size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>strLen)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;string<sp/>copy<sp/>constructor:<sp/>pos<sp/>&gt;<sp/>str<sp/>len&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;string<sp/>copy<sp/>constructor:<sp/>pos<sp/>&gt;<sp/>str<sp/>len\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>strLen<sp/>-<sp/>pos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rlen<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>==<sp/>strLen<sp/>&amp;&amp;<sp/>alloc_<sp/>==<sp/>str.alloc_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>str.alloc_.m_-&gt;addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(str.alloc_.m_-&gt;data()<sp/>+<sp/>pos,<sp/>str.alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>a,<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>init(str.data_<sp/>+<sp/>pos,<sp/>str.data_<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>a,<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::basic_string(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(CharArray_allocator(a))</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(a)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;string<sp/>constructor:<sp/>n<sp/>&gt;<sp/>max_size&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;string<sp/>constructor:<sp/>n<sp/>&gt;<sp/>max_size\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>init(s,<sp/>s<sp/>+<sp/>n,<sp/>a,<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::basic_string(const<sp/>charT*<sp/>s,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(CharArray_allocator(a))</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(a)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>traits::length(s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;string<sp/>constructor:<sp/>n<sp/>&gt;<sp/>max_size&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;string<sp/>constructor:<sp/>n<sp/>&gt;<sp/>max_size\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>init(s,<sp/>s<sp/>+<sp/>n,<sp/>a,<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::basic_string(size_type<sp/>n,<sp/>charT<sp/>c,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(CharArray_allocator(a))</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(a)</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>init(n,<sp/>c,<sp/>a);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::init(const_pointer<sp/>begin,<sp/>const_pointer<sp/>end,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;<sp/>a,<sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(begin<sp/>!=<sp/>end)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>len<sp/>=<sp/>size_type(end<sp/>-<sp/>begin);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(alloc_.m_)<sp/>CharArray(a,<sp/>len);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(alloc_.m_-&gt;data(),<sp/>begin,<sp/>len);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>len;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>len),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>null_.addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::init(size_type<sp/>n,<sp/>charT<sp/>c,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;string<sp/>constructor:<sp/>n<sp/>&gt;<sp/>max_size&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;string<sp/>constructor:<sp/>n<sp/>&gt;<sp/>max_size\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(alloc_.m_)<sp/>CharArray(a,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(alloc_.m_-&gt;data(),<sp/>n,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>n),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>null_.addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::~basic_string()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;removeRef();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::init(const_pointer<sp/>begin,<sp/>const_pointer<sp/>end,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Allocator&amp;,<sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(begin<sp/>!=<sp/>end)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>len<sp/>=<sp/>size_type(end<sp/>-<sp/>begin);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>recommend(len);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>alloc_.allocate(alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(data_,<sp/>begin,<sp/>len);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>len;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>len),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::init(size_type<sp/>n,<sp/>charT<sp/>c,<sp/>const<sp/>Allocator&amp;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;string<sp/>constructor:<sp/>n<sp/>&gt;<sp/>max_size&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;string<sp/>constructor:<sp/>n<sp/>&gt;<sp/>max_size\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>recommend(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>alloc_.allocate(alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(data_,<sp/>n,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>n),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::~basic_string()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::operator=(const<sp/>basic_string&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>assign(str);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::operator=(const<sp/>charT*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>assign(s);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::operator=(charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>assign(1,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::begin()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;makeUnique(alloc_.m_-&gt;size_,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>alloc_.m_-&gt;markUnsharable();</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>__data();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::begin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>__data();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::end()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;makeUnique(alloc_.m_-&gt;size_,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>alloc_.m_-&gt;markUnsharable();</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>__data()<sp/>+<sp/>size();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::end()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>__data()<sp/>+<sp/>size();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::rbegin()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>reverse_iterator(end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::const_reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::rbegin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_reverse_iterator(end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::rend()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>reverse_iterator(begin());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::const_reverse_iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::rend()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_reverse_iterator(begin());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_-&gt;size_;</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>size_;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::length()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_-&gt;size_;</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>size_;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::max_size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_-&gt;get_allocator().max_size()<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>get_allocator().max_size()<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::resize(size_type<sp/>n,<sp/>charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>oldsize<sp/>=<sp/>size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>change_size(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(oldsize<sp/>&lt;<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(__data()<sp/>+<sp/>oldsize,<sp/>n<sp/>-<sp/>oldsize,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::resize(size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resize(n,<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::change_size(size_type<sp/>n,<sp/>bool<sp/>copy)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::length<sp/>error.<sp/><sp/>Resizing<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::length<sp/>error.<sp/><sp/>Resizing<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;makeUnique(n,<sp/>alloc_,<sp/>copy);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>alloc_.m_-&gt;capacity())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>newsize<sp/>=<sp/>alloc_.m_-&gt;capacity();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(newsize<sp/>&lt;<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newsize<sp/>*=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;reserve(newsize);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>n),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;invalidateReferences();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::change_size(size_type<sp/>n,<sp/>bool<sp/>copy)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::length<sp/>error.<sp/><sp/>Resizing<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::length<sp/>error.<sp/><sp/>Resizing<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>alloc_.m_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>newsize<sp/>=<sp/>max(alloc_.m_,<sp/>recommend(1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(newsize<sp/>&lt;<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newsize<sp/>=<sp/>recommend(newsize<sp/>*<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>temp<sp/>=<sp/>alloc_.allocate(newsize<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(copy)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(data_,<sp/>data_<sp/>+<sp/>size_,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>newsize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>n),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::capacity()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_-&gt;capacity();</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::reserve(size_type<sp/>res_arg)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res_arg<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::reserve<sp/>argument<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::reserve<sp/>argument<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res_arg<sp/>&lt;<sp/>alloc_.m_-&gt;size_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_arg<sp/>=<sp/>alloc_.m_-&gt;size_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;makeUnique(res_arg,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;reserve(res_arg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;invalidateReferences();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::reserve(size_type<sp/>res_arg)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res_arg<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::reserve<sp/>argument<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::reserve<sp/>argument<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res_arg<sp/>&lt;<sp/>size_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_arg<sp/>=<sp/>size_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_arg<sp/>=<sp/>recommend(res_arg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(res_arg<sp/>!=<sp/>alloc_.m_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>temp<sp/>=<sp/>alloc_.allocate(res_arg<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::copy(data_,<sp/>data_<sp/>+<sp/>size_<sp/>+<sp/>1,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>res_arg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::clear()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>change_size(0,<sp/>false);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::empty()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>size()<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::const_reference</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::operator[](size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*(__data()<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::reference</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::operator[](size_type<sp/>pos)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;makeUnique(alloc_.m_-&gt;size_,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>alloc_.m_-&gt;markUnsharable();</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*(__data()<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::const_reference</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::at(size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;=<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::at<sp/>index<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::at<sp/>index<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*(__data()<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::reference</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::at(size_type<sp/>pos)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;=<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::at<sp/>index<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::at<sp/>index<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;makeUnique(alloc_.m_-&gt;size_,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>alloc_.m_-&gt;markUnsharable();</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*(__data()<sp/>+<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::operator+=(const<sp/>basic_string&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>append(str);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::operator+=(const<sp/>charT*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>append(s);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::operator+=(charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>append(1,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::append(const<sp/>basic_string&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>append(str,<sp/>0,<sp/>npos);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::append(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>str.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::append<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::append<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>min(n,<sp/>str.size()<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>ok<sp/>if<sp/>this<sp/>==<sp/>&amp;str</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>curlen<sp/>=<sp/>size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(curlen<sp/>+<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(__data()<sp/>+<sp/>curlen,<sp/>str.__data()<sp/>+<sp/>pos,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::append(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>curlen<sp/>=<sp/>size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(curlen<sp/>+<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(__data()<sp/>+<sp/>curlen,<sp/>s,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::append(const<sp/>charT*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>append(s,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::append(size_type<sp/>n,<sp/>charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size()<sp/>||<sp/>size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::append<sp/>results<sp/>in<sp/>string<sp/>&gt;<sp/>max_size&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::append<sp/>results<sp/>in<sp/>string<sp/>&gt;<sp/>max_size&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>curlen<sp/>=<sp/>size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(curlen<sp/>+<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(__data()<sp/>+<sp/>curlen,<sp/>n,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_append(const_pointer<sp/>first,<sp/>const_pointer<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>(size_type)(last<sp/>-<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>curlen<sp/>=<sp/>size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>change_size(curlen<sp/>+<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>traits::copy(__data()<sp/>+<sp/>curlen,<sp/>first,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::push_back(charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>append(1,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::assign(const<sp/>basic_string&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>assign(str,<sp/>0,<sp/>npos);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::assign(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>str.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::append<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::append<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>min(n,<sp/>str.size()<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>==<sp/>str.size()<sp/>&amp;&amp;<sp/>alloc_<sp/>==<sp/>str.alloc_<sp/>&amp;&amp;<sp/>str.alloc_.m_-&gt;sharable())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>==<sp/>str.alloc_.m_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;removeRef();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>str.alloc_.m_-&gt;addRef(alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;str)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase(0,<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>change_size(rlen,<sp/>false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(__data(),<sp/>str.__data()<sp/>+<sp/>pos,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::assign(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>change_size(n,<sp/>false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>traits::copy(__data(),<sp/>s,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::assign(const<sp/>charT*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>assign(s,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::assign(size_type<sp/>n,<sp/>charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>change_size(n,<sp/>false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>traits::assign(__data(),<sp/>n,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_assign(const_pointer<sp/>first,<sp/>const_pointer<sp/>last,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>(size_type)(last<sp/>-<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>change_size(rlen,<sp/>false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>traits::copy(__data(),<sp/>first,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::insert(size_type<sp/>pos1,<sp/>const<sp/>basic_string&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>insert(pos1,<sp/>str,<sp/>0,<sp/>npos);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::insert(size_type<sp/>pos1,<sp/>const<sp/>basic_string&amp;<sp/>str,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos2,<sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(pos1,<sp/>0,<sp/>str,<sp/>pos2,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::insert(size_type<sp/>pos,<sp/>const<sp/>charT*<sp/>s,<sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(pos,<sp/>0,<sp/>s,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::insert(size_type<sp/>pos,<sp/>const<sp/>charT*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>insert(pos,<sp/>s,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::insert(size_type<sp/>pos,<sp/>size_type<sp/>n,<sp/>charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(pos,<sp/>0,<sp/>n,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::insert(iterator<sp/>p,<sp/>charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos<sp/>=<sp/>size_type(p<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>replace(pos,<sp/>0,<sp/>1,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>begin()<sp/>+<sp/>pos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::insert(iterator<sp/>p,<sp/>size_type<sp/>n,<sp/>charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>replace(p,<sp/>p,<sp/>n,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::erase(size_type<sp/>pos,<sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(pos,<sp/>n,<sp/>0,<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::erase(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos<sp/>=<sp/>size_type(position<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>replace(pos,<sp/>1,<sp/>0,<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>begin()<sp/>+<sp/>pos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::erase(iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos<sp/>=<sp/>size_type(first<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>replace(pos,<sp/>size_type(last<sp/>-<sp/>first),<sp/>0,<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>begin()<sp/>+<sp/>pos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(size_type<sp/>pos1,<sp/>size_type<sp/>n1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(pos1,<sp/>n1,<sp/>str,<sp/>0,<sp/>npos);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(size_type<sp/>pos1,<sp/>size_type<sp/>n1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos2,<sp/>size_type<sp/>n2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos2<sp/>&gt;<sp/>str.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>min(n2,<sp/>str.size()<sp/>-<sp/>pos2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;str)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string<sp/>temp(str,<sp/>0,<sp/>npos,<sp/>str.get_allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>do_replace(pos1,<sp/>n1,<sp/>temp.begin()<sp/>+<sp/>pos2,<sp/>temp.begin()<sp/>+<sp/>pos2<sp/>+<sp/>rlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>do_replace(pos1,<sp/>n1,<sp/>str.begin()<sp/>+<sp/>pos2,<sp/>str.begin()<sp/>+<sp/>pos2<sp/>+<sp/>rlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(size_type<sp/>pos,<sp/>size_type<sp/>n1,<sp/>const<sp/>charT*<sp/>s,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>do_replace(pos,<sp/>n1,<sp/>s,<sp/>s<sp/>+<sp/>n2,<sp/>random_access_iterator_tag());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(size_type<sp/>pos,<sp/>size_type<sp/>n1,<sp/>const<sp/>charT*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(pos,<sp/>n1,<sp/>s,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(size_type<sp/>pos,<sp/>size_type<sp/>n1,<sp/>size_type<sp/>n2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>xlen<sp/>=<sp/>min(n1,<sp/>size()<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n2<sp/>&gt;<sp/>max_size()<sp/>||<sp/>size()<sp/>-<sp/>xlen<sp/>&gt;<sp/>max_size()<sp/>-<sp/>n2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::replace<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>nlen<sp/>=<sp/>size()<sp/>-<sp/>xlen<sp/>+<sp/>n2;</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique()<sp/>||<sp/>nlen<sp/>&gt;<sp/>capacity())</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nlen<sp/>&gt;<sp/>capacity())</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>must<sp/>do<sp/>with<sp/>copy</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>temp<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(temp)<sp/>CharArray(alloc_.m_-&gt;get_allocator(),<sp/>nlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data(),<sp/>alloc_.m_-&gt;data(),<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n2<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(temp-&gt;data()<sp/>+<sp/>pos,<sp/>n2,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>n2,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(temp-&gt;data()<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp-&gt;size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;removeRef();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(temp,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>temp<sp/>=<sp/>alloc_.allocate(recommend(nlen)<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp,<sp/>data_,<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n2<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(temp<sp/>+<sp/>pos,<sp/>n2,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp<sp/>+<sp/>pos<sp/>+<sp/>n2,<sp/>data_<sp/>+<sp/>pos<sp/>+<sp/>xlen,<sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(temp<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>recommend(nlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>must<sp/>do<sp/>inplace</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::move(alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>n2,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n2<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(alloc_.m_-&gt;data()<sp/>+<sp/>pos,<sp/>n2,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::move(data_<sp/>+<sp/>pos<sp/>+<sp/>n2,<sp/>data_<sp/>+<sp/>pos<sp/>+<sp/>xlen,<sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n2<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(data_<sp/>+<sp/>pos,<sp/>n2,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(size_type(i1<sp/>-<sp/>begin()),<sp/>size_type(i2<sp/>-<sp/>i1),<sp/>str);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>const<sp/>charT*<sp/>s,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(size_type(i1<sp/>-<sp/>begin()),<sp/>size_type(i2<sp/>-<sp/>i1),<sp/>s,<sp/>n);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>const<sp/>charT*<sp/>s)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(size_type(i1<sp/>-<sp/>begin()),<sp/>size_type(i2<sp/>-<sp/>i1),<sp/>s);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::replace(iterator<sp/>i1,<sp/>iterator<sp/>i2,<sp/>size_type<sp/>n,<sp/>charT<sp/>c)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>replace(size_type(i1<sp/>-<sp/>begin()),<sp/>size_type(i2<sp/>-<sp/>i1),<sp/>n,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::do_replace(size_type<sp/>pos,<sp/>size_type<sp/>len,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_pointer<sp/>first,<sp/>const_pointer<sp/>last,<sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::replace<sp/>pos<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>xlen<sp/>=<sp/>min(len,<sp/>size()<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>size_type(last<sp/>-<sp/>first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>max_size()<sp/>||<sp/>size()<sp/>-<sp/>xlen<sp/>&gt;<sp/>max_size()<sp/>-<sp/>rlen)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;basic_string::replace<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::replace<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>nlen<sp/>=<sp/>size()<sp/>-<sp/>xlen<sp/>+<sp/>rlen;</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!alloc_.m_-&gt;is_unique()<sp/>||<sp/>nlen<sp/>&gt;<sp/>capacity()<sp/>||<sp/>first<sp/>&gt;=<sp/>__data()<sp/>&amp;&amp;<sp/>first<sp/>&lt;<sp/>__data()<sp/>+<sp/>size())</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(nlen<sp/>&gt;<sp/>capacity()<sp/>||<sp/>first<sp/>&gt;=<sp/>__data()<sp/>&amp;&amp;<sp/>first<sp/>&lt;<sp/>__data()<sp/>+<sp/>size())</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>must<sp/>do<sp/>with<sp/>copy</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CharArray*<sp/>temp<sp/>=<sp/>alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new<sp/>(temp)<sp/>CharArray(alloc_.m_-&gt;get_allocator(),<sp/>nlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data(),<sp/>alloc_.m_-&gt;data(),<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data()<sp/>+<sp/>pos,<sp/>first,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(temp-&gt;data()<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp-&gt;size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>alloc_.m_-&gt;removeRef();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(alloc_.m_,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(bad_alloc)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(temp,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>temp<sp/>=<sp/>alloc_.allocate(recommend(nlen)<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp,<sp/>data_,<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp<sp/>+<sp/>pos,<sp/>first,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(temp<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>data_<sp/>+<sp/>pos<sp/>+<sp/>xlen,<sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(temp<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.deallocate(data_,<sp/>alloc_.m_<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data_<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>recommend(nlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>must<sp/>do<sp/>inplace</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::move(alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>alloc_.m_-&gt;data()<sp/>+<sp/>pos<sp/>+<sp/>xlen,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(alloc_.m_-&gt;data()<sp/>+<sp/>pos,<sp/>first,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(alloc_.m_-&gt;data()<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_-&gt;size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>!=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::move(data_<sp/>+<sp/>pos<sp/>+<sp/>rlen,<sp/>data_<sp/>+<sp/>pos<sp/>+<sp/>xlen,<sp/>size()<sp/>-<sp/>(pos<sp/>+<sp/>xlen));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(rlen<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::copy(data_<sp/>+<sp/>pos,<sp/>first,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::assign(*(data_<sp/>+<sp/>nlen),<sp/>charT());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_<sp/>=<sp/>nlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif<sp/>//<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::copy(charT*<sp/>s,<sp/>size_type<sp/>n,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::copy<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::copy<sp/>pos<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>min(n,<sp/>size()<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>traits::copy(s,<sp/>__data()<sp/>+<sp/>pos,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rlen;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::swap(basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>!=<sp/>&amp;str)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(alloc_,<sp/>str.alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(size_,<sp/>str.size_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(alloc_,<sp/>str.alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(data_,<sp/>str.data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">const<sp/>charT*</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::c_str()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>data();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">const<sp/>charT*</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::data()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_-&gt;data();</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(data_<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>charT<sp/>__null<sp/>=<sp/>charT();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>&amp;__null;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::allocator_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::get_allocator()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_REFCOUNT_STRING</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_-&gt;get_allocator();</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find(str.begin(),<sp/>pos,<sp/>str.size());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>+<sp/>n<sp/>&gt;<sp/>size()<sp/>||<sp/>n<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>i<sp/>=<sp/>begin()<sp/>+<sp/>pos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>e<sp/>=<sp/>end()<sp/>-<sp/>n<sp/>+<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>charT<sp/>c<sp/>=<sp/>*s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(i<sp/>!=<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(i<sp/>!=<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>c))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>goto<sp/>found_one;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>found_one:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>n1<sp/>=<sp/>1;<sp/>n1<sp/>&lt;<sp/>n;<sp/>++n1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!traits::eq(*j,<sp/>*(s<sp/>+<sp/>n1)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>goto<sp/>false_alarm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>false_alarm:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find(s,<sp/>pos,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find<sp/>(charT<sp/>c,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;=<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>i<sp/>=<sp/>begin()<sp/>+<sp/>pos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(i<sp/>!=<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>c))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::rfind(const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rfind(str.begin(),<sp/>pos,<sp/>str.size());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::rfind(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>==<sp/>0<sp/>||<sp/>n<sp/>==<sp/>0<sp/>||<sp/>n<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pos<sp/>=<sp/>size()<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>i<sp/>=<sp/>rbegin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>-<sp/>pos<sp/>&gt;<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>+=<sp/>difference_type(size()<sp/>-<sp/>pos<sp/>-<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>e<sp/>=<sp/>rend()<sp/>-<sp/>difference_type(n<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>charT<sp/>c<sp/>=<sp/>*(s<sp/>+<sp/>n<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(i<sp/>!=<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(i<sp/>!=<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>c))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>goto<sp/>found_one;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>found_one:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>n1<sp/>=<sp/>1;<sp/>n1<sp/>&lt;<sp/>n;<sp/>++n1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!traits::eq(*j,<sp/>*(s<sp/>+<sp/>n<sp/>-<sp/>1<sp/>-<sp/>n1)))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>goto<sp/>false_alarm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(j.base()<sp/>-<sp/>begin()<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>false_alarm:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::rfind(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rfind(s,<sp/>pos,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::rfind<sp/>(charT<sp/>c,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pos<sp/>=<sp/>size()<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>i<sp/>=<sp/>rbegin()<sp/>+<sp/>difference_type(size()<sp/>-<sp/>1<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>e<sp/>=<sp/>rend();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(i<sp/>!=<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>c))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i.base()<sp/>-<sp/>begin()<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_first_of(const<sp/>basic_string&amp;<sp/>str,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find_first_of(str.begin(),<sp/>pos,<sp/>str.size());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_first_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;=<sp/>size()<sp/>||<sp/>n<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_iterator<sp/>i<sp/>=<sp/>begin()<sp/>+<sp/>pos;<sp/>i<sp/>!=<sp/>end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>charT*<sp/>j<sp/>=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>n1<sp/>=<sp/>0;<sp/>n1<sp/>&lt;<sp/>n;<sp/>++n1,<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_first_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find_first_of(s,<sp/>pos,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_first_of(charT<sp/>c,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;=<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_iterator<sp/>i<sp/>=<sp/>begin()<sp/>+<sp/>pos;<sp/>i<sp/>!=<sp/>end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>c))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_last_of(const<sp/>basic_string&amp;<sp/>str,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find_last_of(str.begin(),<sp/>pos,<sp/>str.size());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_last_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>==<sp/>0<sp/>||<sp/>n<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pos<sp/>=<sp/>size()<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_reverse_iterator<sp/>i<sp/>=<sp/>rend()<sp/>-<sp/>difference_type(pos<sp/>+<sp/>1);<sp/>i<sp/>!=<sp/>rend();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>charT*<sp/>j<sp/>=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>n1<sp/>=<sp/>0;<sp/>n1<sp/>&lt;<sp/>n;<sp/>++n1,<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i.base()<sp/>-<sp/>begin()<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_last_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find_last_of(s,<sp/>pos,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_last_of(charT<sp/>c,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pos<sp/>=<sp/>size()<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_reverse_iterator<sp/>i<sp/>=<sp/>rend()<sp/>-<sp/>difference_type(pos<sp/>+<sp/>1);<sp/>i<sp/>!=<sp/>rend();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>c))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i.base()<sp/>-<sp/>begin()<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_first_not_of(const<sp/>basic_string&amp;<sp/>str,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find_first_not_of(str.begin(),<sp/>pos,<sp/>str.size());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_first_not_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;=<sp/>size()<sp/>||<sp/>n<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_iterator<sp/>i<sp/>=<sp/>begin()<sp/>+<sp/>pos;<sp/>i<sp/>!=<sp/>end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>charT*<sp/>j<sp/>=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>n1<sp/>=<sp/>0;<sp/>n1<sp/>&lt;<sp/>n;<sp/>++n1,<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>goto<sp/>not_this_one;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>not_this_one:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_first_not_of(const<sp/>charT*<sp/>s,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find_first_not_of(s,<sp/>pos,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_first_not_of(charT<sp/>c,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;=<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_iterator<sp/>i<sp/>=<sp/>begin()<sp/>+<sp/>pos;<sp/>i<sp/>!=<sp/>end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!traits::eq(*i,<sp/>c))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i<sp/>-<sp/>begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_last_not_of(const<sp/>basic_string&amp;<sp/>str,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find_last_not_of(str.begin(),<sp/>pos,<sp/>str.size());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_last_not_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pos<sp/>=<sp/>size()<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_reverse_iterator<sp/>i<sp/>=<sp/>rend()<sp/>-<sp/>difference_type(pos<sp/>+<sp/>1);<sp/>i<sp/>!=<sp/>rend();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>charT*<sp/>j<sp/>=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>n1<sp/>=<sp/>0;<sp/>n1<sp/>&lt;<sp/>n;<sp/>++n1,<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(*i,<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>goto<sp/>not_this_one;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i.base()<sp/>-<sp/>begin()<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>not_this_one:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_last_not_of(const<sp/>charT*<sp/>s,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>find_last_not_of(s,<sp/>pos,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::find_last_not_of(charT<sp/>c,<sp/>size_type<sp/>pos)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pos<sp/>=<sp/>size()<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_reverse_iterator<sp/>i<sp/>=<sp/>rend()<sp/>-<sp/>difference_type(pos<sp/>+<sp/>1);<sp/>i<sp/>!=<sp/>rend();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!traits::eq(*i,<sp/>c))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>size_type(i.base()<sp/>-<sp/>begin()<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>npos;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::substr(size_type<sp/>pos,<sp/>size_type<sp/>n)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;basic_string::substr<sp/>pos<sp/>out<sp/>of<sp/>range&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;basic_string::substr<sp/>pos<sp/>out<sp/>of<sp/>range\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>min(n,<sp/>size()<sp/>-<sp/>pos);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>basic_string(*this,<sp/>pos,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">int</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::compare(const<sp/>basic_string&amp;<sp/>str)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>compare(0,<sp/>size(),<sp/>str.begin(),<sp/>str.size());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">int</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::compare(size_type<sp/>pos1,<sp/>size_type<sp/>n1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>str)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>compare(pos1,<sp/>n1,<sp/>str.begin(),<sp/>str.size());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">int</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::compare(size_type<sp/>pos1,<sp/>size_type<sp/>n1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>basic_string&amp;<sp/>str,<sp/>size_type<sp/>pos2,<sp/>size_type<sp/>n2)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos2<sp/>&gt;<sp/>str.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;string<sp/>compare:<sp/>pos<sp/>&gt;<sp/>len&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;string<sp/>compare:<sp/>pos<sp/>&gt;<sp/>len\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>compare(pos1,<sp/>n1,<sp/>str.begin()<sp/>+<sp/>pos2,<sp/>min(str.size()<sp/>-<sp/>pos2,<sp/>n2));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">int</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::compare(const<sp/>charT*<sp/>s)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>compare(0,<sp/>size(),<sp/>s,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990126</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">int</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::compare(size_type<sp/>pos1,<sp/>size_type<sp/>n1,<sp/>const<sp/>charT*<sp/>s)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>compare(pos1,<sp/>n1,<sp/>s,<sp/>traits::length(s));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">int</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;::compare(size_type<sp/>pos1,<sp/>size_type<sp/>n1,<sp/>const<sp/>charT*<sp/>s,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>n2)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(pos1<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>out_of_range(&quot;string<sp/>compare:<sp/>pos<sp/>&gt;<sp/>len&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;string<sp/>compare:<sp/>pos<sp/>&gt;<sp/>len\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>len<sp/>=<sp/>min(size()<sp/>-<sp/>pos1<sp/>,<sp/>n1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>rlen<sp/>=<sp/>min(len,<sp/>n2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>result<sp/>=<sp/>traits::compare(begin()<sp/>+<sp/>pos1,<sp/>s,<sp/>rlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(result<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(len<sp/>&lt;<sp/>n2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(len<sp/>==<sp/>n2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;(lhs).append(rhs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(const<sp/>charT*<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;(lhs).append(rhs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(charT<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;(1,<sp/>lhs).append(rhs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;(lhs).append(rhs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_string&lt;charT,traits,Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">operator+(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>charT<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>basic_string&lt;charT,<sp/>traits,<sp/>Allocator&gt;(lhs).append(1,<sp/>rhs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rhs.compare(lhs)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>!=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rhs.compare(lhs)<sp/>!=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>!=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>&lt;<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>&lt;<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rhs.compare(lhs)<sp/>&gt;<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>&gt;<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>&gt;<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rhs.compare(lhs)<sp/>&lt;<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>&lt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>&lt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rhs.compare(lhs)<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>const<sp/>charT*<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lhs.compare(rhs)<sp/>&gt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>charT*<sp/>lhs,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rhs.compare(lhs)<sp/>&lt;=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>_lib.string.special_:</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">swap(basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>lhs,<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>rhs)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lhs.swap(rhs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_IO</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_istream&lt;charT,traits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">operator<sp/>&gt;&gt;<sp/>(basic_istream&lt;charT,traits&gt;&amp;<sp/>is,<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>basic_string&lt;charT,traits,Allocator&gt;::size_type<sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>basic_istream&lt;charT,traits&gt;::sentry<sp/>ok(is);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ok)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXPLICIT_FUNC_TEMPLATE_ARG</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>ctype&lt;charT&gt;&amp;<sp/>ct<sp/>=<sp/>use_facet&lt;ctype&lt;charT&gt;<sp/>&gt;(is.getloc());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>ctype&lt;charT&gt;&amp;<sp/>ct<sp/>=<sp/>use_facet(is.getloc(),<sp/>(ctype&lt;charT&gt;*)0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>size_type(is.width());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>str.max_size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>basic_string&lt;charT,traits,Allocator&gt;<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>istreambuf_iterator&lt;charT,<sp/>traits&gt;<sp/>in(is);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>istreambuf_iterator&lt;charT,<sp/>traits&gt;<sp/>end;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(count<sp/>&lt;<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(in<sp/>==<sp/>end)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>is.setstate(ios_base::eofbit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(ct.is(ctype&lt;charT&gt;::space,<sp/>*in))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp.append(1,<sp/>*in);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++in;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(count<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>str<sp/>=<sp/>temp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>is.width(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(count<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>is.setstate(ios_base::failbit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>is;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>__GNUC__</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_ostream&lt;charT,<sp/>traits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">operator<sp/>&lt;&lt;<sp/>(basic_ostream&lt;charT,<sp/>traits&gt;&amp;<sp/>os,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>basic_ostream&lt;charT,traits&gt;::sentry<sp/>ok(os);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ok)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(__putnumber(ostreambuf_iterator&lt;charT,<sp/>traits&gt;(os),<sp/>os,<sp/>os.fill(),<sp/>(const<sp/>charT*)0,<sp/>0,<sp/>str.begin(),<sp/>int(str.size())).failed())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>os.setstate(ios_base::failbit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>os.width(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>os;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_ostream&lt;charT,<sp/>traits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">operator<sp/>&lt;&lt;<sp/>(basic_ostream&lt;charT,<sp/>traits&gt;&amp;<sp/>os,<sp/>const<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>os<sp/>&lt;&lt;<sp/>str.c_str();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990201</highlight></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">basic_istream&lt;charT,traits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">getline(basic_istream&lt;charT,traits&gt;&amp;<sp/>is,<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str,<sp/>charT<sp/>delim)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>basic_string&lt;charT,traits,Allocator&gt;::size_type<sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>basic_istream&lt;charT,traits&gt;::sentry<sp/>ok(is,<sp/>true);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(ok)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>str.clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/><sp/>str.max_size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(count<sp/>&lt;<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traits::int_type<sp/>i<sp/>=<sp/>is.rdbuf()-&gt;sbumpc();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>traits::eof())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>is.setstate(ios_base::eofbit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>charT<sp/>c<sp/>=<sp/>traits::to_char_type(i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(traits::eq(c,<sp/>delim))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>str.append(1,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(count<sp/>==<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>is.setstate(ios_base::failbit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(count<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>is.setstate(ios_base::failbit);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>is;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template&lt;class<sp/>charT,<sp/>class<sp/>traits,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">basic_istream&lt;charT,traits&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">getline(basic_istream&lt;charT,traits&gt;&amp;<sp/>is,<sp/>basic_string&lt;charT,traits,Allocator&gt;&amp;<sp/>str)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>getline(is,<sp/>str,<sp/>is.widen(&apos;\n&apos;));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_MSL_NO_IO</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">typedef<sp/>basic_string&lt;char,<sp/>char_traits&lt;char&gt;,<sp/>allocator&lt;char&gt;<sp/>&gt;<sp/>string;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_WCHART</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>basic_string&lt;wchar_t,<sp/>char_traits&lt;wchar_t&gt;,<sp/>allocator&lt;wchar_t&gt;<sp/>&gt;<sp/>wstring;</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_CPP_NAMESPACE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/>//<sp/>namespace<sp/>std</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#if<sp/>defined(__CFM68K__)<sp/>&amp;&amp;<sp/>!defined(__USING_STATIC_LIBS__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#pragma<sp/>import<sp/>reset</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>options<sp/>align=reset</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/><sp/>//<sp/>RC_INVOKED</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_STRING</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>980908<sp/>rewrote</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>981220<sp/>Added<sp/>typename<sp/>to<sp/>appropriate<sp/>return<sp/>types</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990126<sp/>Converted<sp/>from<sp/>MSIPL<sp/>flags<sp/>to<sp/>_MSL<sp/>flags</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990126<sp/>Corrected<sp/>standards<sp/>bug:<sp/><sp/>compare(pos1,<sp/>n1,<sp/>s)<sp/>was<sp/>malfunctioning<sp/>because<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>default<sp/>argument<sp/>for<sp/>n2<sp/>was<sp/>npos.<sp/><sp/>It<sp/>should<sp/>be<sp/>traits::length(s).<sp/><sp/>This<sp/>requires</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splitting<sp/>compare<sp/>into<sp/>two<sp/>signitures.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990201<sp/>Several<sp/>changes<sp/>in<sp/>getline:<sp/><sp/>erase<sp/>string<sp/>as<sp/>soon<sp/>as<sp/>sentry<sp/>is<sp/>passed.</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed<sp/>temp<sp/>string<sp/>as<sp/>it<sp/>no<sp/>longer<sp/>makes<sp/>sense.</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Changed<sp/>to<sp/>work<sp/>with<sp/>sbumpc<sp/>instead<sp/>of<sp/>istreambuf_iterator.<sp/><sp/>This<sp/>reduces<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>look<sp/>ahead<sp/>by<sp/>1<sp/>char<sp/>which<sp/>makes<sp/>getline<sp/>behave<sp/>better<sp/>when<sp/>the<sp/>stream<sp/>is<sp/>cin.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990630<sp/>Added<sp/>null_<sp/>object<sp/>to<sp/>avoid<sp/>allocations<sp/>for<sp/>constructing<sp/>null<sp/>strings.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990727<sp/>Added<sp/>non-refcounted<sp/>version</highlight></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990728<sp/>Uninlined<sp/>member<sp/>template<sp/>methods<sp/>where<sp/>feasible.</highlight></codeline>
    </programlisting>
    <location file="decomp/CodeWarrior/PowerPC_EABI_Support/Msl/MSL_C++/MSL_Common/Include/string"/>
  </compounddef>
</doxygen>
