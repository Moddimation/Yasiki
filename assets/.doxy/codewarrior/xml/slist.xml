<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="slist" kind="file" language="C++">
    <compoundname>slist</compoundname>
    <includedby refid="slist_8h" local="no">slist.h</includedby>
    <invincdepgraph>
      <node id="1">
        <label>slist</label>
        <link refid="slist"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>slist.h</label>
        <link refid="slist_8h"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*<sp/><sp/>Metrowerks<sp/>Standard<sp/>Library<sp/><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*<sp/><sp/>$Date:<sp/>1999/12/09<sp/>17:59:45<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>$Revision:<sp/>1.3.4.1<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>$NoKeywords:<sp/>$<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>Copyright<sp/>1995-1999<sp/>Metrowerks,<sp/>Inc.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>**<sp/><sp/>slist</highlight></codeline>
<codeline><highlight class="normal"><sp/>**/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>WARNING</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/>slist<sp/>is<sp/>a<sp/>non-standard<sp/>header<sp/>and<sp/>container.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/>slist<sp/>has<sp/>not<sp/>yet<sp/>been<sp/>approved<sp/>by<sp/>the<sp/>ANSI/ISO<sp/>Standards</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/>Committee;<sp/>therefore,<sp/>we<sp/>are<sp/>supplying<sp/>this<sp/>class<sp/>as<sp/>largely</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/>specified<sp/>by<sp/>the<sp/>Silicon<sp/>Graphics,<sp/>Inc.<sp/>(SGI)<sp/>,<sp/>Standard<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/>Template<sp/>Library<sp/>(STL).<sp/><sp/>For<sp/>further<sp/>information,<sp/>refer<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;http://www.sgi.com/Technology/STL/Slist.html&gt;<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/>The<sp/>implementation<sp/>herein<sp/>belongs<sp/>to<sp/>Metrowerks,<sp/>Inc.,<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/>is<sp/>protected<sp/>by<sp/>copyright.<sp/><sp/>Those<sp/>parts<sp/>of<sp/>the<sp/>interface</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/>unique<sp/>to<sp/>SGI&apos;s<sp/>specification<sp/>are<sp/>supplied<sp/>by<sp/>SGI,<sp/>and<sp/>are</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/>likewise<sp/>protected<sp/>by<sp/>copyright.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>Copyright<sp/>ã‚¥<sp/>1996-1999<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/>Silicon<sp/>Graphics<sp/>Computer<sp/>Systems,<sp/>Inc.<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_SLIST</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>_SLIST</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mslconfig&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;memory&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;limits&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdexcept&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;iterator&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;algorithm&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>RC_INVOKED</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#pragma<sp/>options<sp/>align=native</highlight></codeline>
<codeline><highlight class="normal">#if<sp/>defined(__CFM68K__)<sp/>&amp;&amp;<sp/>!defined(__USING_STATIC_LIBS__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#pragma<sp/>import<sp/>on</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_CPP_NAMESPACE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>namespace<sp/>std<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator<sp/>=<sp/>allocator&lt;T&gt;<sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>slist</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;bool<sp/>b&gt;<sp/>struct<sp/>chooser<sp/>{};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>types:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_reference<sp/><sp/><sp/>const_reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::size_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::difference_type<sp/><sp/><sp/>difference_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>T<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>Allocator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::pointer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_pointer<sp/><sp/><sp/><sp/><sp/>const_pointer;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>struct<sp/>node;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>struct<sp/>node_base</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>struct<sp/>node</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>node_base</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typedef<sp/>_MSL_REBIND<sp/>(node)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_allocator_type;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">public:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;forward_iterator_tag,<sp/>T,<sp/>difference_type,<sp/>pointer,<sp/>reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>node_-&gt;data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>&amp;node_-&gt;data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{node_<sp/>=<sp/>node_-&gt;next_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{iterator<sp/>tmp(*this);<sp/>node_<sp/>=<sp/>node_-&gt;next_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>==(iterator<sp/>x,<sp/>iterator<sp/>y)<sp/>{return<sp/>static_cast&lt;bool&gt;(x.node_<sp/>==<sp/>y.node_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>!=(iterator<sp/>x,<sp/>iterator<sp/>y)<sp/>{return<sp/>static_cast&lt;bool&gt;(x.node_<sp/>!=<sp/>y.node_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>node_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator(node*<sp/>node)<sp/>:<sp/>node_(node)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>slist;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>slist::const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;forward_iterator_tag,<sp/>T,<sp/>difference_type,<sp/>const_pointer,<sp/>const_reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(slist::iterator<sp/>x)<sp/>:<sp/>node_(x.node_)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>node_-&gt;data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>&amp;node_-&gt;data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{node_<sp/>=<sp/>node_-&gt;next_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{const_iterator<sp/>tmp(*this);<sp/>node_<sp/>=<sp/>node_-&gt;next_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>==(const_iterator<sp/>x,<sp/>const_iterator<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{return<sp/>static_cast&lt;bool&gt;(x.node_<sp/>==<sp/>y.node_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>!=(const_iterator<sp/>x,<sp/>const_iterator<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{return<sp/>static_cast&lt;bool&gt;(x.node_<sp/>!=<sp/>y.node_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>node*<sp/>node_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(const<sp/>node*<sp/>node)<sp/>:<sp/>node_(node)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>slist;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.cons<sp/>construct/copy/destroy:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>slist(const<sp/>Allocator&amp;<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>explicit<sp/>slist(size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist(size_type<sp/>n,<sp/>const<sp/>T&amp;<sp/>value,<sp/>const<sp/>Allocator&amp;<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_(node_allocator_type(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.prev_<sp/>=<sp/>tail.next_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist(const_iterator<sp/>first,<sp/>const_iterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist(const<sp/>slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>~slist();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&amp;<sp/>operator=(const<sp/>slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;<sp/>void<sp/>assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>assign(const_iterator<sp/>first,<sp/>const_iterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>assign(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last);</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>assign(size_type<sp/>n,<sp/>const<sp/>T&amp;<sp/>t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>allocator_type<sp/>get_allocator()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>iterators:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last_node();<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>returns<sp/>--end()<sp/>(constant<sp/>time)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last_node()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>previous(iterator<sp/>x);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>returns<sp/>--x<sp/>(linear<sp/>time)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>previous(const_iterator<sp/>x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.capacity<sp/>capacity:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/><sp/><sp/><sp/><sp/><sp/>empty()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_type<sp/>max_size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>resize(size_type<sp/>sz);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>resize(size_type<sp/>sz,<sp/>const<sp/>value_type&amp;<sp/>value);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>element<sp/>access:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/>front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_reference<sp/>front()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.modifiers<sp/>modifiers:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>push_front(const<sp/>T&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>pop_front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>push_back(const<sp/>T&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>there<sp/>is<sp/>no<sp/>pop_back</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>insert(iterator<sp/>position,<sp/>const<sp/>T&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>insert(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>T&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(previous(position),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>position,<sp/>const_iterator<sp/>first,<sp/>const_iterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>position,<sp/>const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last);</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>insert,<sp/>inserts<sp/>stuff<sp/>after<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>insert_after(iterator<sp/>position,<sp/>const<sp/>T&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>insert_after(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>T&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_insert_after(position,<sp/>first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>insert_after(iterator<sp/>position,<sp/>const_iterator<sp/>first,<sp/>const_iterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>insert_after(iterator<sp/>position,<sp/>const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last);</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>erase(iterator<sp/>position);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>erase(iterator<sp/>position,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>erase</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>erase_after(iterator<sp/>position);<sp/>//<sp/>erase<sp/>(position,<sp/>position+1],<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>erase_after(iterator<sp/>position,<sp/>iterator<sp/>last);<sp/>//<sp/>erase<sp/>(position,<sp/>last],<sp/>return<sp/>position</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>swap(slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.ops<sp/>slist<sp/>operations:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>splice,<sp/>splices<sp/>stuff<sp/>after<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i);<sp/>//<sp/>splices<sp/>(i,<sp/>i+1]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>splices<sp/>(first,<sp/>last]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>remove(const<sp/>T&amp;<sp/>value);</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;<sp/>void<sp/>remove_if(Predicate<sp/>pred);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_if(Predicate<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p1<sp/>=<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(pred(*i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!pred(*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>unique();</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;<sp/>void<sp/>unique(BinaryPredicate<sp/>binary_pred);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unique(BinaryPredicate<sp/>binary_pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!binary_pred(*i,<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>!=<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>merge(slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;<sp/>void<sp/>merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>x.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::merge<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::merge<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first1<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last1<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first2<sp/>=<sp/>x.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last2<sp/>=<sp/>x.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst1<sp/>=<sp/>last1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst2<sp/>=<sp/>last2.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first1<sp/>!=<sp/>last1<sp/>&amp;&amp;<sp/>first2<sp/>!=<sp/>last2;<sp/>++first1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(comp(*first2,<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>first2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>last2;<sp/>++j,<sp/>++count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!comp(*j,<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>splice_after(pfirst1,<sp/>x,<sp/>pfirst2,<sp/>pj)<sp/>but<sp/>with<sp/>pj-pfirst2<sp/>stored<sp/>in<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>pj)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>pfirst2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(pfirst2,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(pfirst1,<sp/>first2.node_,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>pfirst1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>pj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>-=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pfirst1<sp/>=<sp/>first1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(first2<sp/>!=<sp/>last2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>sort();</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;<sp/>void<sp/>sort(Compare<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort(Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>0:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>1:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>2:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(comp(*j,<sp/>*i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>reverse()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_-&gt;next_<sp/>=<sp/>(node*)&amp;node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_-&gt;next_<sp/>=<sp/>node_alloc_.m_.next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>node_alloc_.m_.next_-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>lower_size<sp/>=<sp/>size()<sp/>/<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>advance(i,<sp/>lower_size<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>upper_half;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>upper_half.splice_after(upper_half.last_node(),<sp/>*this,<sp/>i,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s3<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(&amp;upper_half.node_alloc_.m_,<sp/>s2,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.back_<sp/>=<sp/>s3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.alloc_.m_<sp/>=<sp/>alloc_.m_<sp/>-<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort(comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.sort(comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(upper_half,<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>reverse();</highlight></codeline>
<codeline><highlight class="normal">private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_EmptyMemberOpt&lt;Allocator,<sp/>size_type&gt;<sp/>alloc_;<sp/><sp/>//<sp/>alloc_.m_<sp/>is<sp/>size_</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>_EmptyMemberOpt&lt;node_allocator_type,<sp/>node_base&gt;<sp/>node_alloc_;<sp/><sp/>//<sp/>node_alloc_.m_<sp/>is<sp/>tail<sp/>pseudo<sp/>node</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>node_alloc_.m_.next_<sp/>is<sp/>first<sp/>node</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>back_;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>RandomAccessIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_assign(RandomAccessIterator<sp/>first,<sp/>RandomAccessIterator<sp/>last,<sp/>random_access_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>static_cast&lt;size_type&gt;(first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::construction<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::construction<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>n<sp/>&gt;<sp/>0;<sp/>--n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(static_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>last;<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_back(*first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(first,<sp/>last,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>last<sp/>&amp;&amp;<sp/>i<sp/>!=<sp/>end();<sp/>++first,<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>end())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(last_node(),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ForwardIterator<sp/>f<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>c<sp/>=<sp/>size();<sp/>c<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>f<sp/>!=<sp/>last;<sp/>--c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>temp.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>first<sp/>!=<sp/>f;<sp/>++i,<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>RandomAccessIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(RandomAccessIterator<sp/>first,<sp/>RandomAccessIterator<sp/>last,<sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RandomAccessIterator<sp/>f<sp/>=<sp/>first<sp/>+<sp/>min(size(),<sp/>size_type(last<sp/>-<sp/>first));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(last<sp/>-<sp/>first<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>first<sp/>!=<sp/>f;<sp/>++i,<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(position,<sp/>static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(first,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(position,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>void<sp/>remove_nodes(node_base*<sp/>first,<sp/>node_base*<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>void<sp/>insert_nodes(node_base*<sp/>here,<sp/>node_base*<sp/>first,<sp/>node_base*<sp/>last);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>specialized<sp/>algorithms:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">swap(slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Implementation<sp/>slist</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::slist(const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>,<sp/>node_alloc_(node_allocator_type(a))</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::slist(size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(Allocator(),<sp/>0)</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>,<sp/>node_alloc_(node_allocator_type(alloc_))</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::construction<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::construction<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>value(T());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>n<sp/>&gt;<sp/>0;<sp/>--n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::slist(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>value,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>,<sp/>node_alloc_(node_allocator_type(a))</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::construction<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::construction<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>n<sp/>&gt;<sp/>0;<sp/>--n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_(node_allocator_type(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::slist(const_iterator<sp/>first,<sp/>const_iterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(first<sp/>!=<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(*first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++first;<sp/>first<sp/>!=<sp/>last;<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>insert_after(i,<sp/>*first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::slist(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(first<sp/>!=<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(*first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++first;<sp/>first<sp/>!=<sp/>last;<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>insert_after(i,<sp/>*first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::slist(const<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>alloc_(x.alloc_,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_(x.node_alloc_)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>e<sp/>=<sp/>x.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(const_iterator<sp/>i<sp/>=<sp/>x.begin();<sp/>i<sp/>!=<sp/>e;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_back(*i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::~slist()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::operator=(const<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>!=<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(x.begin(),<sp/>x.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::assign(const_iterator<sp/>first,<sp/>const_iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>f<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>c<sp/>=<sp/>size();<sp/>c<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>f<sp/>!=<sp/>last;<sp/>--c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>temp.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>f;<sp/>++first,<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(p,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::assign(const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>value_type*<sp/>f<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>c<sp/>=<sp/>size();<sp/>c<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>f<sp/>!=<sp/>last;<sp/>--c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>temp.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>f;<sp/>++first,<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(p,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::assign(size_type<sp/>n,<sp/>const<sp/>T&amp;<sp/>t)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(n<sp/>-<sp/>size(),<sp/>t,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>n<sp/>!=<sp/>0;<sp/>--n,<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::allocator_type</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::get_allocator()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::begin()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>iterator(node_alloc_.m_.next_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::begin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_iterator(node_alloc_.m_.next_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::end()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>iterator((node*)&amp;node_alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::end()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>const_iterator((node*)&amp;node_alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::last_node()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::last_node()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::previous(iterator<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>x;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>p;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::previous(const_iterator<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(const_iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>x;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>p;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::empty()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::max_size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(size_type)numeric_limits&lt;difference_type&gt;::max();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::resize(size_type<sp/>sz)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>resize(sz,<sp/>T());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::resize(size_type<sp/>sz,<sp/>const<sp/>value_type&amp;<sp/>value)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(sz<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(sz<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(last_node(),<sp/>sz-size(),<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(sz<sp/>&lt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>advance(i,<sp/>--sz);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::reference</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::front()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>node_alloc_.m_.next_-&gt;data_;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::const_reference</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::front()<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>node_alloc_.m_.next_-&gt;data_;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::push_front(const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insert_after(end(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::pop_front()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>erase_after(end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::push_back(const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insert_after(last_node(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>insert_after(previous(position),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insert_after(previous(position),<sp/>n,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(previous(position),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>const_iterator<sp/>first,<sp/>const_iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(previous(position),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(previous(position),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::insert_after<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::insert_after<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>newnode<sp/>=<sp/>node_alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.construct(&amp;newnode-&gt;data_,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.deallocate(newnode,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insert_nodes(position.node_,<sp/>newnode,<sp/>newnode);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>position.node_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>newnode;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>newnode;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>T&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist<sp/>temp(n,<sp/>x,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>splice_after(position,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_insert_after(position,<sp/>first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>const_iterator<sp/>first,<sp/>const_iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(first,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(position,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>const<sp/>value_type*<sp/>first,<sp/>const<sp/>value_type*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(first,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(position,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::erase(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>++erase_after(previous(position));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::erase(iterator<sp/>position,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>previous(position);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>k<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(++k;<sp/>k<sp/>!=<sp/>last;<sp/>k++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j<sp/>=<sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>erase_after(i,<sp/>j);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>last;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>erase<sp/>(position,<sp/>position+1]</highlight></codeline>
<codeline><highlight class="normal">//<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::erase_after(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>oldnode<sp/>=<sp/>position.node_-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>oldnode)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>position.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>remove_nodes(position.node_,<sp/>oldnode);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>alloc_.destroy(&amp;oldnode-&gt;data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node_alloc_.deallocate(oldnode,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>--alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>position;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>erase<sp/>(position,<sp/>last]</highlight></codeline>
<codeline><highlight class="normal">//<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">typename<sp/>slist&lt;T,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::erase_after(iterator<sp/>position,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(position<sp/>==<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>last.node_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>position.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>remove_nodes(position.node_,<sp/>last.node_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++last;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(i<sp/>!=<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(&amp;*i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>t<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.deallocate(t,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>position;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::swap(slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>!=<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(alloc_,<sp/>x.alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(node_alloc_,<sp/>x.node_alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(back_,<sp/>x.back_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_-&gt;next_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>tail.next_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>x_tail<sp/>=<sp/>x.node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_-&gt;next_<sp/>=<sp/>(node*)&amp;x_tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>x_tail.next_<sp/>=<sp/>(node*)&amp;x_tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::clear()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(&amp;*i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>t<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.deallocate(t,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>tail.next_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>splice_after(previous(position),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>splice_after(previous(position),<sp/>x,<sp/>x.previous(i));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>splice_after(previous(position),<sp/>x,<sp/>x.previous(first),<sp/>x.previous(last));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(x.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>x.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::splice_after<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::splice_after<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>x_tail<sp/>=<sp/>x.node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base*<sp/>s1<sp/>=<sp/>x_tail.next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base*<sp/>s2<sp/>=<sp/>x.back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>x_tail.next_<sp/>=<sp/>(node*)&amp;x_tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>x.alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(position.node_,<sp/>s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>position.node_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>(node*)s2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::splice<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::splice<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>p<sp/>=<sp/>position.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(s1<sp/>==<sp/>p<sp/>||<sp/>s2<sp/>==<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>s2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>--x.alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insert_nodes(p,<sp/>s2,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>++alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(first<sp/>==<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>!=<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>delta<sp/>=<sp/>(size_type)distance(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>delta)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::splice<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::splice<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>-=<sp/>delta;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>delta;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>first.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>s3<sp/>=<sp/>last.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>s3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>insert_nodes(position.node_,<sp/>s2,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>position.node_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s3;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::remove(const<sp/>T&amp;<sp/>value)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>p1<sp/>=<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(*i<sp/>==<sp/>value)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!(*j<sp/>==<sp/>value))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::remove_if(Predicate<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p1<sp/>=<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(pred(*i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!pred(*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::unique()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!(*i<sp/>==<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>!=<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::unique(BinaryPredicate<sp/>binary_pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!binary_pred(*i,<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>!=<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::merge(slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>x.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::merge<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::merge<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>first1<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>last1<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>first2<sp/>=<sp/>x.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>last2<sp/>=<sp/>x.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>pfirst1<sp/>=<sp/>last1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>pfirst2<sp/>=<sp/>last2.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first1<sp/>!=<sp/>last1<sp/>&amp;&amp;<sp/>first2<sp/>!=<sp/>last2;<sp/>++first1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(*first2<sp/>&lt;<sp/>*first1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>first2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>last2;<sp/>++j,<sp/>++count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!(*j<sp/>&lt;<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>splice_after(pfirst1,<sp/>x,<sp/>pfirst2,<sp/>pj)<sp/>but<sp/>with<sp/>pj-pfirst2<sp/>stored<sp/>in<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>pj)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>pfirst2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(pfirst2,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(pfirst1,<sp/>first2.node_,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>pfirst1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>pj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>-=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pfirst1<sp/>=<sp/>first1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(first2<sp/>!=<sp/>last2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>x.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::merge<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::merge<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first1<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last1<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first2<sp/>=<sp/>x.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last2<sp/>=<sp/>x.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst1<sp/>=<sp/>last1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst2<sp/>=<sp/>last2.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first1<sp/>!=<sp/>last1<sp/>&amp;&amp;<sp/>first2<sp/>!=<sp/>last2;<sp/>++first1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(comp(*first2,<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>first2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>last2;<sp/>++j,<sp/>++count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!comp(*j,<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>splice_after(pfirst1,<sp/>x,<sp/>pfirst2,<sp/>pj)<sp/>but<sp/>with<sp/>pj-pfirst2<sp/>stored<sp/>in<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>pj)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>pfirst2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(pfirst2,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(pfirst1,<sp/>first2.node_,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>pfirst1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>pj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>-=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pfirst1<sp/>=<sp/>first1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(first2<sp/>!=<sp/>last2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::sort()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>0:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>1:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>2:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(*j<sp/>&lt;<sp/>*i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>reverse()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_-&gt;next_<sp/>=<sp/>(node*)&amp;node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_-&gt;next_<sp/>=<sp/>node_alloc_.m_.next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>node_alloc_.m_.next_-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>lower_size<sp/>=<sp/>size()<sp/>/<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>advance(i,<sp/>lower_size<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>upper_half;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>upper_half.splice_after(upper_half.last_node(),<sp/>*this,<sp/>i,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s3<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(&amp;upper_half.node_alloc_.m_,<sp/>s2,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.back_<sp/>=<sp/>s3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.alloc_.m_<sp/>=<sp/>alloc_.m_<sp/>-<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.sort();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(upper_half);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::sort(Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>0:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>1:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>2:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(comp(*j,<sp/>*i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>reverse()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_-&gt;next_<sp/>=<sp/>(node*)&amp;node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_-&gt;next_<sp/>=<sp/>node_alloc_.m_.next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>node_alloc_.m_.next_-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>lower_size<sp/>=<sp/>size()<sp/>/<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>advance(i,<sp/>lower_size<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>upper_half;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>upper_half.splice_after(upper_half.last_node(),<sp/>*this,<sp/>i,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s3<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(&amp;upper_half.node_alloc_.m_,<sp/>s2,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.back_<sp/>=<sp/>s3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.alloc_.m_<sp/>=<sp/>alloc_.m_<sp/>-<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort(comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.sort(comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(upper_half,<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::reverse()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&lt;<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>np<sp/>=<sp/>(node*)&amp;node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node*<sp/>n<sp/>=<sp/>np-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(true)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>nn<sp/>=<sp/>n-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n-&gt;next_<sp/>=<sp/>np;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>==<sp/>(node*)&amp;node_alloc_.m_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>np<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>nn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>static_cast&lt;size_type&gt;(first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::construction<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::construction<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>n<sp/>&gt;<sp/>0;<sp/>--n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(static_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>last;<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_back(*first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(first,<sp/>last,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>last<sp/>&amp;&amp;<sp/>i<sp/>!=<sp/>end();<sp/>++first,<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>end())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(last_node(),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ForwardIterator<sp/>f<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>c<sp/>=<sp/>size();<sp/>c<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>f<sp/>!=<sp/>last;<sp/>--c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>temp.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>first<sp/>!=<sp/>f;<sp/>++i,<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>RandomAccessIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::do_assign(RandomAccessIterator<sp/>first,<sp/>RandomAccessIterator<sp/>last,<sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RandomAccessIterator<sp/>f<sp/>=<sp/>first<sp/>+<sp/>min(size(),<sp/>size_type(last<sp/>-<sp/>first));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(last<sp/>-<sp/>first<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>first<sp/>!=<sp/>f;<sp/>++i,<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(position,<sp/>static_cast&lt;size_type&gt;(first),<sp/>static_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T,<sp/>Allocator&gt;::do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(first,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(position,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>range<sp/>is<sp/>(first,<sp/>last]<sp/>NOT<sp/>[first,<sp/>last),<sp/>first<sp/>==<sp/>end()<sp/>ok<sp/>to<sp/>remove<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::remove_nodes(node_base*<sp/>first,<sp/>node_base*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>first-&gt;next_<sp/>=<sp/>last-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>range<sp/>is<sp/>[first,<sp/>last]<sp/>NOT<sp/>[first,<sp/>last),<sp/>nodes<sp/>inserted<sp/>AFTER<sp/>here,<sp/>here<sp/>!=<sp/>end()</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">slist&lt;T,<sp/>Allocator&gt;::insert_nodes(node_base*<sp/>here,<sp/>node_base*<sp/>first,<sp/>node_base*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>last-&gt;next_<sp/>=<sp/>here-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>here-&gt;next_<sp/>=<sp/>(node*)first;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator==(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x.size()<sp/>==<sp/>y.size()<sp/>&amp;&amp;<sp/>equal(x.begin(),<sp/>x.end(),<sp/>y.begin()));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator!=(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(x<sp/>==<sp/>y));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;<sp/>(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>lexicographical_compare(x.begin(),<sp/>x.end(),<sp/>y.begin(),<sp/>y.end());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;<sp/>(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>y<sp/>&lt;<sp/>x;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&gt;=(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(x<sp/>&lt;<sp/>y));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">bool</highlight></codeline>
<codeline><highlight class="normal">operator&lt;=(const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(y<sp/>&lt;<sp/>x));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>specialized<sp/>algorithms:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal">inline</highlight></codeline>
<codeline><highlight class="normal">void</highlight></codeline>
<codeline><highlight class="normal">swap(slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>slist&lt;T,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>x.swap(y);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#if<sp/>!defined(_MSL_NO_PARTIAL_SPECIALIZATION)<sp/>&amp;&amp;<sp/>!defined(_MSL_NO_MEMBER_TEMPLATE)<sp/>&amp;&amp;<sp/>!defined(_Inhibit_Container_Optimization)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Specialize<sp/>for<sp/>T*<sp/>to<sp/>save<sp/>on<sp/>code<sp/>bloat</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>void*</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>slist&lt;void*,<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;bool<sp/>b&gt;<sp/>struct<sp/>chooser<sp/>{};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>types:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_reference<sp/><sp/><sp/>const_reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::size_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::difference_type<sp/><sp/><sp/>difference_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>void*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>Allocator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::pointer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_pointer<sp/><sp/><sp/><sp/><sp/>const_pointer;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>struct<sp/>node;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>struct<sp/>node_base</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>struct<sp/>node</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>node_base</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type<sp/>data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::rebind&lt;node&gt;::other<sp/>node_allocator_type;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/>iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;forward_iterator_tag,<sp/>value_type,<sp/>difference_type,<sp/>pointer,<sp/>reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>node_-&gt;data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>&amp;node_-&gt;data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{node_<sp/>=<sp/>node_-&gt;next_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{iterator<sp/>tmp(*this);<sp/>node_<sp/>=<sp/>node_-&gt;next_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>==(iterator<sp/>x,<sp/>iterator<sp/>y)<sp/>{return<sp/>static_cast&lt;bool&gt;(x.node_<sp/>==<sp/>y.node_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>!=(iterator<sp/>x,<sp/>iterator<sp/>y)<sp/>{return<sp/>static_cast&lt;bool&gt;(x.node_<sp/>!=<sp/>y.node_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>node_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator(node*<sp/>node)<sp/>:<sp/>node_(node)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>slist;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>slist::const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/>const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;forward_iterator_tag,<sp/>value_type,<sp/>difference_type,<sp/>const_pointer,<sp/>const_reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(slist::iterator<sp/>x)<sp/>:<sp/>node_(x.node_)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>node_-&gt;data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>&amp;node_-&gt;data_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{node_<sp/>=<sp/>node_-&gt;next_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{const_iterator<sp/>tmp(*this);<sp/>node_<sp/>=<sp/>node_-&gt;next_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>==(const_iterator<sp/>x,<sp/>const_iterator<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{return<sp/>static_cast&lt;bool&gt;(x.node_<sp/>==<sp/>y.node_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>!=(const_iterator<sp/>x,<sp/>const_iterator<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{return<sp/>static_cast&lt;bool&gt;(x.node_<sp/>!=<sp/>y.node_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>node*<sp/>node_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(const<sp/>node*<sp/>node)<sp/>:<sp/>node_(node)<sp/>{}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>slist;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.cons<sp/>construct/copy/destroy:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>slist(const<sp/>Allocator&amp;<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>slist(size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>value,<sp/>const<sp/>Allocator&amp;<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_(node_allocator_type(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.prev_<sp/>=<sp/>tail.next_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(const<sp/>slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>~slist();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist&amp;<sp/>operator=(const<sp/>slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;<sp/>void<sp/>assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>assign(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator_type<sp/>get_allocator()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>iterators:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last_node();<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>returns<sp/>--end()<sp/>(constant<sp/>time)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last_node()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>previous(iterator<sp/>x);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>returns<sp/>--x<sp/>(linear<sp/>time)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>previous(const_iterator<sp/>x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.capacity<sp/>capacity:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/><sp/><sp/><sp/><sp/><sp/>empty()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>max_size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>resize(size_type<sp/>sz);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>resize(size_type<sp/>sz,<sp/>const<sp/>value_type&amp;<sp/>value);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>element<sp/>access:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/>front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>front()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.modifiers<sp/>modifiers:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>push_front(const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>pop_front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>push_back(const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>there<sp/>is<sp/>no<sp/>pop_back</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>insert(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>insert(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(previous(position),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>insert,<sp/>inserts<sp/>stuff<sp/>after<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>insert_after(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>insert_after(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_insert_after(position,<sp/>first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>erase(iterator<sp/>position);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>erase(iterator<sp/>position,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>erase</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>erase_after(iterator<sp/>position);<sp/>//<sp/>erase<sp/>(position,<sp/>position+1],<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>erase_after(iterator<sp/>position,<sp/>iterator<sp/>last);<sp/>//<sp/>erase<sp/>(position,<sp/>last],<sp/>return<sp/>position</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>swap(slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.ops<sp/>slist<sp/>operations:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>splice,<sp/>splices<sp/>stuff<sp/>after<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i);<sp/>//<sp/>splices<sp/>(i,<sp/>i+1]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>splices<sp/>(first,<sp/>last]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>remove(const<sp/>value_type&amp;<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;<sp/>void<sp/>remove_if(Predicate<sp/>pred);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_if(Predicate<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p1<sp/>=<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(pred(*i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!pred(*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>unique();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;<sp/>void<sp/>unique(BinaryPredicate<sp/>binary_pred);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unique(BinaryPredicate<sp/>binary_pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!binary_pred(*i,<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>!=<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>merge(slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;<sp/>void<sp/>merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>x.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::merge<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::merge<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first1<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last1<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first2<sp/>=<sp/>x.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last2<sp/>=<sp/>x.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst1<sp/>=<sp/>last1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst2<sp/>=<sp/>last2.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first1<sp/>!=<sp/>last1<sp/>&amp;&amp;<sp/>first2<sp/>!=<sp/>last2;<sp/>++first1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(comp(*first2,<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>first2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>last2;<sp/>++j,<sp/>++count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!comp(*j,<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>splice_after(pfirst1,<sp/>x,<sp/>pfirst2,<sp/>pj)<sp/>but<sp/>with<sp/>pj-pfirst2<sp/>stored<sp/>in<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>pj)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>pfirst2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(pfirst2,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(pfirst1,<sp/>first2.node_,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>pfirst1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>pj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>-=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pfirst1<sp/>=<sp/>first1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(first2<sp/>!=<sp/>last2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>sort();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;<sp/>void<sp/>sort(Compare<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort(Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>0:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>1:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>2:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(comp(*j,<sp/>*i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>reverse()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_-&gt;next_<sp/>=<sp/>(node*)&amp;node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_-&gt;next_<sp/>=<sp/>node_alloc_.m_.next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>node_alloc_.m_.next_-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>lower_size<sp/>=<sp/>size()<sp/>/<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>advance(i,<sp/>lower_size<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>upper_half;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>upper_half.splice_after(upper_half.last_node(),<sp/>*this,<sp/>i,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s3<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(&amp;upper_half.node_alloc_.m_,<sp/>s2,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.back_<sp/>=<sp/>s3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.alloc_.m_<sp/>=<sp/>alloc_.m_<sp/>-<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort(comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.sort(comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(upper_half,<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>reverse();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_EmptyMemberOpt&lt;Allocator,<sp/>size_type&gt;<sp/>alloc_;<sp/><sp/>//<sp/>alloc_.m_<sp/>is<sp/>size_</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_EmptyMemberOpt&lt;node_allocator_type,<sp/>node_base&gt;<sp/>node_alloc_;<sp/><sp/>//<sp/>node_alloc_.m_<sp/>is<sp/>tail<sp/>pseudo<sp/>node</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>node_alloc_.m_.next_<sp/>is<sp/>first<sp/>node</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>back_;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>RandomAccessIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_assign(RandomAccessIterator<sp/>first,<sp/>RandomAccessIterator<sp/>last,<sp/>random_access_iterator_tag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>static_cast&lt;size_type&gt;(first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::construction<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::construction<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>n<sp/>&gt;<sp/>0;<sp/>--n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(static_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>last;<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_back(*first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(static_cast&lt;size_type&gt;(first),<sp/>reinterpret_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(first,<sp/>last,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>last<sp/>&amp;&amp;<sp/>i<sp/>!=<sp/>end();<sp/>++first,<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>end())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(last_node(),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ForwardIterator<sp/>f<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>c<sp/>=<sp/>size();<sp/>c<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>f<sp/>!=<sp/>last;<sp/>--c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>temp.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>first<sp/>!=<sp/>f;<sp/>++i,<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>RandomAccessIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(RandomAccessIterator<sp/>first,<sp/>RandomAccessIterator<sp/>last,<sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RandomAccessIterator<sp/>f<sp/>=<sp/>first<sp/>+<sp/>min(size(),<sp/>size_type(last<sp/>-<sp/>first));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(last<sp/>-<sp/>first<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>first<sp/>!=<sp/>f;<sp/>++i,<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(position,<sp/>static_cast&lt;size_type&gt;(first),<sp/>reinterpret_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(first,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(position,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>void<sp/>remove_nodes(node_base*<sp/>first,<sp/>node_base*<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>void<sp/>insert_nodes(node_base*<sp/>here,<sp/>node_base*<sp/>first,<sp/>node_base*<sp/>last);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Implementation<sp/>slist&lt;void*&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::slist(const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>node_alloc_(node_allocator_type(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::slist(size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(Allocator(),<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>node_alloc_(node_allocator_type(alloc_))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::construction<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::construction<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type<sp/>value(value_type());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>n<sp/>&gt;<sp/>0;<sp/>--n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::slist(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>value,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>,<sp/>node_alloc_(node_allocator_type(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::construction<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::construction<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>n<sp/>&gt;<sp/>0;<sp/>--n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(a,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_(node_allocator_type(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_init(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::slist(const<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>alloc_(x.alloc_,<sp/>0),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_(x.node_alloc_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tail.next_<sp/>=<sp/>back_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>e<sp/>=<sp/>x.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(const_iterator<sp/>i<sp/>=<sp/>x.begin();<sp/>i<sp/>!=<sp/>e;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_back(*i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::~slist()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::operator=(const<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>!=<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(x.begin(),<sp/>x.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>*this;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>choose_assign(first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::assign(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>t)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(n<sp/>-<sp/>size(),<sp/>t,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>end();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>n<sp/>!=<sp/>0;<sp/>--n,<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::allocator_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::get_allocator()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>alloc_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(node_alloc_.m_.next_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::begin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_iterator(node_alloc_.m_.next_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::end()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator((node*)&amp;node_alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::end()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_iterator((node*)&amp;node_alloc_.m_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::last_node()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::last_node()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::previous(iterator<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>x;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::previous(const_iterator<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(const_iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>x;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::empty()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::max_size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>(size_type)numeric_limits&lt;difference_type&gt;::max();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::resize(size_type<sp/>sz)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resize(sz,<sp/>value_type());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::resize(size_type<sp/>sz,<sp/>const<sp/>value_type&amp;<sp/>value)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(sz<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(sz<sp/>&gt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(last_node(),<sp/>sz-size(),<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(sz<sp/>&lt;<sp/>size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>advance(i,<sp/>--sz);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::reference</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::front()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>node_alloc_.m_.next_-&gt;data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::const_reference</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::front()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>node_alloc_.m_.next_-&gt;data_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::push_front(const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(end(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::pop_front()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::push_back(const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(last_node(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>insert_after(previous(position),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(previous(position),<sp/>n,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(previous(position),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::insert_after<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::insert_after<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>newnode<sp/>=<sp/>node_alloc_.allocate(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.construct(&amp;newnode-&gt;data_,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.deallocate(newnode,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(position.node_,<sp/>newnode,<sp/>newnode);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>position.node_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>newnode;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>newnode;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(n,<sp/>x,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(position,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_insert_after(position,<sp/>first,<sp/>last,<sp/>chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::erase(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>++erase_after(previous(position));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::erase(iterator<sp/>position,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>previous(position);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>k<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++k;<sp/>k<sp/>!=<sp/>last;<sp/>k++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>j<sp/>=<sp/>k;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>j);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>last;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>erase<sp/>(position,<sp/>position+1]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::erase_after(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>oldnode<sp/>=<sp/>position.node_-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>oldnode)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>position.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(position.node_,<sp/>oldnode);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(&amp;oldnode-&gt;data_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.deallocate(oldnode,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>erase<sp/>(position,<sp/>last]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;void*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::erase_after(iterator<sp/>position,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(position<sp/>==<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>last.node_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>position.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(position.node_,<sp/>last.node_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++last;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(i<sp/>!=<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(&amp;*i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>t<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.deallocate(t,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>position;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::swap(slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>!=<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(alloc_,<sp/>x.alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(node_alloc_,<sp/>x.node_alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_STD::swap(back_,<sp/>x.back_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_-&gt;next_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>tail.next_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>x_tail<sp/>=<sp/>x.node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_-&gt;next_<sp/>=<sp/>(node*)&amp;x_tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>x_tail.next_<sp/>=<sp/>(node*)&amp;x_tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::clear()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(alloc_.m_<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.destroy(&amp;*i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>t<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.deallocate(t,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>tail<sp/>=<sp/>node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>tail.next_<sp/>=<sp/>(node*)&amp;tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(previous(position),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(previous(position),<sp/>x,<sp/>x.previous(i));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(previous(position),<sp/>x,<sp/>x.previous(first),<sp/>x.previous(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>x.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::splice_after<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::splice_after<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base&amp;<sp/>x_tail<sp/>=<sp/>x.node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base*<sp/>s1<sp/>=<sp/>x_tail.next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_base*<sp/>s2<sp/>=<sp/>x.back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>x_tail.next_<sp/>=<sp/>(node*)&amp;x_tail;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>x.alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(position.node_,<sp/>s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>position.node_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>(node*)s2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::splice<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::splice<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>p<sp/>=<sp/>position.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(s1<sp/>==<sp/>p<sp/>||<sp/>s2<sp/>==<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>s2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--x.alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(p,<sp/>s2,<sp/>s2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(first<sp/>==<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>!=<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>delta<sp/>=<sp/>(size_type)distance(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>delta)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::splice<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::splice<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>-=<sp/>delta;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>delta;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>first.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s3<sp/>=<sp/>last.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>s3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(position.node_,<sp/>s2,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>position.node_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::remove(const<sp/>value_type&amp;<sp/>value)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p1<sp/>=<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(*i<sp/>==<sp/>value)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!(*j<sp/>==<sp/>value))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::remove_if(Predicate<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p1<sp/>=<sp/>e;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(pred(*i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!pred(*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p1,<sp/>p2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>e)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p1<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::unique()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!(*i<sp/>==<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>!=<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::unique(BinaryPredicate<sp/>binary_pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>e<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>i<sp/>!=<sp/>e;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>e;<sp/>++j)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!binary_pred(*i,<sp/>*j))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>!=<sp/>p)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(i,<sp/>p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::merge(slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>x.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::merge<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::merge<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first1<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last1<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first2<sp/>=<sp/>x.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last2<sp/>=<sp/>x.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst1<sp/>=<sp/>last1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst2<sp/>=<sp/>last2.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first1<sp/>!=<sp/>last1<sp/>&amp;&amp;<sp/>first2<sp/>!=<sp/>last2;<sp/>++first1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(*first2<sp/>&lt;<sp/>*first1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>first2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>last2;<sp/>++j,<sp/>++count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!(*j<sp/>&lt;<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>splice_after(pfirst1,<sp/>x,<sp/>pfirst2,<sp/>pj)<sp/>but<sp/>with<sp/>pj-pfirst2<sp/>stored<sp/>in<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>pj)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>pfirst2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(pfirst2,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(pfirst1,<sp/>first2.node_,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>pfirst1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>pj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>-=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pfirst1<sp/>=<sp/>first1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(first2<sp/>!=<sp/>last2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(this<sp/>==<sp/>&amp;x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>x.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::merge<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::merge<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first1<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last1<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>first2<sp/>=<sp/>x.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>last2<sp/>=<sp/>x.end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst1<sp/>=<sp/>last1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pfirst2<sp/>=<sp/>last2.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first1<sp/>!=<sp/>last1<sp/>&amp;&amp;<sp/>first2<sp/>!=<sp/>last2;<sp/>++first1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(comp(*first2,<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>first2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(++j;<sp/>j<sp/>!=<sp/>last2;<sp/>++j,<sp/>++count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!comp(*j,<sp/>*first1))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pj<sp/>=<sp/>j.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>splice_after(pfirst1,<sp/>x,<sp/>pfirst2,<sp/>pj)<sp/>but<sp/>with<sp/>pj-pfirst2<sp/>stored<sp/>in<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(x.back_<sp/>==<sp/>pj)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.back_<sp/>=<sp/>pfirst2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(pfirst2,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(pfirst1,<sp/>first2.node_,<sp/>pj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(back_<sp/>==<sp/>pfirst1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>pj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.alloc_.m_<sp/>-=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>+=<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first2<sp/>=<sp/>j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pfirst1<sp/>=<sp/>first1.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(first2<sp/>!=<sp/>last2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::sort()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>0:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>1:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>2:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(*j<sp/>&lt;<sp/>*i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>reverse()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_-&gt;next_<sp/>=<sp/>(node*)&amp;node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_-&gt;next_<sp/>=<sp/>node_alloc_.m_.next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>node_alloc_.m_.next_-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>lower_size<sp/>=<sp/>size()<sp/>/<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>advance(i,<sp/>lower_size<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>upper_half;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>upper_half.splice_after(upper_half.last_node(),<sp/>*this,<sp/>i,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s3<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(&amp;upper_half.node_alloc_.m_,<sp/>s2,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.back_<sp/>=<sp/>s3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.alloc_.m_<sp/>=<sp/>alloc_.m_<sp/>-<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.sort();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(upper_half);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::sort(Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>switch<sp/>(size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>0:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>1:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>2:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>j<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++j;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(comp(*j,<sp/>*i))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/>//<sp/>reverse()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_-&gt;next_<sp/>=<sp/>(node*)&amp;node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_-&gt;next_<sp/>=<sp/>node_alloc_.m_.next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_alloc_.m_.next_<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>node_alloc_.m_.next_-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>default:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>lower_size<sp/>=<sp/>size()<sp/>/<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>advance(i,<sp/>lower_size<sp/>-<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>upper_half;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>upper_half.splice_after(upper_half.last_node(),<sp/>*this,<sp/>i,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s1<sp/>=<sp/>i.node_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s2<sp/>=<sp/>s1-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>s3<sp/>=<sp/>back_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>s1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_nodes(s1,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_nodes(&amp;upper_half.node_alloc_.m_,<sp/>s2,<sp/>s3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.back_<sp/>=<sp/>s3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.alloc_.m_<sp/>=<sp/>alloc_.m_<sp/>-<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc_.m_<sp/>=<sp/>lower_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort(comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>upper_half.sort(comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(upper_half,<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::reverse()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&lt;<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>np<sp/>=<sp/>(node*)&amp;node_alloc_.m_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>n<sp/>=<sp/>np-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>back_<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(true)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node*<sp/>nn<sp/>=<sp/>n-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n-&gt;next_<sp/>=<sp/>np;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>==<sp/>(node*)&amp;node_alloc_.m_)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>np<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>=<sp/>nn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>n<sp/>=<sp/>static_cast&lt;size_type&gt;(first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(n<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::construction<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::construction<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>n<sp/>&gt;<sp/>0;<sp/>--n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_front(reinterpret_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::choose_init(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>last;<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>push_back(*first);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(...)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(static_cast&lt;size_type&gt;(first),<sp/>reinterpret_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::choose_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_assign(first,<sp/>last,<sp/>iterator_traits&lt;InputIterator&gt;::iterator_category());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::do_assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>input_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>i<sp/>=<sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>first<sp/>!=<sp/>last<sp/>&amp;&amp;<sp/>i<sp/>!=<sp/>end();<sp/>++first,<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(i<sp/>==<sp/>end())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(last_node(),<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>ForwardIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::do_assign(ForwardIterator<sp/>first,<sp/>ForwardIterator<sp/>last,<sp/>forward_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ForwardIterator<sp/>f<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_type<sp/>c<sp/>=<sp/>size();<sp/>c<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>f<sp/>!=<sp/>last;<sp/>--c)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(size()<sp/>&gt;<sp/>max_size()<sp/>-<sp/>temp.size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>first<sp/>!=<sp/>f;<sp/>++i,<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>RandomAccessIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::do_assign(RandomAccessIterator<sp/>first,<sp/>RandomAccessIterator<sp/>last,<sp/>random_access_iterator_tag)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RandomAccessIterator<sp/>f<sp/>=<sp/>first<sp/>+<sp/>min(size(),<sp/>size_type(last<sp/>-<sp/>first));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(last<sp/>-<sp/>first<sp/>&gt;<sp/>max_size())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_NO_EXCEPTIONS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>length_error(&quot;slist::assign<sp/>length<sp/>error&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__msl_error(&quot;slist::assign<sp/>length<sp/>error\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(f,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>p<sp/>=<sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(iterator<sp/>i<sp/>=<sp/>begin();<sp/>first<sp/>!=<sp/>f;<sp/>++i,<sp/>++first)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*i<sp/>=<sp/>*first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>i;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(temp.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(last_node(),<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>erase_after(p,<sp/>last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;true&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>insert_after(position,<sp/>static_cast&lt;size_type&gt;(first),<sp/>reinterpret_cast&lt;value_type&gt;(last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::do_insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>chooser&lt;false&gt;)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist<sp/>temp(first,<sp/>last,<sp/>alloc_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splice_after(position,<sp/>temp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>range<sp/>is<sp/>(first,<sp/>last]<sp/>NOT<sp/>[first,<sp/>last),<sp/>first<sp/>==<sp/>end()<sp/>ok<sp/>to<sp/>remove<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::remove_nodes(node_base*<sp/>first,<sp/>node_base*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first-&gt;next_<sp/>=<sp/>last-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>range<sp/>is<sp/>[first,<sp/>last]<sp/>NOT<sp/>[first,<sp/>last),<sp/>nodes<sp/>inserted<sp/>AFTER<sp/>here,<sp/>here<sp/>!=<sp/>end()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;void*,<sp/>Allocator&gt;::insert_nodes(node_base*<sp/>here,<sp/>node_base*<sp/>first,<sp/>node_base*<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last-&gt;next_<sp/>=<sp/>here-&gt;next_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>here-&gt;next_<sp/>=<sp/>(node*)first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator==(const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x.size()<sp/>==<sp/>y.size()<sp/>&amp;&amp;<sp/>equal(x.begin(),<sp/>x.end(),<sp/>y.begin()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator!=(const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(x<sp/>==<sp/>y));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator&lt;<sp/>(const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>lexicographical_compare(x.begin(),<sp/>x.end(),<sp/>y.begin(),<sp/>y.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator&gt;<sp/>(const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>y<sp/>&lt;<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator&gt;=(const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(x<sp/>&lt;<sp/>y));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator&lt;=(const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(y<sp/>&lt;<sp/>x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>specialized<sp/>algorithms:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>swap(slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>slist&lt;void*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.swap(y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>T*</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>class<sp/>slist&lt;T*,<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>private<sp/>slist&lt;void*,<sp/>Allocator::rebind&lt;void*&gt;::other&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>slist&lt;void*,<sp/>Allocator::rebind&lt;void*&gt;::other&gt;<sp/>base;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>base::allocator_type<sp/>base_allocator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>types:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_reference<sp/><sp/><sp/>const_reference;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::size_type<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::difference_type<sp/><sp/><sp/>difference_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>T*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>Allocator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::pointer<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typedef<sp/>typename<sp/>Allocator::const_pointer<sp/><sp/><sp/><sp/><sp/>const_pointer;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/>iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;bidirectional_iterator_tag,<sp/>value_type,<sp/>difference_type,<sp/>pointer,<sp/>reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>iterator(const<sp/>base::iterator&amp;<sp/>i)<sp/>:<sp/>i_(i)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator<sp/>base::iterator()<sp/>const<sp/>{return<sp/>i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>reference(*i_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>pointer(i_.operator-&gt;());}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{++i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{iterator<sp/>tmp(*this);<sp/>++i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator<sp/>--<sp/>()<sp/>{--i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator<sp/>--<sp/>(int)<sp/>{iterator<sp/>tmp(*this);<sp/>--i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>==(const<sp/>iterator&amp;<sp/>x,<sp/>const<sp/>iterator&amp;<sp/>y)<sp/>{return<sp/>x.i_<sp/>==<sp/>y.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>!=(const<sp/>iterator&amp;<sp/>x,<sp/>const<sp/>iterator&amp;<sp/>y)<sp/>{return<sp/>x.i_<sp/>!=<sp/>y.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::iterator<sp/>i_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>class<sp/>slist::const_iterator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/>const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>public<sp/>_STD::iterator&lt;bidirectional_iterator_tag,<sp/>value_type,<sp/>difference_type,<sp/>const_pointer,<sp/>const_reference&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(const<sp/>slist::iterator&amp;<sp/>x)<sp/>:<sp/>i_(x.i_)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>const_iterator(const<sp/>base::const_iterator&amp;<sp/>i)<sp/>:<sp/>i_(i)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>operator<sp/>base::const_iterator()<sp/>const<sp/>{return<sp/>i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>operator<sp/>*<sp/>()<sp/>const<sp/>{return<sp/>const_reference(*i_);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_pointer<sp/>operator<sp/>-&gt;<sp/>()<sp/>const<sp/>{return<sp/>const_pointer(i_.operator-&gt;());}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator<sp/>++<sp/>()<sp/>{++i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator<sp/>++<sp/>(int)<sp/>{const_iterator<sp/>tmp(*this);<sp/>++i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator<sp/>--<sp/>()<sp/>{--i_;<sp/>return<sp/>*this;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator<sp/>--<sp/>(int)<sp/>{const_iterator<sp/>tmp(*this);<sp/>--i_;<sp/>return<sp/>tmp;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>==(const<sp/>const_iterator&amp;<sp/>x,<sp/>const<sp/>const_iterator&amp;<sp/>y)<sp/>{return<sp/>x.i_<sp/>==<sp/>y.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>friend<sp/>bool<sp/>operator<sp/>!=(const<sp/>const_iterator&amp;<sp/>x,<sp/>const<sp/>const_iterator&amp;<sp/>y)<sp/>{return<sp/>x.i_<sp/>!=<sp/>y.i_;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::const_iterator<sp/>i_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.cons<sp/>construct/copy/destroy:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>slist(const<sp/>Allocator&amp;<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>explicit<sp/>slist(size_type<sp/>n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>value,<sp/>const<sp/>Allocator&amp;<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;<sp/>void<sp/>assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a<sp/>=<sp/>Allocator())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>base(first,<sp/>last,<sp/>base_allocator(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::assign(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>assign(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator_type<sp/>get_allocator()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>iterators:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>begin()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>end()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last_node();<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>returns<sp/>--end()<sp/>(constant<sp/>time)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last_node()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>previous(iterator<sp/>x);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>returns<sp/>--x<sp/>(linear<sp/>time)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>previous(const_iterator<sp/>x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.capacity<sp/>capacity:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/><sp/><sp/><sp/><sp/><sp/>empty()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_type<sp/>max_size()<sp/>const;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>resize(size_type<sp/>sz);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/><sp/>resize(size_type<sp/>sz,<sp/>const<sp/>value_type&amp;<sp/>value);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>element<sp/>access:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reference<sp/><sp/><sp/><sp/><sp/><sp/><sp/>front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reference<sp/>front()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.modifiers<sp/>modifiers:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>push_front(const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>pop_front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>push_back(const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>there<sp/>is<sp/>no<sp/>pop_back</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>insert(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>insert(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::insert(position,<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>insert,<sp/>inserts<sp/>stuff<sp/>after<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>insert_after(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>insert_after(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::insert_after(position,<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>erase(iterator<sp/>position);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>erase(iterator<sp/>position,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>erase</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>erase_after(iterator<sp/>position);<sp/>//<sp/>erase<sp/>(position,<sp/>position+1],<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>erase_after(iterator<sp/>position,<sp/>iterator<sp/>last);<sp/>//<sp/>erase<sp/>(position,<sp/>last],<sp/>return<sp/>position</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>swap(slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/><sp/><sp/><sp/><sp/>clear();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>lib.slist.ops<sp/>slist<sp/>operations:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>linear<sp/>time!</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>constant<sp/>time<sp/>versions<sp/>of<sp/>splice,<sp/>splices<sp/>stuff<sp/>after<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>end()<sp/>can<sp/>be<sp/>used<sp/>as<sp/>the<sp/>node<sp/>before<sp/>begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i);<sp/>//<sp/>splices<sp/>(i,<sp/>i+1]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last);<sp/><sp/>//<sp/>splices<sp/>(first,<sp/>last]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>remove(const<sp/>value_type&amp;<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;<sp/>void<sp/>remove_if(Predicate<sp/>pred);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>remove_if(Predicate<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::remove_if(unary_convert&lt;Predicate&gt;(pred));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>unique();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;<sp/>void<sp/>unique(BinaryPredicate<sp/>binary_pred);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unique(BinaryPredicate<sp/>binary_pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::unique(binary_convert&lt;BinaryPredicate&gt;(binary_pred));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>merge(slist&amp;<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;<sp/>void<sp/>merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::merge((base&amp;)x,<sp/>binary_convert&lt;Compare&gt;(comp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>sort();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;<sp/>void<sp/>sort(Compare<sp/>comp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sort(Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::sort(binary_convert&lt;Compare&gt;(comp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>reverse();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/>unary_convert</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unary_convert(Compare<sp/>comp)<sp/>:<sp/>comp_(comp)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator()<sp/>(void*<sp/>x)<sp/>{return<sp/>comp_((T*)x);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Compare<sp/>comp_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>class<sp/>binary_convert</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>binary_convert(Compare<sp/>comp)<sp/>:<sp/>comp_(comp)<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>operator()<sp/>(void*<sp/>x,<sp/>void*<sp/>y)<sp/>{return<sp/>comp_((T*)x,<sp/>(T*)y);}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Compare<sp/>comp_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Implementation<sp/>slist&lt;T*&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::slist(const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>base(base_allocator(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::slist(size_type<sp/>n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>base(n)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::slist(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>value,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>base(n,<sp/>value,<sp/>base_allocator(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::slist(InputIterator<sp/>first,<sp/>InputIterator<sp/>last,<sp/>const<sp/>Allocator&amp;<sp/>a)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>base(first,<sp/>last,<sp/>base_allocator(a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::assign(InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::assign(first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::assign(size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>t)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::assign(n,<sp/>t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::allocator_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::get_allocator()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>base::get_allocator();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::begin()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::begin()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_iterator(base::begin());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::end()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::end()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_iterator(base::end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::last_node()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::last_node()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_iterator(base::last_node());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::previous(iterator<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::previous(x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::const_iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::previous(const_iterator<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_iterator(base::previous(x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::empty()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>base::empty();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/><sp/>base::size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::size_type</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::max_size()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/><sp/>base::max_size();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::resize(size_type<sp/>sz)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::resize(sz);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::resize(size_type<sp/>sz,<sp/>const<sp/>value_type&amp;<sp/>value)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::resize(sz,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::reference</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::front()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>reference(base::front());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::const_reference</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::front()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>const_reference(base::front());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::push_front(const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::push_front(x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::pop_front()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::pop_front();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::push_back(const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::push_back(x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::insert(position,<sp/>x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::insert(position,<sp/>n,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::insert(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::insert(position,<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::insert_after(position,<sp/>x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>size_type<sp/>n,<sp/>const<sp/>value_type&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::insert_after(position,<sp/>n,<sp/>x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>InputIterator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::insert_after(iterator<sp/>position,<sp/>InputIterator<sp/>first,<sp/>InputIterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::insert_after(position,<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::erase(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::erase(position));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::erase(iterator<sp/>position,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::erase(position,<sp/>last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>erase<sp/>(position,<sp/>position+1]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::erase_after(iterator<sp/>position)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::erase_after(position));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>erase<sp/>(position,<sp/>last]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>return<sp/>position</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>slist&lt;T*,<sp/>Allocator&gt;::iterator</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::erase_after(iterator<sp/>position,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>iterator(base::erase_after(position,<sp/>last));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::swap(slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::swap((base&amp;)x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::clear()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::clear();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::splice(position,<sp/>(base&amp;)x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::splice(position,<sp/>(base&amp;)x,<sp/>i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::splice(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::splice(position,<sp/>(base&amp;)x,<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::splice_after(position,<sp/>(base&amp;)x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::splice_after(position,<sp/>(base&amp;)x,<sp/>i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::splice_after(iterator<sp/>position,<sp/>slist&amp;<sp/>x,<sp/>iterator<sp/>first,<sp/>iterator<sp/>last)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::splice_after(position,<sp/>(base&amp;)x,<sp/>first,<sp/>last);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::remove(const<sp/>value_type&amp;<sp/>value)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::remove(value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Predicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::remove_if(Predicate<sp/>pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::remove_if(unary_convert&lt;Predicate&gt;(pred));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::unique()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::unique();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>BinaryPredicate&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::unique(BinaryPredicate<sp/>binary_pred)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::unique(binary_convert&lt;BinaryPredicate&gt;(binary_pred));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::merge(slist&amp;<sp/>x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::merge((base&amp;)x);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::merge(slist&amp;<sp/>x,<sp/>Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::merge((base&amp;)x,<sp/>binary_convert&lt;Compare&gt;(comp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::sort()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::sort();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_MUST_INLINE_MEMBER_TEMPLATE</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>Compare&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::sort(Compare<sp/>comp)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::sort(binary_convert&lt;Compare&gt;(comp));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>slist&lt;T*,<sp/>Allocator&gt;::reverse()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base::reverse();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator==(const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(x.size()<sp/>==<sp/>y.size()<sp/>&amp;&amp;<sp/>equal(x.begin(),<sp/>x.end(),<sp/>y.begin()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator!=(const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(x<sp/>==<sp/>y));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator&lt;<sp/>(const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>lexicographical_compare(x.begin(),<sp/>x.end(),<sp/>y.begin(),<sp/>y.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator&gt;<sp/>(const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>y<sp/>&lt;<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator&gt;=(const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(x<sp/>&lt;<sp/>y));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>operator&lt;=(const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>const<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;bool&gt;(!(y<sp/>&lt;<sp/>x));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>specialized<sp/>algorithms:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>template<sp/>&lt;class<sp/>T,<sp/>class<sp/>Allocator&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>inline</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>swap(slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>x,<sp/>slist&lt;T*,<sp/>Allocator&gt;&amp;<sp/>y)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.swap(y);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>!defined(_MSL_NO_PARTIAL_SPECIALIZATION)<sp/>&amp;&amp;<sp/>!defined(_MSL_NO_MEMBER_TEMPLATE)<sp/>&amp;&amp;<sp/>!defined(_Inhibit_Container_Optimization)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#ifndef<sp/>_MSL_NO_CPP_NAMESPACE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>//<sp/>namespace<sp/>std</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#if<sp/>defined(__CFM68K__)<sp/>&amp;&amp;<sp/>!defined(__USING_STATIC_LIBS__)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>#pragma<sp/>import<sp/>reset</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>options<sp/>align=reset</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>RC_INVOKED</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif<sp/>//<sp/>_SLIST</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>hh<sp/>990629<sp/>Rewrote</highlight></codeline>
    </programlisting>
    <location file="decomp/CodeWarrior/PowerPC_EABI_Support/Msl/MSL_C++/MSL_Common/Include/slist"/>
  </compounddef>
</doxygen>
