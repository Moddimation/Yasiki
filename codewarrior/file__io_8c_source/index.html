<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File file_io.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-file_ioc">File file_io.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_30eb297d72d9bf6e37ae97b245365a16/"><strong>MSL_C</strong></a> <strong>&gt;</strong> <a href="../dir_5ff331ae3d8ec7992933a87ab898fc05/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_296ea1c022f8cfa02577b9a5b06211f5/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../file__io_8c/"><strong>file_io.c</strong></a></p>
<p><a href="../file__io_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/03/09 17:16:22 $ 
 *  $Revision: 1.10 $ 
 *  $NoKeywords: $ 
 *
 *      Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/*
 *  file_io.c
 *  
 *  Routines
 *  --------
 *      remove
 *      rename
 *      tmpnam
 *      tmpfile
 *      fclose
 *      fflush
 *      fopen
 *      freopen
 *
 *      __handle_reopen
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;ansi_files.h&quot;
#include &quot;buffer_io.h&quot;
#include &quot;critical_regions.h&quot;
#include &quot;file_io.h&quot;
#include &quot;misc_io.h&quot;

#if (__dest_os  == __win32_os  || __dest_os == __wince_os)
    #include &lt;ThreadLocalData.h&gt;
#endif

#ifndef _No_Disk_File_OS_Support

/*
hh  971206  Moved __temp_file_mode to get it into ::
*/
__file_modes    __temp_file_mode = 
#ifndef __NO_WIDE_CHAR                      /* mm 980707 */
            {__create_or_truncate, __read_write, _IOFBF, __disk_file, __unoriented, 1};
#else
            {__create_or_truncate, __read_write, _IOFBF, __disk_file, 1};
#endif /* not __NO_WIDE_CHAR */             /* mm 980707 */

int remove(const char * name)
{
    return((__delete_file(name) == __no_io_error) ? 0 : -1);
}

#if __dest_os != __be_os  /*  bds 990121 */
/* beos has its own version of this funtion  bds */
int rename(const char * old_name, const char * new_name)
{
    return((__rename_file(old_name, new_name) == __no_io_error) ? 0 : -1);
}
#endif

char * tmpnam(char * name)
{
    __tls static char temp_name[L_tmpnam];

    if (name)
    {
        __temp_file_name(name, NULL);
        return(name);
    }
    else
    {
    /* 961219 KO */
#if _MWMT &amp;&amp; (__dest_os == __win32_os || __dest_os  == __wince_os)
        __temp_file_name(_GetThreadLocalData()-&gt;tmpnam_temp_name, NULL);
        return(_GetThreadLocalData()-&gt;tmpnam_temp_name);
#else
        __temp_file_name(temp_name, NULL);
        return(temp_name);
#endif
    }
}

FILE * tmpfile(void)
{
    FILE *  file;

    __stdio_atexit();

    __begin_critical_region(files_access);

    if ((file = __find_unopened_file()) != 0)
    {   
        __init_file(file, __temp_file_mode, 0, BUFSIZ);

        if (__open_temp_file(&amp;file-&gt;handle))
        {
            file-&gt;mode.file_kind = __closed_file;
            file = NULL;        
        }
    }

    __end_critical_region(files_access);

    return(file);
}

#endif /* ndef _No_Disk_File_OS_Support */

int fclose(FILE * file)
{
    int flush_result, close_result;

    if (file == NULL)               /* MM-960625 */
        return(EOF);                /* MM-960625 */
    if (file-&gt;mode.file_kind == __closed_file)
        return(0);

    flush_result = fflush(file);

    close_result = (*file-&gt;close_proc)(file-&gt;handle);

    file-&gt;mode.file_kind = __closed_file;
    file-&gt;handle         = 0;

    if (file-&gt;state.free_buffer)
#ifndef _No_Disk_File_OS_Support
        free(file-&gt;buffer);
#else
        return(-1);
#endif

    return((flush_result || close_result) ? EOF : 0);
}

#ifndef __m56800__      /* mm 981029 */
int fflush(FILE * file)
{
    fpos_t  position;                    /* mm 970708 */

    if (!file)
        return(__flush_all());

    if (file-&gt;state.error || file-&gt;mode.file_kind == __closed_file)
        return(EOF);

    if (file-&gt;mode.io_mode == __read)       /* mm 980430 */
        return 0;                           /* mm 980430 */

    if (file-&gt;state.io_state &gt;= __rereading)
        file-&gt;state.io_state = __reading;

    if (file-&gt;state.io_state == __reading)
        file-&gt;buffer_len = 0;

    if (file-&gt;state.io_state != __writing)
    {
        file-&gt;state.io_state = __neutral;  /* mm 970905 */
        return(0);
    }

#ifndef _No_Disk_File_OS_Support
    if (file-&gt;mode.file_kind != __disk_file || (position = ftell(file)) &lt; 0)
        position = 0;
#else
    position = 0;
#endif

    if (__flush_buffer(file, NULL))
    {
        set_error(file);
        return(EOF);
    }

    file-&gt;state.io_state = __neutral;
    file-&gt;position       = position;
    file-&gt;buffer_len     = 0;

    return(0);
}

#endif /* #ifndef __m56800__ */        /* mm 981029 */

#ifndef _No_Disk_File_OS_Support

FILE * fopen(const char * name, const char * mode)
{
    FILE * file;

    __begin_critical_region(files_access);

    file = freopen(name, mode, __find_unopened_file());

    __end_critical_region(files_access);

    return(file);
}

FILE * freopen(const char * name, const char * mode, FILE * file)
{
    __file_modes    modes;

    __stdio_atexit();

    if (!file)
        return(NULL);

    fclose(file);
    clearerr(file);

    if (!__get_file_modes(mode, &amp;modes))
        return(NULL);

    __init_file(file, modes, 0, BUFSIZ);

    if (__open_file(name, modes, &amp;file-&gt;handle))
    {
        file-&gt;mode.file_kind = __closed_file;
        if (file-&gt;state.free_buffer)       /* mm-960719 */
            free(file-&gt;buffer);            /* mm-960719 */
        return(NULL);
    }
    if (modes.io_mode &amp; __append)           /* mm 990119 */
        fseek(file, 0, SEEK_END);           /* mm 990119 */

    return(file);
}

FILE * __handle_open(__file_handle handle, const char * mode)
{
    FILE * file;

    __begin_critical_region(files_access);

    file = __handle_reopen(handle, mode, __find_unopened_file());

    __end_critical_region(files_access);

    return(file);
}

FILE * __handle_reopen(__file_handle handle, const char * mode, FILE * file)
{
    __file_modes    modes;

    __stdio_atexit();

    if (!file)
        return(NULL);

    fclose(file);
    clearerr(file);

    if (!__get_file_modes(mode, &amp;modes))
        return(NULL);

    __init_file(file, modes, 0, BUFSIZ);

    file-&gt;handle = handle;

    return(file);
}

int __get_file_modes(const char * mode, __file_modes * modes)
{
    const char *    mode_ptr = mode;
    unsigned long   mode_str;
    unsigned char   open_mode, io_mode;

    modes-&gt;file_kind = __disk_file;
#ifndef __NO_WIDE_CHAR                      /* mm 980204 */
    modes-&gt;file_orientation = __unoriented;
#endif /* not __NO_WIDE_CHAR */             /* mm 980204 */
    modes-&gt;binary_io = 0;

    mode_str = *mode_ptr++;

    switch (mode_str)
    {
        case 'r':
            open_mode = __must_exist;
            break;

        case 'w':
            open_mode = __create_or_truncate;
            break;

        case 'a':
            open_mode = __create_if_necessary;
            break;

        default:
            return(0);
    }

    modes-&gt;open_mode = open_mode;

    switch (*mode_ptr++)
    {
        case 'b':
            modes-&gt;binary_io = 1;

            if (*mode_ptr == '+')
                mode_str = (mode_str &lt;&lt; 8) | '+';

            break;

        case '+':
            mode_str = (mode_str &lt;&lt; 8) | '+';

            if (*mode_ptr == 'b')
                modes-&gt;binary_io = 1;

            break;
    }

    switch (mode_str)
    {
        case 'r':
            io_mode = __read;
            break;

        case 'w':
            io_mode = __write;
            break;

        case 'a':
            io_mode = __write | __append;
            break;

        case 'r+':
            io_mode = __read_write;
            break;

        case 'w+':
            io_mode = __read_write;
            break;

        case 'a+':
            io_mode = __read_write | __append;
            break;
    }

    modes-&gt;io_mode = io_mode;

    return(1);
}

#endif /* ndef _No_Disk_File_OS_Support */

void __set_idle_proc(FILE * file, __idle_proc idle_proc)
{
    file-&gt;idle_proc = idle_proc;
}

/*  Change Record
 *  14-Aug-95 JFH  First code release.
 *  16-Oct-95 JFH  Modified fflush to flush read buffers for SIOUX
 *  13-Dec-95 JFH  Added idle_proc to FILE and __set_idle_proc(). Intended primarily for Mac I/O
 *                               (see file_io.mac.c).
 *  19-Feb-96 JFH  Added closed-file check to fflush.
 *  25-Apr-96 JFH  Modified fflush to account for multi-level 'ungetc'.
 *  29-Apr-96 JFH  Merged Win32 changes in.
 *                      CTV
 *  96-Jun-25 MM   Added code to avoid bus error in fclose with null file pointer
 *  96-Jul-19 MM   Added code to prevent memory leak in freopen
 *  19-Dec-96 KO    Added some Win32 ifdefs to use my thread local data structure rather
 *                  than static local variables.
 *  961228    bobk line 135 added for clean exits on win32
 *  11-Jul-97 SCM  Wrapped os-dependent functions in #ifndef __no_os.
 *  20-Jul-97 MEA  Changed __no_os to _No_Disk_File_OS_Support.
 * mm 970708  Inserted Be changes
 * mm 970905  Correction to mark file as _neutral when flushed in other than _writing mode.
 * mm 980204  Changes to support wide characters
 * mm 980430  The Standard does not define any action for fflush on a file opened in read only mode so do
 *            nothing.  MW02733
 * mf 980512  wince changes
 * mm 980707  Corrected initialization of __temp_file_mode to allow for wide characters
 * mm 981029  Excluded fflush() for __m56800__
 * mm 990119  When a file is opened in append mode, make sure that it is positioned to eof IL9901-1347 
 * bds 990121 Added BEOS wrapper
 * mf  990301 removed calls to _GetThreadLocalData for single threaded lib ansix86st.lib
 */
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>