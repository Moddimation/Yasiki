<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File qsort.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-qsortc">File qsort.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_30eb297d72d9bf6e37ae97b245365a16/"><strong>MSL_C</strong></a> <strong>&gt;</strong> <a href="../dir_5ff331ae3d8ec7992933a87ab898fc05/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_296ea1c022f8cfa02577b9a5b06211f5/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../qsort_8c/"><strong>qsort.c</strong></a></p>
<p><a href="../qsort_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/01/22 23:40:32 $ 
 *  $Revision: 1.7 $ 
 *  $NoKeywords: $ 
 *
 *      Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/*
 *  qsort.c
 *  
 *  Routines
 *  --------
 *      qsort
 *
 *  Implementation
 *  --------------
 *
 *      Here we use Heapsort, after Knuth's &quot;The Art of Computer Programming, Vol. 3&quot;,
 *      Section 5.2.3. Heapsort was chosen because it requires no auxiliary storage and
 *      has excellent average *and* worst-case performance.
 *
 *  Future Enhancements
 *  -------------------
 *      
 *      Although this algorithm is theoretically efficient, it is not as efficient
 *      as it could be for certain special cases. Specifically, the Swap routine
 *      could be more efficient in the same way memcpy et al. could be, i.e., by
 *      moving longs instead of bytes whenever possible. This would only be
 *      beneficial with a large member_size, though.
 *      
 *      For smaller member_size's, many Swap operations could be eliminated
 *      entirely. We swap on each iteration through the 'sift' operation even
 *      though, in theory, we can pick up a value before the loop, put it in a
 *      temporary, and drop it in its final destination after the loop. Where we
 *      now swap in the loop, we would merely need to replace:
 *      
 *         swap(ip,jp,member_size);
 *      
 *      with:
 *      
 *         memcpy(ip,jp,member_size);
 *      
 *      which involves less work.
 *      
 *      We do the swap because we don't know, in general, how big a temporary we
 *      would be needing. We could conceivably malloc a temporary as needed and
 *      resort to the algorithm used here only when we can't get the memory
 *      needed. However, for reasonably small member_size's, say &lt;= 64, we could
 *      use a statically allocated temporary.
 *      
 *      And finally, we can squeeze a lot of cycles for the special cases of
 *      member_size's of 1, 2, and 4 bytes, where we could presumably use a
 *      register for the temporary.
 *
 *
 *  18-Jul-95 JFH  First code release.
 *  04-Dec-95 JFH  Fixed small (!) bug in PPC version of swap. Was
 *                               pre-incrementing on store instead of fetch.
 */

#include &lt;stdlib.h&gt;

#define table_ptr(i)    (((char *) table_base) + (member_size * ((i) - 1)))

#if !__POWERPC__

#define swap(dst, src, cnt)                                             \
do {                                                                    \
  char *  p;                                                            \
  char *  q;                                                            \
  size_t  n = cnt;                                                      \
                                                                        \
  unsigned char tmp;                                                    \
                                                                        \
  for (p = src, q = dst, n++; --n;)                                     \
  {                                                                     \
    tmp = *q;                                                           \
    *q++ = *p;                                                          \
    *p++ = tmp;                                                         \
  }                                                                     \
} while (0)

#else

#define swap(dst, src, cnt)                                             \
do {                                                                    \
  char *  p;                                                            \
  char *  q;                                                            \
  size_t  n = cnt;                                                      \
                                                                        \
  unsigned long tmp;                                                    \
                                                                        \
  for (p = (char *) src - 1, q = (char *) dst - 1, n++; --n;)               \
  {                                                                     \
    tmp = *++q;                                                         \
    *q = *++p;                                                          \
    *p = tmp;                                                           \
  }                                                                     \
} while (0)

#endif

void qsort(void * table_base, size_t num_members, size_t member_size,
                     _compare_function compare_members)                          /* mm 961031 */
{
    size_t  l, r, /*i,*/ j;
    char *  lp;
    char *  rp;
    char *  ip;
    char *  jp;
    char *  kp;

    if (num_members &lt; 2)
        return;

    r = num_members;
    l = (r / 2) + 1;

    lp = table_ptr(l);
    rp = table_ptr(r);

    for (;;)
    {
        if (l &gt; 1)
        {
            l--;
            lp -= member_size;
        }
        else
        {
            swap(lp,rp,member_size);

            if (--r == 1)
                return;

            rp -= member_size;
        }

        j = l;

        jp = table_ptr(j);

        while (j*2 &lt;= r)
        {
        /*i =  j;*/
            j *= 2;

            ip = jp;
            jp = table_ptr(j);

            if (j &lt; r)
            {
                kp = jp + member_size;

                if (compare_members(jp, kp) &lt; 0)
                {
                    j++;
                    jp = kp;
                }
            }

            if (compare_members(ip,jp) &lt; 0)
                swap(ip,jp,member_size);    
            else
                break;
        }
    }
}

/*  Change Record
 *  18-Jul-95 JFH  First code release.
 *  04-Dec-95 JFH  Fixed small (!) bug in PPC version of swap. Was
 *                               pre-incrementing on store instead of fetch.
 *  mm 961031      Improved legibility of function declaration
*/
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>