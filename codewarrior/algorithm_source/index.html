<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File algorithm - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-algorithm">File algorithm</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_1d8bcf55c9e1564519df8a05b1def2d1/"><strong>MSL_C++</strong></a> <strong>&gt;</strong> <a href="../dir_fc42de24ef3c14a5dea3aca327bd2ec9/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_f262df31fb8e04d575b9a3aa2e30ecf8/"><strong>Include</strong></a> <strong>&gt;</strong> <a href="../algorithm/"><strong>algorithm</strong></a></p>
<p><a href="../algorithm/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/12/09 17:58:47 $ 
 *  $Revision: 1.12.4.1 $ 
 *  $NoKeywords: $ 
 *
 *      Portions Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/**
 **   algorithm
 **/

#ifndef _ALGORITHM
#define _ALGORITHM

#include &lt;mslconfig&gt;

#include &lt;cstdlib&gt;
#include &lt;climits&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;
#include &lt;functional&gt;
#include &lt;memory&gt;

#ifndef RC_INVOKED

#pragma options align=native
#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
    namespace std {
#endif

//  lib.alg.nonmodifying, non-modifying sequence operations:

// for_each

template&lt;class InputIterator, class Function&gt;
inline
Function
for_each(InputIterator first, InputIterator last, Function f)
{
    for (; first != last; ++first)
        f(*first);
    return f;
}

// find

template &lt;class InputIterator, class T&gt;
inline
InputIterator
find(InputIterator first, InputIterator last, const T&amp; value)
{
    while (first != last &amp;&amp; !(*first == value))
        ++first;
    return first;
}

template &lt;class InputIterator, class Predicate&gt;
inline
InputIterator
find_if(InputIterator first, InputIterator last, Predicate pred)
{
    while (first != last &amp;&amp; !pred(*first))
        ++first;
    return first;
}

// equal

template &lt;class InputIterator1, class InputIterator2&gt;
inline
bool
equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
    for (; first1 != last1; ++first1, ++first2)
        if (!(*first1 == *first2))
            return false;
    return true;
}

template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
inline
bool
equal(InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, BinaryPredicate pred)
{
    for (; first1 != last1; ++first1, ++first2)
        if (!pred(*first1, *first2))
            return false;
    return true;
}

// search

template &lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
       ForwardIterator2 first2, ForwardIterator2 last2)
{
    typename iterator_traits&lt;ForwardIterator1&gt;::difference_type d1 = distance(first1, last1);
    typename iterator_traits&lt;ForwardIterator2&gt;::difference_type d2 = distance(first2, last2);
    if (d1 &lt; d2 || d2 == 0)
        return last1;
    for (; d1 &gt;= d2; ++first1, --d1)
        if (equal(first2, last2, first1))
            return first1;
    return last1;
}

template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
       ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
    typename iterator_traits&lt;ForwardIterator1&gt;::difference_type d1 = distance(first1, last1);
    typename iterator_traits&lt;ForwardIterator2&gt;::difference_type d2 = distance(first2, last2);
    if (d1 &lt; d2 || d2 == 0)
        return last1;
    for (; d1 &gt;= d2; ++first1, --d1)
        if (equal(first2, last2, first1, pred))
            return first1;
    return last1;
}

// find_end

template &lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator1
__find_end(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2, forward_iterator_tag)
{
    first1 = search(first1, last1, first2, last2);
    ForwardIterator1 result = first1;
    if (first1 != last1)
    {
        while (true)
        {
            ++first1;
            first1 = search(first1, last1, first2, last2);
            if (first1 == last1)
                break;
            result = first1;
        }
    }
    return result;
}

template &lt;class BidirectionalIterator1, class ForwardIterator2&gt;
BidirectionalIterator1
__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2,
           bidirectional_iterator_tag)
{
    typename iterator_traits&lt;BidirectionalIterator1&gt;::difference_type d1 = distance(first1, last1);
    typename iterator_traits&lt;ForwardIterator2&gt;::difference_type d2 = distance(first2, last2);
    if (d1 &lt; d2 || d2 == 0)
        return last1;
    BidirectionalIterator1 result = last1;
    for (advance(result, -d2); result != first1; --result)
        if (equal(first2, last2, result))
            return result;
    if (equal(first2, last2, first1))
        return first1;
    return last1;
}

template &lt;class ForwardIterator1, class ForwardIterator2&gt;
inline
ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1 last1,
         ForwardIterator2 first2, ForwardIterator2 last2)
{
    typedef typename iterator_traits&lt;ForwardIterator1&gt;::iterator_category Category;
    return __find_end(first1, last1, first2, last2, Category());
}

template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
ForwardIterator1
__find_end(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred,
           forward_iterator_tag)
{
    first1 = search(first1, last1, first2, last2, pred);
    ForwardIterator1 result = first1;
    if (first1 != last1)
    {
        while (true)
        {
            ++first1;
            first1 = search(first1, last1, first2, last2, pred);
            if (first1 == last1)
                break;
            result = first1;
        }
    }
    return result;
}

template &lt;class BidirectionalIterator1, class ForwardIterator2, class BinaryPredicate&gt;
BidirectionalIterator1
__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred,
           bidirectional_iterator_tag)
{
    typename iterator_traits&lt;BidirectionalIterator1&gt;::difference_type d1 = distance(first1, last1);
    typename iterator_traits&lt;ForwardIterator2&gt;::difference_type d2 = distance(first2, last2);
    if (d1 &lt; d2 || d2 == 0)
        return last1;
    BidirectionalIterator1 result = last1;
    for (advance(result, -d2); result != first1; --result)
        if (equal(first2, last2, result, pred))
            return result;
    if (equal(first2, last2, first1, pred))
        return first1;
    return last1;
}

template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
inline
ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1 last1,
         ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
    typedef typename iterator_traits&lt;ForwardIterator1&gt;::iterator_category Category;
    return __find_end(first1, last1, first2, last2, pred, Category());
}

// find_first_of

template &lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator1
find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2)
{
    for (; first1 != last1; ++first1)
    {
        for (ForwardIterator2 i = first2; i != last2; ++i)
            if (*first1 == *i)
                return first1;
    }
    return last1;
}

template &lt;class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate&gt;
ForwardIterator1
find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
    for (; first1 != last1; ++first1)
    {
        for (ForwardIterator2 i = first2; i != last2; ++i)
            if (pred(*first1, *i))
                return first1;
    }
    return last1;
}

// adjacent_find

template &lt;class ForwardIterator&gt;
inline
ForwardIterator
adjacent_find(ForwardIterator first, ForwardIterator last)
{
    if (first != last)
    {
        ForwardIterator i = first;
        for (++i; i != last; ++i)
        {
            if (*first == *i)
                return first;
            first = i;
        }
    }
    return last;
}

template &lt;class ForwardIterator, class BinaryPredicate&gt;
inline
ForwardIterator
adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred)
{
    if (first != last)
    {
        ForwardIterator i = first;
        for (++i; i != last; ++i)
        {
            if (pred(*first, *i))
                return first;
            first = i;
        }
    }
    return last;
}

// count

template &lt;class InputIterator, class T&gt;
inline
typename iterator_traits&lt;InputIterator&gt;::difference_type
count(InputIterator first, InputIterator last, const T&amp; value)
{
    typename iterator_traits&lt;InputIterator&gt;::difference_type result = 0;
    for (; first != last; ++first)
        if (*first == value)
            ++result;
    return result;
}

template &lt;class InputIterator, class Predicate&gt;
inline
typename iterator_traits&lt;InputIterator&gt;::difference_type
count_if(InputIterator first, InputIterator last, Predicate pred)
{
    typename iterator_traits&lt;InputIterator&gt;::difference_type result = 0;
    for (; first != last; ++first)
        if (pred(*first))
            ++result;
    return result;
}

// mismatch

template &lt;class InputIterator1, class InputIterator2&gt;
inline
pair&lt;InputIterator1, InputIterator2&gt;
mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
    for (; first1 != last1; ++first1, ++first2)
        if (!(*first1 == *first2))
            break;
    return pair&lt;InputIterator1, InputIterator2&gt;(first1, first2);
}

template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
inline
pair&lt;InputIterator1, InputIterator2&gt;
mismatch(InputIterator1 first1, InputIterator1 last1,
         InputIterator2 first2, BinaryPredicate pred)
{
    for (; first1 != last1; ++first1, ++first2)
        if (!pred(*first1, *first2))
            break;
    return pair&lt;InputIterator1, InputIterator2&gt;(first1, first2);
}

// search_n

template &lt;class ForwardIterator, class Size, class T&gt;
ForwardIterator
search_n(ForwardIterator first, ForwardIterator last, Size count, const T&amp; value)
{
    Size d1 = static_cast&lt;Size&gt;(distance(first, last));
    if (d1 &lt; count || count == 0)
        return last;
    for (; d1 &gt;= count; ++first, --d1)
    {
        ForwardIterator i = first;
        for (Size n = 0; n &lt; count; ++n, ++i, --d1)
            if (!(*i == value))
                goto not_found;
        return first;
    not_found:
        first = i;
    }
    return last;
}

template &lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;
ForwardIterator
search_n(ForwardIterator first, ForwardIterator last,
         Size count, const T&amp; value, BinaryPredicate pred)
{
    Size d1 = static_cast&lt;Size&gt;(distance(first, last));
    if (d1 &lt; count || count == 0)
        return last;
    for (; d1 &gt;= count; ++first, --d1)
    {
        ForwardIterator i = first;
        for (Size n = 0; n &lt; count; ++n, ++i, --d1)
            if (!pred(*i, value))
                goto not_found;
        return first;
    not_found:
        first = i;
    }
    return last;
}

//  lib.alg.min.max, minimum and maximum:

template &lt;class T&gt;
inline
const T&amp;
min(const T&amp; a, const T&amp; b)
{
    return b &lt; a ? b : a;
}

template &lt;class T, class Compare&gt;
inline
const T&amp;
min(const T&amp; a, const T&amp; b, Compare comp)
{
    return comp(b, a) ? b : a;
}

template &lt;class T&gt;
inline
const T&amp;
max(const T&amp; a, const T&amp; b)
{
    return a &lt; b ? b : a;
}

template &lt;class T, class Compare&gt;
inline
const T&amp;
max(const T&amp; a, const T&amp; b, Compare comp)
{
    return comp(a, b) ? b : a;
}

template &lt;class ForwardIterator&gt;
inline
ForwardIterator
min_element(ForwardIterator first, ForwardIterator last)
{
    ForwardIterator i = first;
    if (first != last)
        for (++first; first != last; ++first)
            if (*first &lt; *i)
                i = first;
    return i;
}

template &lt;class ForwardIterator, class Compare&gt;
inline
ForwardIterator
min_element(ForwardIterator first, ForwardIterator last, Compare comp)
{
    ForwardIterator i = first;
    if (first != last)
        for (++first; first != last; ++first)
            if (comp(*first, *i))
                i = first;
    return i;
}

template &lt;class ForwardIterator&gt;
inline
ForwardIterator
max_element(ForwardIterator first, ForwardIterator last)
{
    ForwardIterator i = first;
    if (first != last)
        for (++first; first != last; ++first)
            if (*i &lt; *first)
                i = first;
    return i;
}

template &lt;class ForwardIterator, class Compare&gt;
inline
ForwardIterator
max_element(ForwardIterator first, ForwardIterator last, Compare comp)
{
    ForwardIterator i = first;
    if (first != last)
        for (++first; first != last; ++first)
            if (comp(*i, *first))
                i = first;
    return i;
}

template &lt;class InputIterator1, class InputIterator2&gt;
inline
bool
lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2)
{
    for (; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2)
    {
        if (*first1 &lt; *first2)
            return true;
        if (*first2 &lt; *first1)
            return false;
    }
    return static_cast&lt;bool&gt;(first2 != last2);
}

template &lt;class InputIterator1, class InputIterator2, class Compare&gt;
bool
lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2, Compare comp)
{
    for (; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2)
    {
        if (comp(*first1, *first2))
            return true;
        if (comp(*first2, *first1))
            return false;
    }
    return static_cast&lt;bool&gt;(first2 != last2);
}

//  lib.alg.modifying.operations, modifying sequence operations:

//  lib.alg.copy, copy:

template &lt;class InputIterator, class OutputIterator&gt;
inline
OutputIterator
copy(InputIterator first, InputIterator last, OutputIterator result)
{
    for (; first != last; ++first, ++result)
        *result = *first;
    return result;
}

// copy_backward

template &lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
inline
BidirectionalIterator2
copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
              BidirectionalIterator2 result)
{
    while (last != first)
        *--result = *--last;
    return result;
}

//  lib.alg.swap, swap:

template &lt;class T&gt;
inline
void
swap(T&amp; a, T&amp; b)
{
    T tmp(a);
    a = b;
    b = tmp;
}

// iter_swap

template &lt;class ForwardIterator1, class ForwardIterator2&gt;
inline
void
iter_swap(ForwardIterator1 a, ForwardIterator2 b)
{
    typename iterator_traits&lt;ForwardIterator1&gt;::value_type tmp(*a);
    *a = *b;
    *b = tmp;
}

// swap_ranges

template &lt;class ForwardIterator1, class ForwardIterator2&gt;
inline
ForwardIterator2
swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2)
{
    for (; first1 != last1; ++first1, ++first2)
        iter_swap(first1, first2);
    return first2;
}

// transform

template &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
inline
OutputIterator
transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op)
{
    for (; first != last; ++first, ++result)
        *result = op(*first);
    return result;
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator,
         class BinaryOperation&gt;
inline
OutputIterator
transform(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, OutputIterator result, BinaryOperation binary_op)
{
    for (; first1 != last1; ++first1, ++first2, ++result)
        *result = binary_op(*first1, *first2);
    return result;
}

// replace

template &lt;class ForwardIterator, class T&gt;
inline
void
replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value)
{
    for (; first != last; ++first)
        if (*first == old_value)
            *first = new_value;
}

template &lt;class ForwardIterator, class Predicate, class T&gt;
inline
void
replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T&amp; new_value)
{
    for (; first != last; ++first)
        if (pred(*first))
            *first = new_value;
}

// replace_copy

template &lt;class InputIterator, class OutputIterator, class T&gt;
inline
OutputIterator
replace_copy(InputIterator first, InputIterator last,
             OutputIterator result, const T&amp; old_value, const T&amp; new_value)
{
    for (; first != last; ++first, ++result)
        *result = *first == old_value ? new_value : *first;
    return result;
}

template &lt;class InputIterator, class OutputIterator, class Predicate, class T&gt;
inline
OutputIterator
replace_copy_if(InputIterator first, InputIterator last,
                OutputIterator result, Predicate pred, const T&amp; new_value)
{
    for (; first != last; ++first, ++result)
        *result = pred(*first) ? new_value : *first;
    return result;
}

// fill

template &lt;class ForwardIterator, class T&gt;
inline
void
fill(ForwardIterator first, ForwardIterator last, const T&amp; value)
{
    for (; first != last; ++first)
        *first = value;
}

template &lt;class OutputIterator, class Size, class T&gt;
inline
void
fill_n(OutputIterator first, Size n, const T&amp; value)
{
    for (; n &gt; 0; ++first, --n)
        *first = value;
}

// generate

template &lt;class ForwardIterator, class Generator&gt;
inline
void
generate(ForwardIterator first, ForwardIterator last, Generator gen)
{
    for (; first != last; ++first)
        *first = gen();
}

template &lt;class OutputIterator, class Size, class Generator&gt;
inline
void
generate_n(OutputIterator first, Size n, Generator gen)
{
    for (; n &gt; 0; ++first, --n)
        *first = gen();
}

// remove_copy

template &lt;class InputIterator, class OutputIterator, class T&gt;
OutputIterator
remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; value)
{
    for (; first != last; ++first)
    {
        if (!(*first == value))
        {
            *result = *first;
            ++result;
        }
    }
    return result;
}

template &lt;class InputIterator, class OutputIterator, class Predicate&gt;
OutputIterator
remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred)
{
    for (; first != last; ++first)
    {
        if (!pred(*first))
        {
            *result = *first;
            ++result;
        }
    }
    return result;
}

// remove

template &lt;class ForwardIterator, class T&gt;
inline
ForwardIterator
remove(ForwardIterator first, ForwardIterator last, const T&amp; value)
{
    ForwardIterator i = first = find(first, last, value);
    return first == last ? first : remove_copy(++i, last, first, value);
}

template &lt;class ForwardIterator, class Predicate&gt;
inline
ForwardIterator
remove_if(ForwardIterator first, ForwardIterator last, Predicate pred)
{
    ForwardIterator i = first = find_if(first, last, pred);
    return first == last ? first : remove_copy_if(++i, last, first, pred);
}

// unique_copy

template &lt;class InputIterator, class OutputIterator&gt;
OutputIterator
__unique_copy(InputIterator first, InputIterator last, OutputIterator result,
              output_iterator_tag)
{
    if (first != last)
    {
        typename iterator_traits&lt;InputIterator&gt;::value_type tmp(*first);
        *result = tmp;
        ++result;
        for (++first; first != last; ++first)
        {
            if (!(tmp == *first))
            {
                tmp = *first;
                *result = tmp;
                ++result;
            }
        }
    }
    return result;
}

template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
__unique_copy(InputIterator first, InputIterator last, ForwardIterator result,
              forward_iterator_tag)
{
    if (first != last)
    {
        *result = *first;
        for (++first; first != last; ++first)
            if (!(*result == *first))
                *++result = *first;
        ++result;
    }
    return result;
}

template &lt;class InputIterator, class OutputIterator&gt;
inline
OutputIterator
unique_copy(InputIterator first, InputIterator last, OutputIterator result)
{
    typedef typename iterator_traits&lt;OutputIterator&gt;::iterator_category Category;
    return __unique_copy(first, last, result, Category());
}

template &lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
OutputIterator
__unique_copy(InputIterator first, InputIterator last, OutputIterator result,
              BinaryPredicate pred, output_iterator_tag)
{
    if (first != last)
    {
        typename iterator_traits&lt;InputIterator&gt;::value_type tmp(*first);
        *result = tmp;
        ++result;
        for (++first; first != last; ++first)
        {
            if (!pred(tmp, *first))
            {
                tmp = *first;
                *result = tmp;
                ++result;
            }
        }
    }
    return result;
}

template &lt;class InputIterator, class ForwardIterator, class BinaryPredicate&gt;
ForwardIterator
__unique_copy(InputIterator first, InputIterator last, ForwardIterator result,
              BinaryPredicate pred, forward_iterator_tag)
{
    if (first != last)
    {
        *result = *first;
        for (++first; first != last; ++first)
            if (!pred(*result, *first))
                *++result = *first;
        ++result;
    }
    return result;
}

template &lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
inline
OutputIterator
unique_copy(InputIterator first, InputIterator last,
            OutputIterator result, BinaryPredicate pred)
{
    typedef typename iterator_traits&lt;OutputIterator&gt;::iterator_category Category;
    return __unique_copy(first, last, result, pred, Category());
}

// unique

template &lt;class ForwardIterator&gt;
inline
ForwardIterator
unique(ForwardIterator first, ForwardIterator last)
{
    first = adjacent_find(first, last);
    return unique_copy(first, last, first);
}

template &lt;class ForwardIterator, class BinaryPredicate&gt;
inline
ForwardIterator
unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred)
{
    first = adjacent_find(first, last, pred);
    return unique_copy(first, last, first, pred);
}

// reverse

template &lt;class BidirectionalIterator&gt;
inline
void
__reverse(BidirectionalIterator first, BidirectionalIterator last, bidirectional_iterator_tag)
{
    while (first != last)
    {
        --last;
        if (first == last)
            break;
        iter_swap(first, last);
        ++first;
    }
}

template &lt;class RandomAccessIterator&gt;
inline
void
__reverse(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)
{
    for (; first &lt; --last; ++first)
        iter_swap(first, last);
}

template &lt;class BidirectionalIterator&gt;
inline
void
reverse(BidirectionalIterator first, BidirectionalIterator last)
{
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::iterator_category Category;
    return __reverse(first, last, Category());
}

template &lt;class BidirectionalIterator, class OutputIterator&gt;
inline
OutputIterator
reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)
{
    for (; first != last; ++result)
        *result = *--last;
    return result;
}

// rotate

template &lt;class ForwardIterator&gt;
void
__rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last, forward_iterator_tag)
{
    ForwardIterator i = middle;
    while (true)
    {
        iter_swap(first, i);
        if (++first == middle)
        {
            if (++i == last)
                break;
            middle = i;
        }
        else if (++i == last)
            i = middle;
    }
}

template &lt;class BidirectionalIterator, class Distance, class RandomAccessIterator&gt;
BidirectionalIterator
__rotate(BidirectionalIterator first, BidirectionalIterator middle,
         BidirectionalIterator last, Distance len1, Distance len2,
         RandomAccessIterator buf_begin, RandomAccessIterator buf_end)
{
    Distance buf_size = static_cast&lt;Distance&gt;(buf_end - buf_begin);
    if (len1 &lt;= len2 &amp;&amp; len1 &lt;= buf_size)
    {
        buf_end = copy(first, middle, buf_begin);
        copy(middle, last, first);
        return copy_backward(buf_begin, buf_end, last);
    }
    if (len2 &lt;= buf_size)
    {
        buf_end = copy(middle, last, buf_begin);
        copy_backward(first, middle, last);
        return copy(buf_begin, buf_end, first);
    }
    __rotate(first, middle, last, forward_iterator_tag());
    advance(first, len2);
    return first;
}

template &lt;class BidirectionalIterator&gt;
void
__rotate(BidirectionalIterator first, BidirectionalIterator middle,
         BidirectionalIterator last, bidirectional_iterator_tag)
{
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::value_type T;
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type D;
    D len1 = distance(first, middle);
    D len2 = distance(middle, last);
    _TempVec&lt;T&gt; temp_buf(min(len1, len2));
    __rotate(first, middle, last, len1, len2, temp_buf.begin(), temp_buf.end());
}

template &lt;class ForwardIterator&gt;
inline
void
rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last)
{
    if (first == middle || middle == last)
        return;
    typedef typename iterator_traits&lt;ForwardIterator&gt;::iterator_category Category;
    __rotate(first, middle, last, Category());
}

template &lt;class ForwardIterator, class OutputIterator&gt;
inline
OutputIterator
rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last,
            OutputIterator result)
{
    return copy(first, middle, copy(middle, last, result));
}

// random_shuffle

#ifdef __POWERPC__

    template &lt;class T&gt;
    inline
    T
    __next_pow2(T d)
    {
        T lz = static_cast&lt;T&gt;(__cntlzw(static_cast&lt;unsigned int&gt;(d)));
        T r = T(1) &lt;&lt; (sizeof(unsigned int)*CHAR_BIT - lz - 1u);
        T m = static_cast&lt;T&gt;(static_cast&lt;unsigned int&gt;(-1) &gt;&gt; (lz + 1u));
        if (m &amp; d)
            r &lt;&lt;= 1;
        return r;
    }

#else

    template &lt;class T&gt;
    inline
    T
    __next_pow2(T x)
    {
        if(x == 0)
            return x;
        T shift = 0;
        T result =1 ;
        --x;  
        while(x != 0)
        {
            x &gt;&gt;= 1;
            ++shift;
        }
        return result &lt;&lt; shift; 
    }

#endif

template &lt;class T&gt;
T
__rs_default(T n)
{
    if (n &lt;= RAND_MAX + 1)
        return rand() * n / (RAND_MAX + 1);
    T d = n / (RAND_MAX + 1);
    if (n % (RAND_MAX + 1) != 0)
        ++d;
    d = __next_pow2(d);
    if (d &gt; RAND_MAX + 1)
        d = RAND_MAX + 1;
    T s = __rs_default(d);
    T h = n / d;
    T hm = d - n % d;
    if (s &lt; hm)
        return s * h + __rs_default(h);
    return hm * h + (s - hm) * (h + 1) + __rs_default(h + 1);
}

template &lt;class RandomAccessIterator&gt;
inline
void
random_shuffle(RandomAccessIterator first, RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    D d = last - first;
    if (d &gt; 1)
    {
        for (--last; first &lt; last; ++first, --d)
            iter_swap(first, first + __rs_default(d));
    }
}

template &lt;class RandomAccessIterator, class RandomNumberGenerator&gt;
inline
void
random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
               RandomNumberGenerator&amp; rand)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    D d = last - first;
    if (d &gt; 1)
    {
        for (--last; first &lt; last; ++first, --d)
            iter_swap(first, first + rand(d));
    }
}

//  lib.alg.partitions

// partition

template &lt;class BidirectionalIterator, class Predicate&gt;
inline
BidirectionalIterator
__partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred,
    bidirectional_iterator_tag)
{
    while (true)
    {
        while (pred(*first))
            ++first;
        if (first == last)
            break;
        while (!pred(*--last))
            {}
        if (first == ++last)
            break;
        iter_swap(first, --last);
        ++first;
    }
    return first;
}

template &lt;class RandomAccessIterator, class Predicate&gt;
inline
RandomAccessIterator
__partition(RandomAccessIterator first, RandomAccessIterator last, Predicate pred,
    random_access_iterator_tag)
{
    while (true)
    {
        while (pred(*first))
            ++first;
        while (!pred(*--last))
            {}
        if (first &gt;= last)
            break;
        iter_swap(first, last);
        ++first;
    }
    return first;
}

template &lt;class BidirectionalIterator, class Predicate&gt;
BidirectionalIterator
partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred)
{
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::iterator_category Category;
    if (first == last)
        return first;
    bool guard_front = pred(*first);
    bool guard_back = !pred(*--last);
    if (guard_front &amp;&amp; guard_back)
        // *first == true, *last == false
        return __partition(++first, last, pred, Category());
    if (guard_back)
    {
        // *first == false, *last == false
        if (first == last)
            return first;
        while (first != --last &amp;&amp; !pred(*last))
            {}
        if (first == last)
            return first;
    }
    else if (guard_front)
    {
        // *first == true, *last == true
        ++last;
        ++first;
        while (first != last &amp;&amp; pred(*first))
            ++first;
        if (first == last)
            return first;
        --last;
    }
    // *first == false, *last == true
    iter_swap(first, last);
    return __partition(++first, last, pred, Category());
}

// stable_partition

template &lt;class BidirectionalIterator, class Predicate, class Distance, class RandomAccessIterator&gt;
BidirectionalIterator
__stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred,
                   Distance len, RandomAccessIterator buf_begin, RandomAccessIterator buf_end)
{
    // check for trivial cases
    switch (len)
    {
    case 0:
        return last;
    case 1:
        return pred(*first) ? last : first;
    case 2:
        if (pred(*first))
        {
            if (pred(*++first))
                return last;
            return first;
        }
        if (pred(*--last))
        {
            iter_swap(first, last);
            return last;
        }
        return first;
    }
    // Try to do with temporary memory
    if (len &lt;= buf_end - buf_begin)
    {
        // Find first false
        while (first != last &amp;&amp; pred(*first))
            ++first;
        if (first == last)  // if already partitioned
            return last;
        // first marks first false
        BidirectionalIterator i = first;
        // Find next true
        i = find_if(++i, last, pred);
        if (i == last)  // if already partitioned
            return first;
        // Put falses in temporary buffer, move trues towards first
        RandomAccessIterator j = copy(first, i, buf_begin);
        *first = *i;
        for (++first, ++i; i != last; ++i)
        {
            if (pred(*i))
            {
                *first = *i;
                ++first;
            }
            else
            {
                *j = *i;
                ++j;
            }
        }
        // Now move falses back to first
        copy(buf_begin, j, first);
        return first;
    }
    // Else make do with less memory
    BidirectionalIterator mid = first;
    Distance l2 = len / 2;
    advance(mid, l2);
    BidirectionalIterator first_false =
        __stable_partition(first, mid, pred, l2, buf_begin, buf_end);
    BidirectionalIterator second_false =
        __stable_partition(mid, last, pred, len - l2, buf_begin, buf_end);
    l2 = distance(mid, second_false);
    if (l2 == 0)
        return first_false;
    len = distance(first_false, mid);
    if (len &gt; 0)
        first_false = __rotate(first_false, mid, second_false, len, l2, buf_begin, buf_end);
    else
        advance(first_false, l2);
    return first_false;
}

template &lt;class BidirectionalIterator, class Predicate&gt;
BidirectionalIterator
stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred)
{
    // Attempt to shrink problem size
    while (first != last &amp;&amp; pred(*first))
        ++first;
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::value_type T;
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type D;
    D len = distance(first, last);
    // partition now known to start with false
    switch (len)
    {
    case 0:
    case 1:
        return first;
    case 2:
        if (pred(*--last))
        {
            iter_swap(first, last);
            return last;
        }
        return first;
    }
    _TempVec&lt;T&gt; temp_buf(len);
    return __stable_partition(first, last, pred, len, temp_buf.begin(), temp_buf.end());
}

//  lib.alg.binary.search, binary search:

// lower_bound

template &lt;class ForwardIterator, class T&gt;
ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value)
{
    typedef typename iterator_traits&lt;ForwardIterator&gt;::difference_type D;
    D len = distance(first, last);
    while (len &gt; 0)
    {
        ForwardIterator i = first;
        D len2 = len / 2;
        advance(i, len2);
        if (*i &lt; value)
        {
            first = ++i;
            len -= len2 + 1;
        }
        else
            len = len2;
    }
    return first;
}

template &lt;class ForwardIterator, class T, class Compare&gt;
ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp)
{
    typedef typename iterator_traits&lt;ForwardIterator&gt;::difference_type D;
    D len = distance(first, last);
    while (len &gt; 0)
    {
        ForwardIterator i = first;
        D len2 = len / 2;
        advance(i, len2);
        if (comp(*i, value))
        {
            first = ++i;
            len -= len2 + 1;
        }
        else
            len = len2;
    }
    return first;
}

// upper_bound

template &lt;class ForwardIterator, class T&gt;
ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value)
{
    typedef typename iterator_traits&lt;ForwardIterator&gt;::difference_type D;
    D len = distance(first, last);
    while (len &gt; 0)
    {
        ForwardIterator i = first;
        D len2 = len / 2;
        advance(i, len2);
        if (!(value &lt; *i))
        {
            first = ++i;
            len -= len2 + 1;
        }
        else
            len = len2;
    }
    return first;
}

template &lt;class ForwardIterator, class T, class Compare&gt;
ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp)
{
    typedef typename iterator_traits&lt;ForwardIterator&gt;::difference_type D;
    D len = distance(first, last);
    while (len &gt; 0)
    {
        ForwardIterator i = first;
        D len2 = len / 2;
        advance(i, len2);
        if (!comp(value, *i))
        {
            first = ++i;
            len -= len2 + 1;
        }
        else
            len = len2;
    }
    return first;
}

// equal_range

template &lt;class ForwardIterator, class T&gt;
pair&lt;ForwardIterator, ForwardIterator&gt;
equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value)
{
    typedef pair&lt;ForwardIterator, ForwardIterator&gt; Result;
    typedef typename iterator_traits&lt;ForwardIterator&gt;::difference_type D;
    D len = distance(first, last);
    while (len &gt; 0)
    {
        ForwardIterator i = first;
        D len2 = len / 2;
        advance(i, len2);
        if (*i &lt; value)
        {
            first = ++i;
            len -= len2 + 1;
        }
        else if (value &lt; *i)
        {
            len = len2;
            last = i;
        }
        else
        {
            ForwardIterator j = i;
            return Result(lower_bound(first, i, value), upper_bound(++j, last, value));
        }
    }
    return Result(first, first);
}

template &lt;class ForwardIterator, class T, class Compare&gt;
pair&lt;ForwardIterator, ForwardIterator&gt;
equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp)
{
    typedef pair&lt;ForwardIterator, ForwardIterator&gt; Result;
    typedef typename iterator_traits&lt;ForwardIterator&gt;::difference_type D;
    D len = distance(first, last);
    while (len &gt; 0)
    {
        ForwardIterator i = first;
        D len2 = len / 2;
        advance(i, len2);
        if (comp(*i, value))
        {
            first = ++i;
            len -= len2 + 1;
        }
        else if (comp(value, *i))
        {
            len = len2;
            last = i;
        }
        else
        {
            ForwardIterator j = i;
            return Result(lower_bound(first, i, value, comp),
                          upper_bound(++j, last, value, comp));
        }
    }
    return Result(first, first);
}

template &lt;class ForwardIterator, class T&gt;
inline
bool
binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value)
{
    ForwardIterator i = lower_bound(first, last, value);
    return static_cast&lt;bool&gt;(i != last &amp;&amp; !(value &lt; *i));
}

template &lt;class ForwardIterator, class T, class Compare&gt;
inline
bool
binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp)
{
    ForwardIterator i = lower_bound(first, last, value, comp);
    return static_cast&lt;bool&gt;(i != last &amp;&amp; !comp(value, *i));
}

// merge

template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator
merge(InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2, OutputIterator result)
{
    for (; first1 != last1 &amp;&amp; first2 != last2; ++result)
    {
        if (*first2 &lt; *first1)
        {
            *result = *first2;
            ++first2;
        }
        else
        {
            *result = *first1;
            ++first1;
        }
    }
    if (first1 == last1)
        return copy(first2, last2, result);
    return copy(first1, last1, result);
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
OutputIterator
merge(InputIterator1 first1, InputIterator1 last1,
      InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp)
{
    for (; first1 != last1 &amp;&amp; first2 != last2; ++result)
    {
        if (comp(*first2, *first1))
        {
            *result = *first2;
            ++first2;
        }
        else
        {
            *result = *first1;
            ++first1;
        }
    }
    if (first1 == last1)
        return copy(first2, last2, result);
    return copy(first1, last1, result);
}

// __merge_backward

template &lt;class BidirectionalIterator1, class BidirectionalIterator2,
          class BidirectionalIterator3&gt;
BidirectionalIterator3
__merge_backward(BidirectionalIterator1 first1, BidirectionalIterator1 last1,
                 BidirectionalIterator2 first2, BidirectionalIterator2 last2,
                 BidirectionalIterator3 result)
{
    if (first1 == last1)
        return copy_backward(first2, last2, result);
    if (first2 == last2)
        return copy_backward(first1, last1, result);
    --last1;
    --last2;
    while (true)
    {
        if (*last2 &lt; *last1)
        {
            *--result = *last1;
            if (first1 == last1)
                return copy_backward(first2, ++last2, result);
            --last1;
        } else
        {
            *--result = *last2;
            if (first2 == last2)
                return copy_backward(first1, ++last1, result);
            --last2;
        }
    }
}

template &lt;class BidirectionalIterator1, class BidirectionalIterator2,
          class BidirectionalIterator3, class Compare&gt;
BidirectionalIterator3
__merge_backward(BidirectionalIterator1 first1, BidirectionalIterator1 last1,
                 BidirectionalIterator2 first2, BidirectionalIterator2 last2,
                 BidirectionalIterator3 result, Compare comp)
{
    if (first1 == last1)
        return copy_backward(first2, last2, result);
    if (first2 == last2)
        return copy_backward(first1, last1, result);
    --last1;
    --last2;
    while (true)
    {
        if (comp(*last2, *last1))
        {
            *--result = *last1;
            if (first1 == last1)
                return copy_backward(first2, ++last2, result);
            --last1;
        } else
        {
            *--result = *last2;
            if (first2 == last2)
                return copy_backward(first1, ++last1, result);
            --last2;
        }
    }
}

// inplace_merge

template &lt;class BidirectionalIterator, class Distance, class RandomAccessIterator&gt;
void
__inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,
                BidirectionalIterator last, Distance len1, Distance len2,
                RandomAccessIterator buf_beg, RandomAccessIterator buf_end)
{
    if (first == middle || middle == last)
        return;
    if (len1 + len2 == 2)
    {
        if (*middle &lt; *first)
            iter_swap(first, middle);
        return;
    }
    Distance buffer_size = static_cast&lt;Distance&gt;(buf_end - buf_beg);
    if (len1 &lt;= len2 &amp;&amp; len1 &lt;= buffer_size)
        merge(buf_beg, copy(first, middle, buf_beg), middle, last, first);
    else if (len2 &lt;= buffer_size)
        __merge_backward(first, middle, buf_beg, copy(middle, last, buf_beg), last);
    else
    {
        BidirectionalIterator mid1, mid2;
        Distance len12, len22;
        if (len1 &lt; len2)
        {
            len22 = len2 / 2;
            mid2 = middle;
            advance(mid2, len22);
            mid1 = upper_bound(first, middle, *mid2);
            len12 = distance(first, mid1);
        }
        else
        {
            len12 = len1 / 2;
            mid1 = first;
            advance(mid1, len12);
            mid2 = lower_bound(middle, last, *mid1);
            len22 = distance(middle, mid2);
        }
        middle = __rotate(mid1, middle, mid2, len1 - len12, len22, buf_beg, buf_end);
        __inplace_merge(first, mid1, middle, len12, len22, buf_beg, buf_end);
        __inplace_merge(middle, mid2, last, len1-len12, len2-len22, buf_beg, buf_end);
    }
}

template &lt;class BidirectionalIterator&gt;
void
inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,
              BidirectionalIterator last)
{
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::value_type T;
    D len1 = distance(first, middle);
    if (len1 == 0)
        return;
    D len2 = distance(middle, last);
    if (len2 == 0)
        return;
    _TempVec&lt;T&gt; temp_buf(min(len1, len2));
    __inplace_merge(first, middle, last, len1, len2, temp_buf.begin(), temp_buf.end());
}

template &lt;class BidirectionalIterator, class Compare, class Distance, class RandomAccessIterator&gt;
void
__inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,
                BidirectionalIterator last, Compare comp, Distance len1, Distance len2,
                RandomAccessIterator buf_beg, RandomAccessIterator buf_end)
{
    if (first == middle || middle == last)
        return;
    if (len1 + len2 == 2)
    {
        if (comp(*middle, *first))
            iter_swap(first, middle);
        return;
    }
    Distance buffer_size = static_cast&lt;Distance&gt;(buf_end - buf_beg);
    if (len1 &lt;= len2 &amp;&amp; len1 &lt;= buffer_size)
        merge(buf_beg, copy(first, middle, buf_beg), middle, last, first, comp);
    else if (len2 &lt;= buffer_size)
        __merge_backward(first, middle, buf_beg, copy(middle, last, buf_beg), last, comp);
    else
    {
        BidirectionalIterator mid1, mid2;
        Distance len12, len22;
        if (len1 &lt;= len2)
        {
            len22 = len2 / 2;
            mid2 = middle;
            advance(mid2, len22);
            mid1 = upper_bound(first, middle, *mid2, comp);
            len12 = distance(first, mid1);
        }
        else
        {
            len12 = len1 / 2;
            mid1 = first;
            advance(mid1, len12);
            mid2 = lower_bound(middle, last, *mid1, comp);
            len22 = distance(middle, mid2);
        }
        middle = __rotate(mid1, middle, mid2, len1 - len12, len22, buf_beg, buf_end);
        __inplace_merge(first, mid1, middle, comp, len12, len22, buf_beg, buf_end);
        __inplace_merge(middle, mid2, last, comp, len1-len12, len2-len22, buf_beg, buf_end);
    }
}

template &lt;class BidirectionalIterator, class Compare&gt;
void
inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,
              BidirectionalIterator last, Compare comp)
{
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;BidirectionalIterator&gt;::value_type T;
    D len1 = distance(first, middle);
    if (len1 == 0)
        return;
    D len2 = distance(middle, last);
    if (len2 == 0)
        return;
    _TempVec&lt;T&gt; temp_buf(min(len1, len2));
    __inplace_merge(first, middle, last, comp, len1, len2, temp_buf.begin(), temp_buf.end());
}

//  lib.alg.heap.operations, heap operations:

// push_heap

template &lt;class RandomAccessIterator&gt;
void
push_heap(RandomAccessIterator first, RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    D hole = last - first;
    if (hole &lt; 2)
        return;
    --hole;
    D parent = (hole - 1) / 2;
    RandomAccessIterator parent_ptr = first + parent;
    RandomAccessIterator hole_ptr = first + hole;
    if (*parent_ptr &lt; *hole_ptr)
    {
        T tmp(*hole_ptr);
        do
        {
            *hole_ptr = *parent_ptr;
            hole_ptr = parent_ptr;
            if (hole_ptr == first)
                break;
            --parent;
            parent /= 2;
            parent_ptr = first + parent;
        } while (*parent_ptr &lt; tmp);
        *hole_ptr = tmp;
    }
}


template &lt;class RandomAccessIterator, class Compare&gt;
void
push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    D hole = last - first;
    if (hole &lt; 2)
        return;
    --hole;
    D parent = (hole - 1) / 2;
    RandomAccessIterator parent_ptr = first + parent;
    RandomAccessIterator hole_ptr = first + hole;
    if (comp(*parent_ptr, *hole_ptr))
    {
        T tmp(*hole_ptr);
        do
        {
            *hole_ptr = *parent_ptr;
            hole_ptr = parent_ptr;
            if (hole_ptr == first)
                break;
            --parent;
            parent /= 2;
            parent_ptr = first + parent;
        } while (comp(*parent_ptr, tmp));
        *hole_ptr = tmp;
    }
}

// __insert_heap_down

template &lt;class RandomAccessIterator, class Distance, class T&gt;
void
__insert_heap_down(RandomAccessIterator first, Distance len, Distance hole,
                   const T&amp; temp)
{
    RandomAccessIterator hole_ptr = first + hole;
    Distance child = (hole + 1) * 2;
    while (child &lt;= len)
    {
        RandomAccessIterator child_ptr = first + child;
        if (child == len || *child_ptr &lt; *(child_ptr - 1))
        {
            --child;
            --child_ptr;
        }
        if (!(temp &lt; *child_ptr))
            break;
        *hole_ptr = *child_ptr;
        hole_ptr = child_ptr;
        ++child;
        child *= 2;
    }
    *hole_ptr = temp;
}

template &lt;class RandomAccessIterator, class Distance, class T, class Compare&gt;
void
__insert_heap_down(RandomAccessIterator first, Distance len, Distance hole,
                   const T&amp; temp, Compare comp)
{
    RandomAccessIterator hole_ptr = first + hole;
    Distance child = (hole + 1) * 2;
    while (child &lt;= len)
    {
        RandomAccessIterator child_ptr = first + child;
        if (child == len || comp(*child_ptr, *(child_ptr - 1)))
        {
            --child;
            --child_ptr;
        }
        if (!comp(temp, *child_ptr))
            break;
        *hole_ptr = *child_ptr;
        hole_ptr = child_ptr;
        ++child;
        child *= 2;
    }
    *hole_ptr = temp;
}

// pop_heap

template &lt;class RandomAccessIterator&gt;
void
pop_heap(RandomAccessIterator first, RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    D len = last - first;
    if (len &lt; 2)
        return;
    --last;
    if (len == 2)
    {
        iter_swap(first, last);
        return;
    }
    --len;
    T temp(*last);
    *last = *first;
    __insert_heap_down(first, len, D(0), temp);
}

template &lt;class RandomAccessIterator, class Compare&gt;
void
pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    D len = last - first;
    if (len &lt; 2)
        return;
    --last;
    if (len == 2)
    {
        iter_swap(first, last);
        return;
    }
    --len;
    T temp(*last);
    *last = *first;
    __insert_heap_down(first, len, D(0), temp, comp);
}

// make_heap

template &lt;class RandomAccessIterator&gt;
void
make_heap(RandomAccessIterator first, RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    D len = last - first;
    if (len &lt; 2)
        return;
    D parent = (len - 2)/2;
    RandomAccessIterator parent_ptr = first + parent;
    D child2 = (parent + 1) * 2;
    RandomAccessIterator child2_ptr = first + child2;
    RandomAccessIterator child1_ptr = child2_ptr - 1;
    D max_child = child2;
    RandomAccessIterator max_child_ptr = child2_ptr;
    if (child2 == len || *child2_ptr &lt; *child1_ptr)
    {
        --max_child;
        max_child_ptr = child1_ptr;
    }
    while (true)
    {
        if (*parent_ptr &lt; *max_child_ptr)
        {
            T temp(*parent_ptr);
            *parent_ptr = *max_child_ptr;
            __insert_heap_down(first, len, max_child, temp);
        }
        if (parent-- == 0)
            break;
        --parent_ptr;
        child2 -= 2;
        child2_ptr -= 2;
        child1_ptr -= 2;
        max_child = child2;
        max_child_ptr = child2_ptr;
        if (*child2_ptr &lt; *child1_ptr)
        {
            --max_child;
            max_child_ptr = child1_ptr;
        }
    }
}

template &lt;class RandomAccessIterator, class Compare&gt;
void
make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    D len = last - first;
    if (len &lt; 2)
        return;
    D parent = (len - 2)/2;
    RandomAccessIterator parent_ptr = first + parent;
    D child2 = (parent + 1) * 2;
    RandomAccessIterator child2_ptr = first + child2;
    RandomAccessIterator child1_ptr = child2_ptr - 1;
    D max_child = child2;
    RandomAccessIterator max_child_ptr = child2_ptr;
    if (child2 == len || comp(*child2_ptr, *child1_ptr))
    {
        --max_child;
        max_child_ptr = child1_ptr;
    }
    while (true)
    {
        if (comp(*parent_ptr, *max_child_ptr))
        {
            T temp(*parent_ptr);
            *parent_ptr = *max_child_ptr;
            __insert_heap_down(first, len, max_child, temp, comp);
        }
        if (parent-- == 0)
            break;
        --parent_ptr;
        child2 -= 2;
        child2_ptr -= 2;
        child1_ptr -= 2;
        max_child = child2;
        max_child_ptr = child2_ptr;
        if (comp(*child2_ptr, *child1_ptr))
        {
            --max_child;
            max_child_ptr = child1_ptr;
        }
    }
}

//  sort_heap

template &lt;class RandomAccessIterator&gt;
inline
void
sort_heap(RandomAccessIterator first, RandomAccessIterator last)
{
    for (; first != last; --last)
        pop_heap(first, last);
}

template &lt;class RandomAccessIterator, class Compare&gt;
inline
void
sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
{
    for (; first != last; --last)
        pop_heap(first, last, comp);
}

//  sort

// hh 990106
template&lt;class ForwardIterator&gt;
void
__sort3(ForwardIterator a1, ForwardIterator a2, ForwardIterator a3)
{
    if (*a2 &lt; *a1)
        iter_swap(a1, a2);
    if (*a3 &lt; *a2)
    {
        typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type Value;
        Value tmp = *a3;
        *a3 = *a2;
        if (tmp &lt; *a1)
        {
            *a2 = *a1;
            *a1 = tmp;
        }
        else
            *a2 = tmp;
    }
}

// hh 990106
template&lt;class ForwardIterator, class Compare&gt;
void
__sort3(ForwardIterator a1, ForwardIterator a2, ForwardIterator a3, Compare comp)
{
    if (comp(*a2, *a1))
        iter_swap(a1, a2);
    if (comp(*a3, *a2))
    {
        typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type Value;
        Value tmp = *a3;
        *a3 = *a2;
        if (comp(tmp, *a1))
        {
            *a2 = *a1;
            *a1 = tmp;
        }
        else
            *a2 = tmp;
    }
}

template&lt;class RandomAccessIterator&gt;
void
__insertion_sort(RandomAccessIterator first, RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type Value;
    RandomAccessIterator i = first;
    for (++i; i &lt; last; ++i)
    {
        Value tmp = *i;
        RandomAccessIterator j = i;
        RandomAccessIterator k = j;
        --j;
        while (first &lt; k &amp;&amp; tmp &lt; *j)
        {
            *k = *j;
            --k;
            --j;
        }
        *k = tmp;
    }
}

template&lt;class RandomAccessIterator, class Compare&gt;
void
__insertion_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type Value;
    RandomAccessIterator i = first;
    for (++i; i &lt; last; ++i)
    {
        Value tmp = *i;
        RandomAccessIterator j = i;
        RandomAccessIterator k = j;
        --j;
        while (first &lt; k &amp;&amp; comp(tmp, *j))
        {
            *k = *j;
            --k;
            --j;
        }
        *k = tmp;
    }
}

template&lt;class RandomAccessIterator&gt;
void
sort(RandomAccessIterator first, RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type Difference;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    Difference len = last - first;
    if (len &lt;= 1)
        return;
    if (len &lt;= 20)
    {
        __insertion_sort(first, last);
        return;
    }
    RandomAccessIterator m = first + len / 2;
    RandomAccessIterator j = last - 1;
    __sort3(first, m, j);  // hh 990106
    m = partition(first + 1, j, bind2nd(less&lt;T&gt;(), *m));
    sort(first, m);
    sort(m, last);
}

template&lt;class RandomAccessIterator, class Compare&gt;
void
sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type Difference;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type Value;
    Difference len = last - first;
    if (len &lt;= 1)
        return;
    if (len &lt;= 20)
    {
        __insertion_sort(first, last, comp);
        return;
    }
    RandomAccessIterator m = first + len / 2;
    RandomAccessIterator j = last - 1;
    __sort3(first, m, j, comp);  // hh 990106
    m = partition(first + 1, j, bind2nd(comp, *m));
    sort(first, m, comp);
    sort(m, last, comp);
}

// stable_sort

template &lt;class RandomAccessIterator1, class RandomAccessIterator2&gt;
void
__stable_sort_copy(RandomAccessIterator1 first1, RandomAccessIterator1 last1,
                   RandomAccessIterator2 first2)
{
    typedef typename iterator_traits&lt;RandomAccessIterator1&gt;::difference_type Difference;
    Difference len = last1 - first1;
    if (len &lt;= 0)
        return;
    if (len == 1)
    {
        *first2 = *first1;
        return;
    }
    if (len == 2)
    {
        if (*(last1-1) &lt; *first1)
            reverse_copy(first1, last1, first2);
        else
            copy(first1, last1, first2);
        return;
    }
    if (len &lt;= 20)
    {
        __insertion_sort(first1, last1);
        copy(first1, last1, first2);
        return;
    }
    Difference len2 = len / 2;
    RandomAccessIterator1 middle = first1 + len2;
    __stable_sort(first1, middle, first2, first2+len2);
    __stable_sort(middle, last1, first2+len2, first2+len);
    merge(first1, first1+len2, first1+len2, first1+len, first2);
}

template &lt;class RandomAccessIterator1, class RandomAccessIterator2, class Compare&gt;
void
__stable_sort_copy(RandomAccessIterator1 first1, RandomAccessIterator1 last1,
                   RandomAccessIterator2 first2, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator1&gt;::difference_type Difference;
    Difference len = last1 - first1;
    if (len &lt;= 0)
        return;
    if (len == 1)
    {
        *first2 = *first1;
        return;
    }
    if (len == 2)
    {
        if (comp(*(last1-1), *first1))
            reverse_copy(first1, last1, first2);
        else
            copy(first1, last1, first2);
        return;
    }
    if (len &lt;= 20)
    {
        __insertion_sort(first1, last1, comp);
        copy(first1, last1, first2);
        return;
    }
    Difference len2 = len / 2;
    RandomAccessIterator1 middle = first1 + len2;
    __stable_sort(first1, middle, first2, first2+len2, comp);
    __stable_sort(middle, last1, first2+len2, first2+len, comp);
    merge(first1, first1+len2, first1+len2, first1+len, first2, comp);
}

template &lt;class RandomAccessIterator1, class RandomAccessIterator2&gt;
void
__stable_sort(RandomAccessIterator1 first, RandomAccessIterator1 last,
              RandomAccessIterator2 buf_beg, RandomAccessIterator2 buf_end)
{
    typedef typename iterator_traits&lt;RandomAccessIterator1&gt;::difference_type Difference;
    Difference len = last - first;
    if (len &lt;= 1)
        return;
    if (len == 2)
    {
        --last;
        if (*last &lt; *first)
            iter_swap(first, last);
        return;
    }
    if (len &lt;= 20)
    {
        __insertion_sort(first, last);
        return;
    }
    RandomAccessIterator1 middle = first + len / 2;
    if (len &lt;= buf_end - buf_beg)
    {
        __stable_sort_copy(first, middle, buf_beg);
        __stable_sort_copy(middle, last, buf_beg+len/2);
        merge(buf_beg, buf_beg+len/2, buf_beg+len/2, buf_beg+len, first);
        return;
    }
    __stable_sort(first, middle, buf_beg, buf_end);
    __stable_sort(middle, last, buf_beg, buf_end);
    __inplace_merge(first, middle, last, middle - first, last - middle, buf_beg, buf_end);
}

template &lt;class RandomAccessIterator1, class RandomAccessIterator2, class Compare&gt;
void
__stable_sort(RandomAccessIterator1 first, RandomAccessIterator1 last,
              RandomAccessIterator2 buf_beg, RandomAccessIterator2 buf_end, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator1&gt;::difference_type Difference;
    Difference len = last - first;
    if (len &lt;= 1)
        return;
    if (len == 2)
    {
        --last;
        if (comp(*last, *first))
            iter_swap(first, last);
        return;
    }
    if (len &lt;= 20)
    {
        __insertion_sort(first, last, comp);
        return;
    }
    RandomAccessIterator1 middle = first + len / 2;
    if (len &lt;= buf_end - buf_beg)
    {
        __stable_sort_copy(first, middle, buf_beg, comp);
        __stable_sort_copy(middle, last, buf_beg+len/2, comp);
        merge(buf_beg, buf_beg+len/2, buf_beg+len/2, buf_beg+len, first, comp);
        return;
    }
    __stable_sort(first, middle, buf_beg, buf_end, comp);
    __stable_sort(middle, last, buf_beg, buf_end, comp);
    __inplace_merge(first, middle, last, comp, middle - first, last - middle, buf_beg,
        buf_end);
}

template &lt;class RandomAccessIterator&gt;
void
stable_sort(RandomAccessIterator first, RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type Difference;
    Difference len = last - first;
    if (len &lt;= 1)
        return;
    if (len == 2)
    {
        --last;
        if (*last &lt; *first)
            iter_swap(first, last);
        return;
    }
    if (len &lt;= 20)
    {
        __insertion_sort(first, last);
        return;
    }
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type Value;
    _TempVec&lt;Value&gt; buf(len);
    __stable_sort(first, last, buf.begin(), buf.end());
}

template &lt;class RandomAccessIterator, class Compare&gt;
void
stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type Difference;
    Difference len = last - first;
    if (len &lt;= 1)
        return;
    if (len == 2)
    {
        --last;
        if (comp(*last, *first))
            iter_swap(first, last);
        return;
    }
    if (len &lt;= 20)
    {
        __insertion_sort(first, last, comp);
        return;
    }
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type Value;
    _TempVec&lt;Value&gt; buf(len);
    __stable_sort(first, last, buf.begin(), buf.end(), comp);
}

// partial_sort

template &lt;class RandomAccessIterator&gt;
void
partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
             RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    D midlen = middle - first;
    switch (midlen)
    {
    case 0:
        return;
    case 1:
        iter_swap(first, min_element(first, last));
        return;
    }
    make_heap(first, middle);
    for (RandomAccessIterator i = middle; i != last; ++i)
    {
        if (*i &lt; *first)
        {
            T tmp(*i);
            *i = *first;
            __insert_heap_down(first, midlen, D(0), tmp);
        }
    }
    sort_heap(first, middle);
}

template &lt;class RandomAccessIterator, class Compare&gt;
void
partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
             RandomAccessIterator last, Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    D midlen = middle - first;
    switch (midlen)
    {
    case 0:
        return;
    case 1:
        iter_swap(first, min_element(first, last, comp));
        return;
    }
    make_heap(first, middle, comp);
    for (RandomAccessIterator i = middle; i != last; ++i)
    {
        if (comp(*i, *first))
        {
            T tmp(*i);
            *i = *first;
            __insert_heap_down(first, midlen, D(0), tmp, comp);
        }
    }
    sort_heap(first, middle, comp);
}

template &lt;class InputIterator, class RandomAccessIterator&gt;
RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
                  RandomAccessIterator result_first, RandomAccessIterator result_last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    RandomAccessIterator result = result_first;
    for (; first != last &amp;&amp; result != result_last; ++first, ++result)
        *result = *first;
    D len = result - result_first;
    if (len == 0)
        return result;
    make_heap(result_first, result);
    for (; first != last; ++first)
        if (*first &lt; *result_first)
            __insert_heap_down(result_first, len, D(0), *first);
    sort_heap(result_first, result);
    return result;
}

template &lt;class InputIterator, class RandomAccessIterator, class Compare&gt;
RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
                  RandomAccessIterator result_first, RandomAccessIterator result_last,
                  Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    RandomAccessIterator result = result_first;
    for (; first != last &amp;&amp; result != result_last; ++first, ++result)
        *result = *first;
    D len = result - result_first;
    if (len == 0)
        return result;
    make_heap(result_first, result, comp);
    for (; first != last; ++first)
        if (comp(*first, *result_first))
            __insert_heap_down(result_first, len, D(0), *first, comp);
    sort_heap(result_first, result, comp);
    return result;
}

template &lt;class RandomAccessIterator&gt;
void
nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    D len = last - first;
    while (len &gt; 3)
    {
        if (nth == first)
        {
            iter_swap(first, min_element(first, last));
            return;
        }
        RandomAccessIterator j = last - 1;
        if (nth == j)
        {
            iter_swap(j, max_element(first, last));
            return;
        }
        RandomAccessIterator m = first + len / 2;
        __sort3(first, m, j);  // hh 990106
        T part(*m);
        m = partition(first + 1, j, bind2nd(less&lt;T&gt;(), *m));
        if (nth &lt; m)
            last = m;
        else
            first = m;
        len = last - first;
    }
    __insertion_sort(first, last);
}

template &lt;class RandomAccessIterator, class Compare&gt;
void
nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last,
            Compare comp)
{
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type D;
    typedef typename iterator_traits&lt;RandomAccessIterator&gt;::value_type T;
    D len = last - first;
    while (len &gt; 3)
    {
        if (nth == first)
        {
            iter_swap(first, min_element(first, last, comp));
            return;
        }
        RandomAccessIterator j = last - 1;
        if (nth == j)
        {
            iter_swap(j, max_element(first, last, comp));
            return;
        }
        RandomAccessIterator m = first + len / 2;
        __sort3(first, m, j, comp);  // hh 990106
        T part(*m);
        m = partition(first + 1, j, bind2nd(comp, *m));
        if (nth &lt; m)
            last = m;
        else
            first = m;
        len = last - first;
    }
    __insertion_sort(first, last, comp);
}

//  lib.alg.set.operations, set operations:

template &lt;class InputIterator1, class InputIterator2&gt;
inline
bool
includes(InputIterator1 first1, InputIterator1 last1,
         InputIterator2 first2, InputIterator2 last2)
{
    for (; first1 != last1 &amp;&amp; first2 != last2; ++first1)
    {
        if (*first2 &lt; *first1)
            return false;
        else if (!(*first1 &lt; *first2))  // else if (*first1 == *first2)
            ++first2;
    }
    return static_cast&lt;bool&gt;(first2 == last2);
}

template &lt;class InputIterator1, class InputIterator2, class Compare&gt;
inline
bool
includes(InputIterator1 first1, InputIterator1 last1,
         InputIterator2 first2, InputIterator2 last2, Compare comp)
{
    for (; first1 != last1 &amp;&amp; first2 != last2; ++first1)
    {
        if (comp(*first2, *first1))
            return false;
        else if (!comp(*first1, *first2))  // else if (*first1 == *first2)
            ++first2;
    }
    return static_cast&lt;bool&gt;(first2 == last2);
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator
set_union(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2, OutputIterator result)
{
    for (; first1 != last1 &amp;&amp; first2 != last2; ++result)
    {
        if (*first2 &lt; *first1)
        {
            *result = *first2;
            ++first2;
        }
        else if (*first1 &lt; *first2)
        {
            *result = *first1;
            ++first1;
        }
        else
        {
            *result = *first1;
            ++first1;
            ++first2;
        }
    }
    if (first2 == last2)
        return copy(first1, last1, result);
    return copy(first2, last2, result);
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
OutputIterator
set_union(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp)
{
    for (; first1 != last1 &amp;&amp; first2 != last2; ++result)
    {
        if (comp(*first2, *first1))
        {
            *result = *first2;
            ++first2;
        }
        else if (comp(*first1, *first2))
        {
            *result = *first1;
            ++first1;
        }
        else
        {
            *result = *first1;
            ++first1;
            ++first2;
        }
    }
    if (first2 == last2)
        return copy(first1, last1, result);
    return copy(first2, last2, result);
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator
set_intersection(InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2, InputIterator2 last2, OutputIterator result)
{
    while (first1 != last1 &amp;&amp; first2 != last2)
    {
        if (*first2 &lt; *first1)
            ++first2;
        else if (*first1 &lt; *first2)
            ++first1;
        else
        {
            *result = *first1;
            ++result;
            ++first1;
            ++first2;
        }
    }
    return result;
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
OutputIterator
set_intersection(InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2, InputIterator2 last2, OutputIterator result,
                 Compare comp)
{
    while (first1 != last1 &amp;&amp; first2 != last2)
    {
        if (comp(*first2, *first1))
            ++first2;
        else if (comp(*first1, *first2))
            ++first1;
        else
        {
            *result = *first1;
            ++result;
            ++first1;
            ++first2;
        }
    }
    return result;
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator
set_difference(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2, OutputIterator result)
{
    while (first1 != last1 &amp;&amp; first2 != last2)
    {
        if (*first1 &lt; *first2)
        {
            *result = *first1;
            ++result;
            ++first1;
        }
        else if (*first2 &lt; *first1)
            ++first2;
        else
        {
            ++first1;
            ++first2;
        }
    }
    return copy(first1, last1, result);
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
OutputIterator
set_difference(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2, OutputIterator result,
               Compare comp)
{
    while (first1 != last1 &amp;&amp; first2 != last2)
    {
        if (comp(*first1, *first2))
        {
            *result = *first1;
            ++result;
            ++first1;
        }
        else if (comp(*first2, *first1))
            ++first2;
        else
        {
            ++first1;
            ++first2;
        }
    }
    return copy(first1, last1, result);
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator
set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2, OutputIterator result)
{
    while (first1 != last1 &amp;&amp; first2 != last2)
    {
        if (*first1 &lt; *first2)
        {
            *result = *first1;
            ++result;
            ++first1;
        }
        else if (*first2 &lt; *first1)
        {
            *result = *first2;
            ++result;
            ++first2;
        }
        else
        {
            ++first1;
            ++first2;
        }
    }
    if (first2 == last2)
        return copy(first1, last1, result);
    return copy(first2, last2, result);
}

template &lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
OutputIterator
set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result, Compare comp)
{
    while (first1 != last1 &amp;&amp; first2 != last2)
    {
        if (comp(*first1, *first2))
        {
            *result = *first1;
            ++result;
            ++first1;
        }
        else if (comp(*first2, *first1))
        {
            *result = *first2;
            ++result;
            ++first2;
        }
        else
        {
            ++first1;
            ++first2;
        }
    }
    if (first2 == last2)
        return copy(first1, last1, result);
    return copy(first2, last2, result);
}

//  lib.alg.permutation.generators, permutations

template &lt;class BidirectionalIterator&gt;
bool
next_permutation(BidirectionalIterator first, BidirectionalIterator last)
{
    BidirectionalIterator i = last;
    if (first == last || first == --i)
        return false;
    while (true)
    {
        BidirectionalIterator ip1 = i;
        --i;
        if (*i &lt; *ip1)
        {
            BidirectionalIterator j = last;
            --j;
            while (!(*i &lt; *j))
                --j;
            iter_swap(i, j);
            reverse(ip1, last);
            return true;
        }
        if (i == first)
        {
            reverse(first, last);
            return false;
        }
    }
}

template &lt;class BidirectionalIterator, class Compare&gt;
bool
next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp)
{
    BidirectionalIterator i = last;
    if (first == last || first == --i)
        return false;
    while (true)
    {
        BidirectionalIterator ip1 = i;
        --i;
        if (comp(*i, *ip1))
        {
            BidirectionalIterator j = last;
            --j;
            while (!comp(*i, *j))
                --j;
            iter_swap(i, j);
            reverse(ip1, last);
            return true;
        }
        if (i == first)
        {
            reverse(first, last);
            return false;
        }
    }
}

template &lt;class BidirectionalIterator&gt;
bool
prev_permutation(BidirectionalIterator first, BidirectionalIterator last)
{
    BidirectionalIterator i = last;
    if (first == last || first == --i)
        return false;
    while (true)
    {
        BidirectionalIterator ip1 = i;
        --i;
        if (*ip1 &lt; *i)
        {
            BidirectionalIterator j = last;
            --j;
            while (!(*j &lt; *i))
                --j;
            iter_swap(i, j);
            reverse(ip1, last);
            return true;
        }
        if (i == first)
        {
            reverse(first, last);
            return false;
        }
    }
}

template &lt;class BidirectionalIterator, class Compare&gt;
bool
prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp)
{
    BidirectionalIterator i = last;
    if (first == last || first == --i)
        return false;
    while (true)
    {
        BidirectionalIterator ip1 = i;
        --i;
        if (comp(*ip1, *i))
        {
            BidirectionalIterator j = last;
            --j;
            while (!comp(*j, *i))
                --j;
            iter_swap(i, j);
            reverse(ip1, last);
            return true;
        }
        if (i == first)
        {
            reverse(first, last);
            return false;
        }
    }
}

#ifndef _MSL_NO_CPP_NAMESPACE
    } // namespace std 
#endif

#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _ALGORITHM

// hh 971220 fixed MOD_INCLUDE
// hh 971221  filename changed from algorithm.h
// hh 971221  include guards given standard compliant name
// hh 971221 added align and import pragmas
// hh 971221 expanded namespace macro
// hh 971221 added using namespace std::rel_ops;
// hh 971230 added RC_INVOKED wrapper
// hh 980520 Changed return on generate_n from OutputIterator to void
// hh 980520 Simplified unique_copy (but kept same basic algorithm)
// hh 980520 Rewrote reverse (used example from standard)
// hh 980520  Did analysis of the 3 rotate algorithms (forward, bidirect, and random)
//            The forward and rand access iterator versions have the same efficiency.
//            The bidirectional version is more expensive.
//            Simplifying the whole thing down to forward iterators.
// hh 980902 #ifdef'd out exception code when ndef MSIPL_EXCEPT
// hh 980911 unique_copy did not work for output iterators
// hh 990106 Changed __sort3 to work with iterators instead of references to relax the
//           requirement that *i returns a T&amp;.
// hh 990306 fixed bug in __partition when called with an empty range.
// hh 990510 Rewrote.
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>