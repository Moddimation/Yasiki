<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File deque - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-deque">File deque</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_1d8bcf55c9e1564519df8a05b1def2d1/"><strong>MSL_C++</strong></a> <strong>&gt;</strong> <a href="../dir_fc42de24ef3c14a5dea3aca327bd2ec9/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_f262df31fb8e04d575b9a3aa2e30ecf8/"><strong>Include</strong></a> <strong>&gt;</strong> <a href="../deque/"><strong>deque</strong></a></p>
<p><a href="../deque/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/12/09 17:58:48 $ 
 *  $Revision: 1.15.4.1 $ 
 *  $NoKeywords: $ 
 *
 *      Portions Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/**
 ** deque
 **/

#ifndef _DEQUE
#define _DEQUE

#include &lt;mslconfig&gt;

#include &lt;iterator&gt;
#include &lt;new&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;
#include &lt;cdeque&gt;

#ifndef RC_INVOKED

#pragma options align=native
#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
    namespace std {
#endif

template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
class deque
{
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;bool b&gt; struct chooser {};
    #endif
public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    class                                         iterator;
    class                                         const_iterator;
    typedef typename Allocator::size_type         size_type;
    typedef typename Allocator::difference_type   difference_type;
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef _STD::reverse_iterator&lt;iterator&gt;       reverse_iterator;
    typedef _STD::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
private:
    typedef _MSL_REBIND (pointer) buf_allocator;
    typedef __cdeque&lt;pointer, buf_allocator&gt; buf_type;
public:
    friend class iterator;
    class iterator
        : public _STD::iterator&lt;random_access_iterator_tag, T, difference_type, pointer, reference&gt;
    {
    public:
        iterator() {}
        reference operator * () const {return *cur_;}
        pointer operator -&gt; () const {return cur_;}
        iterator&amp; operator ++ ()
        {
            ++pos_;
            if (++cur_ == end_)
            {
                difference_type buf_size = end_ - *beg_;
                ++beg_;
                pointer beg = *beg_;
                cur_ = beg;
                end_ = beg + buf_size;
            }
            return *this;
        }
        iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}
        iterator&amp; operator -- ()
        {
            --pos_;
            pointer beg = *beg_;
            if (cur_ != beg)
                --cur_;
            else
            {
                difference_type buf_size = end_ - beg;
                --beg_;
                end_ = *beg_ + buf_size;
                cur_ = end_ - 1;
            }
            return *this;
        }
        iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}
        iterator&amp; operator += (difference_type n)
        {
            if (n &lt; 0)
                return (*this) -= -n;
            pos_ += n;
            difference_type room = end_ - cur_ ;
            if (n &lt; room)
                cur_ += n;
            else
            {
                difference_type buf_size = end_ - *beg_;
                n -= room;
                beg_ += n / buf_size + 1;
                pointer beg = *beg_;
                cur_ = beg + n % buf_size;
                end_ = beg + buf_size;
            }
            return *this;
        }
        iterator operator + (difference_type n) const {return iterator(*this) += n;}
        iterator&amp; operator -= (difference_type n)
        {
            if (n &lt; 0)
                return (*this) += -n;
            pos_ -= n;
            pointer beg = *beg_;
            difference_type room = cur_ - beg + 1;
            if (n &lt; room)
                cur_ -= n;
            else
            {
                difference_type buf_size = end_ - beg;
                n -= room;
                beg_ -= n / buf_size + 1;
                end_ = *beg_ + buf_size;
                cur_ = end_ - 1 - n % buf_size;
            }
            return *this;
        }
        iterator operator - (difference_type n) const {return iterator(*this) -= n;}
        difference_type operator - (const iterator&amp; rhs) const {return difference_type(pos_ - rhs.pos_);}
        reference operator [] (difference_type i) const {iterator tmp(*this); tmp += i; return *tmp;}
        friend bool operator ==(const iterator&amp; x, const iterator&amp; y) {return x.cur_ == y.cur_;}  // hh 990720
        friend bool operator !=(const iterator&amp; x, const iterator&amp; y) {return x.cur_ != y.cur_;}
        friend bool operator &lt; (const iterator&amp; x, const iterator&amp; y) {return x.pos_ &lt;  y.pos_;}
        friend bool operator &lt;=(const iterator&amp; x, const iterator&amp; y) {return x.pos_ &lt;= y.pos_;}
        friend bool operator &gt; (const iterator&amp; x, const iterator&amp; y) {return x.pos_ &gt;  y.pos_;}
        friend bool operator &gt;=(const iterator&amp; x, const iterator&amp; y) {return x.pos_ &gt;= y.pos_;}
        friend iterator operator + (difference_type n, const iterator&amp; rhs)
            {return iterator(rhs) += n;}
    private:
        buf_type::iterator beg_;
        pointer cur_;
        pointer end_;
        size_type pos_;

        iterator(const buf_type::iterator&amp; beg, pointer cur, pointer end, size_type pos)
            : beg_(beg),
              cur_(cur),
              end_(end),
              pos_(pos)
        {}

        friend class deque;
        friend class deque::const_iterator;
    };

    friend class const_iterator;
    class const_iterator
        : public _STD::iterator&lt;random_access_iterator_tag, T, difference_type, const_pointer, const_reference&gt;
    {
    public:
        const_iterator() {}
        const_iterator(const deque::iterator&amp; rhs) : beg_(rhs.beg_), cur_(rhs.cur_), end_(rhs.end_), pos_(rhs.pos_) {}
        const_reference operator * () const {return *cur_;}
        const_pointer operator -&gt; () const {return cur_;}
        const_iterator&amp; operator ++ ()
        {
            ++pos_;
            if (++cur_ == end_)
            {
                difference_type buf_size = end_ - *beg_;
                ++beg_;
                pointer beg = *beg_;
                cur_ = beg;
                end_ = beg + buf_size;
            }
            return *this;
        }
        const_iterator operator ++ (int) {const_iterator tmp(*this); ++(*this); return tmp;}
        const_iterator&amp; operator -- ()
        {
            --pos_;
            pointer beg = *beg_;
            if (cur_ != beg)
                --cur_;
            else
            {
                difference_type buf_size = end_ - beg;
                --beg_;
                end_ = *beg_ + buf_size;
                cur_ = end_ - 1;
            }
            return *this;
        }
        const_iterator operator -- (int) {const_iterator tmp(*this); --(*this); return tmp;}
        const_iterator&amp; operator += (difference_type n)
        {
            if (n &lt; 0)
                return (*this) -= -n;
            pos_ += n;
            difference_type room = end_ - cur_ ;
            if (n &lt; room)
                cur_ += n;
            else
            {
                difference_type buf_size = end_ - *beg_;
                n -= room;
                beg_ += n / buf_size + 1;
                pointer beg = *beg_;
                cur_ = beg + n % buf_size;
                end_ = beg + buf_size;
            }
            return *this;
        }
        const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}
        const_iterator&amp; operator -= (difference_type n)
        {
            if (n &lt; 0)
                return (*this) += -n;
            pos_ -= n;
            pointer beg = *beg_;
            difference_type room = cur_ - beg + 1;
            if (n &lt; room)
                cur_ -= n;
            else
            {
                difference_type buf_size = end_ - beg;
                n -= room;
                beg_ -= n / buf_size + 1;
                end_ = *beg_ + buf_size;
                cur_ = end_ - 1 - n % buf_size;
            }
            return *this;
        }
        const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}
        difference_type operator - (const const_iterator&amp; rhs) const {return difference_type(pos_ - rhs.pos_);}
        const_reference operator [] (difference_type i) const {const_iterator tmp(*this); tmp += i; return *tmp;}
        friend bool operator ==(const const_iterator&amp; x, const const_iterator&amp; y) {return x.cur_ == y.cur_;}  // hh 990720
        friend bool operator !=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.cur_ != y.cur_;}
        friend bool operator &lt; (const const_iterator&amp; x, const const_iterator&amp; y) {return x.pos_ &lt;  y.pos_;}
        friend bool operator &lt;=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.pos_ &lt;= y.pos_;}
        friend bool operator &gt; (const const_iterator&amp; x, const const_iterator&amp; y) {return x.pos_ &gt;  y.pos_;}
        friend bool operator &gt;=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.pos_ &gt;= y.pos_;}
        friend const_iterator operator + (difference_type n, const const_iterator&amp; rhs)
            {return const_iterator(rhs) += n;}
    private:
        buf_type::const_iterator beg_;
        const_pointer cur_;
        const_pointer end_;
        size_type pos_;

        const_iterator(const buf_type::const_iterator&amp; beg, const_pointer cur, const_pointer end, size_type pos)
            : beg_(beg),
              cur_(cur),
              end_(end),
              pos_(pos)
        {}

        friend class deque;
    };

    // _lib.deque.cons_ construct/copy/destroy:
    explicit deque(const Allocator&amp; = Allocator());
    explicit deque(size_type n, const T&amp; value = T(), const Allocator&amp; = Allocator());
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;class InputIterator&gt;
            inline
            deque(InputIterator first, InputIterator last, const Allocator&amp; a = Allocator())
                : alloc_(a, default_bufsize_s),
                  buf_(buf_allocator(a)),
                  start_(0),
                  size_(0)
            {
                choose_init(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
    #else
        deque(const_iterator first, const_iterator last, const Allocator&amp; = Allocator());
        deque(const value_type* first, const value_type* last, const Allocator&amp; = Allocator());
    #endif
    deque(const deque&lt;T,Allocator&gt;&amp; x);
    ~deque();
    deque&lt;T,Allocator&gt;&amp; operator=(const deque&lt;T,Allocator&gt;&amp; x);
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;class InputIterator&gt;
            inline
            void assign(InputIterator first, InputIterator last)
            {
                choose_assign(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
    #else
        void assign(const_iterator first, const_iterator last);
        void assign(const value_type* first, const value_type* last);
    #endif
    void assign(size_type n, const T&amp; t);
    allocator_type get_allocator() const;
    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;
    // _lib.deque.capacity_ capacity:
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, T c = T());
    bool      empty() const;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;
    // _lib.deque.modifiers_ modifiers:
    void push_front(const T&amp; x);
    void push_back(const T&amp; x);
    iterator insert(iterator position, const T&amp; x);
    void     insert(iterator position, size_type n, const T&amp; x);
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;class InputIterator&gt;
            inline
            void insert(iterator position, InputIterator first, InputIterator last)
            {
                choose_insert(position, first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
    #else
        void insert(iterator position, const_iterator first, const_iterator last);
        void insert(iterator position, const value_type* first, const value_type* last);
    #endif
    void pop_front();
    void pop_back();
    iterator erase(iterator position);
    iterator erase(iterator first, iterator last);
    void     swap(deque&lt;T,Allocator&gt;&amp;);
    void     clear();
private:
    static const size_type min_buf_size_s = 8;
    static const size_type min_foot_print_s = 512;
    static const size_type default_bufsize_s = sizeof(T) * min_buf_size_s &lt; min_foot_print_s ?
                                               min_foot_print_s / sizeof(T) : min_buf_size_s;
    _EmptyMemberOpt&lt;Allocator, size_type&gt; alloc_;  // alloc_.m_ is bufsize_
    buf_type buf_;
    size_type start_;
    size_type size_;

    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;class InputIterator&gt;
            inline
            void
            choose_init(InputIterator first, InputIterator last, chooser&lt;true&gt;)
            {
                init(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_init(InputIterator first, InputIterator last, chooser&lt;false&gt;)
            {
                init(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            init(InputIterator first, InputIterator last, input_iterator_tag)
            {
                #ifndef _MSL_NO_EXCEPTIONS
                try
                {
                #endif
                    for (; first != last; ++first)
                        push_back(*first);
                #ifndef _MSL_NO_EXCEPTIONS
                }
                catch (...)
                {
                    tear_down();
                    throw;
                }
                #endif
            }

        template &lt;class ForwardIterator&gt;
            void
            init(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
            {
                size_ = (size_type)distance(first, last);
                if (size_ &gt; max_size())
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;deque::construction length error&quot;);
                    #else
                        __msl_error(&quot;deque::construction length error\n&quot;);
                    #endif
                if (size_ &gt; 0)
                {
                    init_buf();
                    if (alloc_.m_ &lt; size_)
                        alloc_.m_ = size_;
                    pointer tmp = alloc_.allocate(alloc_.m_);
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        buf_.front() = tmp;
                        buf_.push_back(0);
                        start_ = (alloc_.m_ - size_) / 2;
                        uninitialized_copy(first, last, tmp + start_);
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        alloc_.deallocate(tmp, alloc_.m_);
                        throw;
                    }
                    #endif
                }
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_assign(InputIterator first, InputIterator last, chooser&lt;true&gt;)
            {
                assign(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_assign(InputIterator first, InputIterator last, chooser&lt;false&gt;)
            {
                do_assign(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            do_assign(InputIterator first, InputIterator last, input_iterator_tag)
            {
                deque temp(first, last, get_allocator());
                const deque&amp; tempr = temp;
                do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
            }

        template &lt;class ForwardIterator&gt;
            void
            do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
            {
                size_type n = (size_type)distance(first, last);
                if (n &gt; max_size())
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;deque::assign length error&quot;);
                    #else
                        __msl_error(&quot;deque::assign length error\n&quot;);
                    #endif
                if (buf_.empty())
                    init_buf();
                while (n &gt; capacity())
                {
                    pointer tmp = alloc_.allocate(alloc_.m_);
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        buf_.back() = tmp;
                        buf_.push_back(0);
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        alloc_.deallocate(tmp, alloc_.m_);
                        buf_.back() = 0;
                        throw;
                    }
                    #endif
                }
                destroy(begin(), end());
                size_ = 0;
                start_ = (capacity() - n) / 2;
                while (start_ &gt;= alloc_.m_)
                {
                    buf_.pop_back();
                    pointer&amp; p = buf_.back();
                    alloc_.deallocate(p, alloc_.m_);
                    p = 0;
                    start_ = (capacity() - n) / 2;
                }
                uninitialized_copy(first, last, begin());
                size_ = n;
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_insert(iterator position, InputIterator first, InputIterator last,
                chooser&lt;true&gt;)
            {
                insert(position, static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_insert(iterator position, InputIterator first, InputIterator last,
                chooser&lt;false&gt;)
            {
                do_insert(position, first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            do_insert(iterator position, InputIterator first, InputIterator last,
                input_iterator_tag)
            {
                deque temp(first, last, get_allocator());
                const deque&amp; tempr = temp;
                do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());
            }

        template &lt;class ForwardIterator&gt;
            void
            do_insert(iterator position, ForwardIterator first, ForwardIterator last,
                forward_iterator_tag)
            {
                size_type n = (size_type)distance(first, last);
                if (n == 0)
                    return;
                size_type ms = max_size();
                if (n &gt; ms || size_ &gt; ms - n)
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;deque::insert length error&quot;);
                    #else
                        __msl_error(&quot;deque::insert length error\n&quot;);
                    #endif
                if (buf_.empty())
                    init_buf();
                size_type pb = position.pos_ - start_;
                size_type pe = size_ - pb;
                if (pb &lt;= pe)  // hh 981210
                {
                    size_type new_buffers = 0;
                    size_type oldstart = start_;
                    buf_type orig_buf;
                    bool buf_invalidated = false;
                    if (start_ &lt; n)
                        buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);
                    else
                        start_ -= n;
                    size_type done = 0;
                    iterator beg = begin();
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        if (pb == 0) // insert at begin()
                            uninitialized_copy(first, last, beg);
                        else // pos in [1, size_ / 2)
                        {
                            iterator b_n = beg + difference_type(n);
                            iterator b_n_pb = b_n + difference_type(pb);
                            iterator b_pb = pb == n ? b_n : beg + difference_type(pb);
                            iterator t;
                            if (pb &gt; n)
                                t = beg + difference_type(2*n);
                            else
                                t = b_n_pb;
                            uninitialized_copy(b_n, t, beg);
                            ForwardIterator i = first;
                            if (pb &gt; n)
                            {
                                done = n;
                                copy(t, b_n_pb, b_n);
                                t = b_pb;
                            }
                            else if (pb &lt; n)
                            {
                                done = pb;
                                advance(i, difference_type(n - pb));
                                uninitialized_copy(first, i, b_pb);
                                done = n;
                                t = b_n;
                            }
                            else
                            {
                                done = n;
                                t = b_n;
                            }
                            copy(i, last, t);
                        }
                        size_ += n;
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        destroy(beg, beg + difference_type(done));
                        for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
                        {
                            alloc_.deallocate(buf_.front(), alloc_.m_);
                            buf_.pop_front();
                        }
                        if (buf_invalidated)
                            buf_.swap(orig_buf);
                        start_ = oldstart;
                        throw;
                    }
                    #endif
                }
                else // pos &gt;= size_ / 2
                {
                    size_type new_buffers = 0;
                    buf_type orig_buf;
                    bool buf_invalidated = false;
                    size_type e = capacity() - (start_ + size_);
                    bool done = false;
                    if (e &lt; n)
                        buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);
                    iterator t2;
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        if (pe == 0) // insert at end()
                            uninitialized_copy(first, last, end());
                        else // pos in [size_ / 2, size_)
                        {
                            iterator ei = end();
                            iterator e_n = ei - difference_type(n);
                            iterator e_pe = pe == n ? e_n : ei - difference_type(pe);
                            iterator t1;
                            if (pe &gt;= n)
                            {
                                t1 = e_n;
                                t2 = ei;
                            }
                            else
                            {
                                t1 = e_pe;
                                t2 = ei + difference_type(n - pe);
                            }
                            uninitialized_copy(t1, ei, t2);
                            done = true;
                            if (pe &gt;= n)
                            {
                                if (pe &gt; n)
                                    copy_backward(e_pe, e_n, ei);
                                copy(first, last, e_pe);
                            }
                            else if (n &gt; pe)
                            {
                                ForwardIterator i = first;
                                advance(i, difference_type(pe));
                                copy(first, i, e_pe);
                                uninitialized_copy(i, last, ei);
                            }
                        }
                        size_ += n;
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        if (done)
                            destroy(t2, end() + difference_type(n));
                        for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
                        {
                            buf_.pop_back();
                            pointer&amp; p = buf_.back();
                            alloc_.deallocate(p, alloc_.m_);
                            p = 0;
                        }
                        if (buf_invalidated)
                            buf_.swap(orig_buf);
                        throw;
                    }
                    #endif
                }
                invalidate_iterators();
            }

    #endif
    void init(size_type n, const T&amp; value);
    void tear_down();
    void destroy(iterator first, iterator last);
    void invalidate_iterators();
    iterator make_iterator(size_type pos);
    const_iterator make_iterator(size_type pos) const;
    void init_buf();
    size_type capacity() const;
    bool grow_buf_front(size_type oldstart, buf_type&amp; orig_buf, size_type&amp; new_buffers, size_type n);
    bool grow_buf_back(size_type e, buf_type&amp; orig_buf, size_type&amp; new_buffers, size_type n);
};

template &lt;class T, class Allocator&gt;
bool
operator==(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator&lt; (const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator!=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator&gt; (const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator&gt;=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator&lt;=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y);

// specialized algorithms:

template &lt;class T, class Allocator&gt;
void
swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);

// Implementation deque

template &lt;class T, class Allocator&gt;
inline
void
deque&lt;T, Allocator&gt;::invalidate_iterators()
{
    while (start_ &gt;= 3 * alloc_.m_ / 2)
    {
        alloc_.deallocate(buf_.front(), alloc_.m_);
        buf_.pop_front();
        start_ -= alloc_.m_;
    }
}

template &lt;class T, class Allocator&gt;
typename deque&lt;T, Allocator&gt;::iterator
deque&lt;T, Allocator&gt;::make_iterator(size_type pos)
{
    buf_type::iterator b = buf_.begin();
    pointer cur;
    pointer beg;
    if (pos &lt; alloc_.m_)
    {
        if (!buf_.empty())
            beg = *b;
        else
            beg = 0;
        cur = beg + pos;
    }
    else
    {
        b += difference_type(pos / alloc_.m_);
        beg = *b;
        cur = beg + pos % alloc_.m_;
    }
    return iterator(b, cur, beg + alloc_.m_, pos);
}

template &lt;class T, class Allocator&gt;
typename deque&lt;T, Allocator&gt;::const_iterator
deque&lt;T, Allocator&gt;::make_iterator(size_type pos) const
{
    buf_type::const_iterator b = buf_.begin();
    const_pointer cur;
    const_pointer beg;
    if (pos &lt; alloc_.m_)
    {
        if (!buf_.empty())
            beg = *b;
        else
            beg = 0;
        cur = beg + pos;
    }
    else
    {
        b += difference_type(pos / alloc_.m_);
        beg = *b;
        cur = beg + pos % alloc_.m_;
    }
    return const_iterator(b, cur, beg + alloc_.m_, pos);
}

template &lt;class T, class Allocator&gt;
inline
void
deque&lt;T, Allocator&gt;::init_buf()
{
    buf_.reserve(2);
    buf_.resize(1);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::size_type
deque&lt;T, Allocator&gt;::capacity() const
{
    return (buf_.size() - 1) * alloc_.m_;
}

template &lt;class T, class Allocator&gt;
bool
deque&lt;T, Allocator&gt;::grow_buf_front(size_type oldstart, buf_type&amp; orig_buf, size_type&amp; new_buffers, size_type n)
{
    bool buf_invalidated = false;
    size_type nc = n;
    nc -= start_;
    while (true)
    {
        pointer tmp = alloc_.allocate(alloc_.m_);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            if (!buf_invalidated &amp;&amp; buf_.size() == buf_.capacity())
            {
                buf_.swap(orig_buf);
                buf_invalidated = true;
                buf_.reserve(2*orig_buf.capacity());
                buf_.assign(orig_buf.begin(), orig_buf.end());
            }
            buf_.push_front(tmp);
            ++new_buffers;  // hh 981210
            start_ += alloc_.m_;
            if (nc &lt;= alloc_.m_)
            {
                if (size_ != 0)  // hh 981210
                    start_ -= n;
                else
                    start_ = (capacity() - n) / 2;
                break;
            }
            nc -= alloc_.m_;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(tmp, alloc_.m_);
            for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
            {
                alloc_.deallocate(buf_.front(), alloc_.m_);
                buf_.pop_front();
            }
            if (buf_invalidated)
                buf_.swap(orig_buf);
            start_ = oldstart;
            throw;
        }
        #endif
    }
    return buf_invalidated;
}

template &lt;class T, class Allocator&gt;
bool
deque&lt;T, Allocator&gt;::grow_buf_back(size_type e, buf_type&amp; orig_buf, size_type&amp; new_buffers, size_type n)
{
    bool buf_invalidated = false;
    size_type nc = n;
    nc -= e;
    while (true)
    {
        pointer tmp = alloc_.allocate(alloc_.m_);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            if (!buf_invalidated &amp;&amp; buf_.size() == buf_.capacity())
            {
                buf_.swap(orig_buf);
                buf_invalidated = true;
                buf_.reserve(2*orig_buf.capacity());
                buf_.assign(orig_buf.begin(), orig_buf.end());
            }
            buf_.back() = tmp;
            buf_.push_back(0);
            ++new_buffers;
            if (nc &lt;= alloc_.m_)
                break;
            nc -= alloc_.m_;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(tmp, alloc_.m_);
            if (!buf_.empty())
                buf_.back() = 0;
            for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
            {
                buf_.pop_back();
                pointer&amp; p = buf_.back();
                alloc_.deallocate(p, alloc_.m_);
                p = 0;
            }
            if (buf_invalidated)
                buf_.swap(orig_buf);
            throw;
        }
        #endif
    }
    return buf_invalidated;
}

template &lt;class T, class Allocator&gt;
deque&lt;T, Allocator&gt;::deque(const Allocator&amp; a)
    : alloc_(a, default_bufsize_s),
#ifndef _MSL_NO_MEMBER_TEMPLATE
      buf_(buf_allocator(a)),
#endif
      start_(0),
      size_(0)
{
}

template &lt;class T, class Allocator&gt;
deque&lt;T, Allocator&gt;::deque(size_type n, const T&amp; value, const Allocator&amp; a)
    : alloc_(a, default_bufsize_s),
#ifndef _MSL_NO_MEMBER_TEMPLATE
      buf_(buf_allocator(a)),
#endif
      start_(0),
      size_(0)
{
    init(n, value);
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

    template &lt;class T, class Allocator&gt;
    deque&lt;T, Allocator&gt;::deque(const_iterator first, const_iterator last, const Allocator&amp; a)
        : alloc_(a, default_bufsize_s),
    #ifndef _MSL_NO_MEMBER_TEMPLATE
          buf_(buf_allocator(a)),
    #endif
          start_(0),
          size_(size_type(last - first))
    {
        if (size_ &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::construction length error&quot;);
            #else
                __msl_error(&quot;deque::construction length error\n&quot;);
            #endif
        if (size_ &gt; 0)
        {
            init_buf();
            if (alloc_.m_ &lt; size_)
                alloc_.m_ = size_;
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                buf_.front() = tmp;
                buf_.push_back(0);
                start_ = (alloc_.m_ - size_) / 2;
                uninitialized_copy(first, last, tmp + start_);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                throw;
            }
            #endif
        }
    }

    template &lt;class T, class Allocator&gt;
    deque&lt;T, Allocator&gt;::deque(const value_type* first, const value_type* last, const Allocator&amp; a)
        : alloc_(a, default_bufsize_s),
    #ifndef _MSL_NO_MEMBER_TEMPLATE
          buf_(buf_allocator(a)),
    #endif
          start_(0),
          size_(size_type(last - first))
    {
        if (size_ &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::construction length error&quot;);
            #else
                __msl_error(&quot;deque::construction length error\n&quot;);
            #endif
        if (size_ &gt; 0)
        {
            init_buf();
            if (alloc_.m_ &lt; size_)
                alloc_.m_ = size_;
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                buf_.front() = tmp;
                buf_.push_back(0);
                start_ = (alloc_.m_ - size_) / 2;
                uninitialized_copy(first, last, tmp + start_);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                throw;
            }
            #endif
        }
    }

#endif

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::init(size_type n, const T&amp; value)
{
    if (n &gt; max_size())
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;deque::construction length error&quot;);
        #else
            __msl_error(&quot;deque::construction length error\n&quot;);
        #endif
    if (n &gt; 0)
    {
        init_buf();
        if (alloc_.m_ &lt; n)
            alloc_.m_ = n;
        pointer tmp = alloc_.allocate(alloc_.m_);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            buf_.front() = tmp;
            buf_.push_back(0);
            size_ = n;
            start_ = (alloc_.m_ - size_) / 2;
            uninitialized_fill_n(tmp + start_, size_, value);
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(tmp, alloc_.m_);
            throw;
        }
        #endif
    }
}

template &lt;class T, class Allocator&gt;
deque&lt;T, Allocator&gt;::deque(const deque&lt;T,Allocator&gt;&amp; x)
    : alloc_(x.alloc_, default_bufsize_s),
#ifndef _MSL_NO_MEMBER_TEMPLATE
      buf_(buf_allocator(alloc_)),
#endif
      start_(0),
      size_(x.size_)
{
    if (size_ &gt; 0)
    {
        init_buf();
        if (alloc_.m_ &lt; size_)
            alloc_.m_ = size_;
        pointer tmp = alloc_.allocate(alloc_.m_);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            buf_.front() = tmp;
            buf_.push_back(0);
            start_ = (alloc_.m_ - size_) / 2;
            uninitialized_copy(x.begin(), x.end(), tmp + start_);
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(tmp, alloc_.m_);
            throw;
        }
        #endif
    }
}

template &lt;class T, class Allocator&gt;
inline
deque&lt;T, Allocator&gt;::~deque()
{
    tear_down();
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::tear_down()
{
    if (!buf_.empty())
    {
        destroy(begin(), end());
        buf_type::iterator e = --buf_.end();
        for (buf_type::iterator i = buf_.begin(); i != e; ++i)
            alloc_.deallocate(*i, alloc_.m_);
    }
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::destroy(iterator first, iterator last)
{
    if (first != last)
    {
        size_type diff = size_type(last - first);
        size_type i = first.pos_;
        size_type w = i / alloc_.m_;
        i %= alloc_.m_;
        size_type e = min(alloc_.m_, i + diff);
        buf_type::iterator bi = buf_.begin() + difference_type(w);
        pointer p = *bi;
        __destroy(p + i, p + e);
        diff -= e - i;
        if (diff == 0)
            return;
        ++bi;
        while (diff &gt;= alloc_.m_)
        {
            p = *bi;
            __destroy(p, p + alloc_.m_);
            ++bi;
            diff -= alloc_.m_;
        }
        if (diff &gt; 0)
        {
            p = *bi;
            __destroy(p, p + diff);
        }
    }
}

template &lt;class T, class Allocator&gt;
inline
deque&lt;T,Allocator&gt;&amp;
deque&lt;T, Allocator&gt;::operator=(const deque&lt;T,Allocator&gt;&amp; x)
{
    if (this != &amp;x)
        assign(x.begin(), x.end());
    return *this;
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

    template &lt;class T, class Allocator&gt;
    void
    deque&lt;T, Allocator&gt;::assign(const_iterator first, const_iterator last)
    {
        size_type n = (size_type)distance(first, last);
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::assign length error&quot;);
            #else
                __msl_error(&quot;deque::assign length error\n&quot;);
            #endif
        if (buf_.empty())
            init_buf();
        while (n &gt; capacity())
        {
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                buf_.back() = tmp;
                buf_.push_back(0);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                buf_.back() = 0;
                throw;
            }
            #endif
        }
        destroy(begin(), end());
        size_ = 0;
        start_ = (capacity() - n) / 2;
        while (start_ &gt;= alloc_.m_)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
            start_ = (capacity() - n) / 2;
        }
        uninitialized_copy(first, last, begin());
        size_ = n;
    }

    template &lt;class T, class Allocator&gt;
    void
    deque&lt;T, Allocator&gt;::assign(const value_type* first, const value_type* last)
    {
        size_type n = (size_type)distance(first, last);
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::assign length error&quot;);
            #else
                __msl_error(&quot;deque::assign length error\n&quot;);
            #endif
        if (buf_.empty())
            init_buf();
        while (n &gt; capacity())
        {
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                buf_.back() = tmp;
                buf_.push_back(0);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                buf_.back() = 0;
                throw;
            }
            #endif
        }
        destroy(begin(), end());
        size_ = 0;
        start_ = (capacity() - n) / 2;
        while (start_ &gt;= alloc_.m_)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
            start_ = (capacity() - n) / 2;
        }
        uninitialized_copy(first, last, begin());
        size_ = n;
    }

#endif

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::assign(size_type n, const T&amp; t)
{
    if (n &gt; max_size())
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;deque::assign length error&quot;);
        #else
            __msl_error(&quot;deque::assign length error\n&quot;);
        #endif
    if (buf_.empty())
        init_buf();
    while (n &gt; capacity())
    {
        pointer tmp = alloc_.allocate(alloc_.m_);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            buf_.back() = tmp;
            buf_.push_back(0);
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(tmp, alloc_.m_);
            buf_.back() = 0;
            throw;
        }
        #endif
    }
    destroy(begin(), end());
    size_ = 0;
    start_ = (capacity() - n) / 2;
    while (start_ &gt;= alloc_.m_)
    {
        buf_.pop_back();
        pointer&amp; p = buf_.back();
        alloc_.deallocate(p, alloc_.m_);
        p = 0;
        start_ = (capacity() - n) / 2;
    }
    uninitialized_fill_n(begin(), n, t);
    size_ = n;
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::allocator_type
deque&lt;T, Allocator&gt;::get_allocator() const
{
    return alloc_;
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::iterator
deque&lt;T, Allocator&gt;::begin()
{
    return make_iterator(start_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::const_iterator
deque&lt;T, Allocator&gt;::begin() const
{
    return make_iterator(start_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::iterator
deque&lt;T, Allocator&gt;::end()
{   
    return make_iterator(start_ + size_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::const_iterator
deque&lt;T, Allocator&gt;::end() const
{   
    return make_iterator(start_ + size_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::reverse_iterator
deque&lt;T, Allocator&gt;::rbegin()
{
    return reverse_iterator(end());
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::const_reverse_iterator
deque&lt;T, Allocator&gt;::rbegin() const
{
    return const_reverse_iterator(end());
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::reverse_iterator
deque&lt;T, Allocator&gt;::rend()
{
    return reverse_iterator(begin());
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::const_reverse_iterator
deque&lt;T, Allocator&gt;::rend() const
{
    return const_reverse_iterator(begin());
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::size_type
deque&lt;T, Allocator&gt;::size() const
{
    return size_;
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::size_type
deque&lt;T, Allocator&gt;::max_size() const
{
    return alloc_.max_size();
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::resize(size_type sz, T c)
{
    if (sz &gt; size())
        insert(end(), sz-size(), c);
    else if (sz &lt; size())
        erase(begin() + difference_type(sz), end());
}

template &lt;class T, class Allocator&gt;
inline
bool
deque&lt;T, Allocator&gt;::empty() const
{
    return size_ == 0;
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::reference
deque&lt;T, Allocator&gt;::operator[](size_type n)
{
    size_type i = n + start_;
    return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::const_reference
deque&lt;T, Allocator&gt;::operator[](size_type n) const
{
    size_type i = n + start_;
    return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template &lt;class T, class Allocator&gt;
typename deque&lt;T, Allocator&gt;::reference
deque&lt;T, Allocator&gt;::at(size_type n)
{
    if (n &gt;= size_)
        #ifndef _MSL_NO_EXCEPTIONS
            throw out_of_range(&quot;deque::at index out of range&quot;);
        #else
            __msl_error(&quot;deque::at index out of range&quot;);
        #endif
    size_type i = n + start_;
    return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template &lt;class T, class Allocator&gt;
typename deque&lt;T, Allocator&gt;::const_reference
deque&lt;T, Allocator&gt;::at(size_type n) const
{
    if (n &gt;= size_)
        #ifndef _MSL_NO_EXCEPTIONS
            throw out_of_range(&quot;deque::at index out of range&quot;);
        #else
            __msl_error(&quot;deque::at index out of range&quot;);
        #endif
    size_type i = n + start_;
    return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::reference
deque&lt;T, Allocator&gt;::front()
{
    return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::const_reference
deque&lt;T, Allocator&gt;::front() const
{
    return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::reference
deque&lt;T, Allocator&gt;::back()
{
    size_type i = start_ + size_ - 1;
    return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::const_reference
deque&lt;T, Allocator&gt;::back() const
{
    size_type i = start_ + size_ - 1;
    return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::push_front(const T&amp; x)
{
    if (size_ &gt; max_size() - 1)
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;deque::push_front length error&quot;);
        #else
            __msl_error(&quot;deque::push_front length error\n&quot;);
        #endif
    if (buf_.empty())
        init_buf();
    size_type new_buffers = 0;
    size_type oldstart = start_;
    buf_type orig_buf;
    bool buf_invalidated = false;
    if (start_ == 0)
        buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, 1);
    else
        --start_;
    #ifndef _MSL_NO_EXCEPTIONS
    try
    {
    #endif
        if (start_ &lt; alloc_.m_)
            new (buf_.front() + start_) value_type(x);
        else
            new (buf_[start_ / alloc_.m_] + start_ % alloc_.m_) value_type(x);
        ++size_;
    #ifndef _MSL_NO_EXCEPTIONS
    }
    catch (...)
    {
        if (new_buffers)
        {
            alloc_.deallocate(buf_.front(), alloc_.m_);
            buf_.pop_front();
        }
        if (buf_invalidated)
            buf_.swap(orig_buf);
        start_ = oldstart;
        throw;
    }
    #endif
    invalidate_iterators();
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::push_back(const T&amp; x)
{
    if (size_ &gt; max_size() - 1)
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;deque::push_back length error&quot;);
        #else
            __msl_error(&quot;deque::push_back length error\n&quot;);
        #endif
    if (buf_.empty())
        init_buf();
    {
        size_type new_buffers = 0;
        buf_type orig_buf;
        bool buf_invalidated = false;
        if (capacity() == start_ + size_)
            buf_invalidated = grow_buf_back(0, orig_buf, new_buffers, 1);
        size_type pos = start_ + size_;
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            if (pos &lt; alloc_.m_)
                new (buf_.front() + pos) value_type(x);
            else
                new (buf_[pos / alloc_.m_] + pos % alloc_.m_) value_type(x);
            ++size_;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
            {
                buf_.pop_back();
                pointer&amp; p = buf_.back();
                alloc_.deallocate(p, alloc_.m_);
                p = 0;
            }
            if (buf_invalidated)
                buf_.swap(orig_buf);
            throw;
        }
        #endif
    }
    invalidate_iterators();
}

template &lt;class T, class Allocator&gt;
typename deque&lt;T, Allocator&gt;::iterator
deque&lt;T, Allocator&gt;::insert(iterator position, const T&amp; x)
{
    difference_type pos = position - begin();
    insert(position, 1, x);
    return begin() + pos;
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::insert(iterator position, size_type n, const T&amp; x)
{
    if (n == 0)
        return;
    size_type ms = max_size();
    if (n &gt; ms || size_ &gt; ms - n)
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;deque::insert length error&quot;);
        #else
            __msl_error(&quot;deque::insert length error\n&quot;);
        #endif
    if (buf_.empty())
        init_buf();
    size_type pb = position.pos_ - start_;
    size_type pe = size_ - pb;
    if (pb &lt;= pe)  // hh 981210
    {
        size_type new_buffers = 0;
        size_type oldstart = start_;
        buf_type orig_buf;
        bool buf_invalidated = false;
        if (start_ &lt; n)
            buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);
        else
            start_ -= n;
        size_type done = 0;
        iterator beg = begin();
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            if (pb == 0) // insert at begin()
                uninitialized_fill_n(beg, n, x);
            else // pos in [1, size_ / 2)
            {
                iterator b_n = beg + difference_type(n);
                iterator b_n_pb = b_n + difference_type(pb);
                iterator b_pb = pb == n ? b_n : beg + difference_type(pb);
                iterator t;
                if (pb &gt; n)
                    t = beg + difference_type(2*n);
                else
                    t = b_n_pb;
                uninitialized_copy(b_n, t, beg);
                if (pb &gt; n)
                {
                    done = n;
                    copy(t, b_n_pb, b_n);
                    t = b_pb;
                }
                else if (pb &lt; n)
                {
                    done = pb;
                    uninitialized_fill(b_pb, b_n, x);
                    done = n;
                    t = b_n;
                }
                else
                {
                    done = n;
                    t = b_n;
                }
                fill(t, b_n_pb, x);
            }
            size_ += n;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            destroy(beg, beg + difference_type(done));
            for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
            {
                alloc_.deallocate(buf_.front(), alloc_.m_);
                buf_.pop_front();
            }
            if (buf_invalidated)
                buf_.swap(orig_buf);
            start_ = oldstart;
            throw;
        }
        #endif
    }
    else // pos &gt;= size_ / 2
    {
        size_type new_buffers = 0;
        buf_type orig_buf;
        bool buf_invalidated = false;
        size_type e = capacity() - (start_ + size_);
        bool done = false;
        if (e &lt; n)
            buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);
        iterator t2;
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            if (pe == 0) // insert at end()
                uninitialized_fill_n(end(), n, x);
            else // pos in [size_ / 2, size_)
            {
                iterator ei = end();
                iterator e_n = ei - difference_type(n);
                iterator e_pe = pe == n ? e_n : ei - difference_type(pe);
                iterator t1;
                if (pe &gt;= n)
                {
                    t1 = e_n;
                    t2 = ei;
                }
                else
                {
                    t1 = e_pe;
                    t2 = ei + difference_type(n - pe);
                }
                uninitialized_copy(t1, ei, t2);
                done = true;
                if (pe &gt;= n)
                {
                    if (pe &gt; n)
                        copy_backward(e_pe, e_n, ei);
                    t1 = pe == n ? ei : ei - difference_type(pe - n);
                    fill(e_pe, t1, x);
                }
                else if (n &gt; pe)
                {
                    fill(e_pe, ei, x);
                    uninitialized_fill(ei, t2, x);
                }
            }
            size_ += n;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            if (done)
                destroy(t2, end() + difference_type(n));
            for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
            {
                buf_.pop_back();
                pointer&amp; p = buf_.back();
                alloc_.deallocate(p, alloc_.m_);
                p = 0;
            }
            if (buf_invalidated)
                buf_.swap(orig_buf);
            throw;
        }
        #endif
    }
    invalidate_iterators();
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

    template &lt;class T, class Allocator&gt;
    void
    deque&lt;T, Allocator&gt;::insert(iterator position, const_iterator first, const_iterator last)
    {
        size_type n = (size_type)distance(first, last);
        if (n == 0)
            return;
        size_type ms = max_size();
        if (n &gt; ms || size_ &gt; ms - n)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::insert length error&quot;);
            #else
                __msl_error(&quot;deque::insert length error\n&quot;);
            #endif
        if (buf_.empty())
            init_buf();
        size_type pb = position.pos_ - start_;
        size_type pe = size_ - pb;
        if (pb &lt;= pe)  // hh 981210
        {
            size_type new_buffers = 0;
            size_type oldstart = start_;
            buf_type orig_buf;
            bool buf_invalidated = false;
            if (start_ &lt; n)
                buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);
            else
                start_ -= n;
            size_type done = 0;
            iterator beg = begin();
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                if (pb == 0) // insert at begin()
                    uninitialized_copy(first, last, beg);
                else // pos in [1, size_ / 2)
                {
                    iterator b_n = beg + difference_type(n);
                    iterator b_n_pb = b_n + difference_type(pb);
                    iterator b_pb = pb == n ? b_n : beg + difference_type(pb);
                    iterator t;
                    if (pb &gt; n)
                        t = beg + difference_type(2*n);
                    else
                        t = b_n_pb;
                    uninitialized_copy(b_n, t, beg);
                    const_iterator i = first;
                    if (pb &gt; n)
                    {
                        done = n;
                        copy(t, b_n_pb, b_n);
                        t = b_pb;
                    }
                    else if (pb &lt; n)
                    {
                        done = pb;
                        advance(i, difference_type(n - pb));
                        uninitialized_copy(first, i, b_pb);
                        done = n;
                        t = b_n;
                    }
                    else
                    {
                        done = n;
                        t = b_n;
                    }
                    copy(i, last, t);
                }
                size_ += n;
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                destroy(beg, beg + difference_type(done));
                for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
                {
                    alloc_.deallocate(buf_.front(), alloc_.m_);
                    buf_.pop_front();
                }
                if (buf_invalidated)
                    buf_.swap(orig_buf);
                start_ = oldstart;
                throw;
            }
            #endif
        }
        else // pos &gt;= size_ / 2
        {
            size_type new_buffers = 0;
            buf_type orig_buf;
            bool buf_invalidated = false;
            size_type e = capacity() - (start_ + size_);
            bool done = false;
            if (e &lt; n)
                buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);
            iterator t2;
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                if (pe == 0) // insert at end()
                    uninitialized_copy(first, last, end());
                else // pos in [size_ / 2, size_)
                {
                    iterator ei = end();
                    iterator e_n = ei - difference_type(n);
                    iterator e_pe = pe == n ? e_n : ei - difference_type(pe);
                    iterator t1;
                    if (pe &gt;= n)
                    {
                        t1 = e_n;
                        t2 = ei;
                    }
                    else
                    {
                        t1 = e_pe;
                        t2 = ei + difference_type(n - pe);
                    }
                    uninitialized_copy(t1, ei, t2);
                    done = true;
                    if (pe &gt;= n)
                    {
                        if (pe &gt; n)
                            copy_backward(e_pe, e_n, ei);
                        copy(first, last, e_pe);
                    }
                    else if (n &gt; pe)
                    {
                        const_iterator i = first;
                        advance(i, difference_type(pe));
                        copy(first, i, e_pe);
                        uninitialized_copy(i, last, ei);
                    }
                }
                size_ += n;
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                if (done)
                    destroy(t2, end() + difference_type(n));
                for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
                {
                    buf_.pop_back();
                    pointer&amp; p = buf_.back();
                    alloc_.deallocate(p, alloc_.m_);
                    p = 0;
                }
                if (buf_invalidated)
                    buf_.swap(orig_buf);
                throw;
            }
            #endif
        }
        invalidate_iterators();
    }

    template &lt;class T, class Allocator&gt;
    void
    deque&lt;T, Allocator&gt;::insert(iterator position, const value_type* first, const value_type* last)
    {
        size_type n = (size_type)distance(first, last);
        if (n == 0)
            return;
        size_type ms = max_size();
        if (n &gt; ms || size_ &gt; ms - n)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::insert length error&quot;);
            #else
                __msl_error(&quot;deque::insert length error\n&quot;);
            #endif
        if (buf_.empty())
            init_buf();
        size_type pb = position.pos_ - start_;
        size_type pe = size_ - pb;
        if (pb &lt;= pe)  // hh 981210
        {
            size_type new_buffers = 0;
            size_type oldstart = start_;
            buf_type orig_buf;
            bool buf_invalidated = false;
            if (start_ &lt; n)
                buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);
            else
                start_ -= n;
            size_type done = 0;
            iterator beg = begin();
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                if (pb == 0) // insert at begin()
                    uninitialized_copy(first, last, beg);
                else // pos in [1, size_ / 2)
                {
                    iterator b_n = beg + difference_type(n);
                    iterator b_n_pb = b_n + difference_type(pb);
                    iterator b_pb = pb == n ? b_n : beg + difference_type(pb);
                    iterator t;
                    if (pb &gt; n)
                        t = beg + difference_type(2*n);
                    else
                        t = b_n_pb;
                    uninitialized_copy(b_n, t, beg);
                    const value_type* i = first;
                    if (pb &gt; n)
                    {
                        done = n;
                        copy(t, b_n_pb, b_n);
                        t = b_pb;
                    }
                    else if (pb &lt; n)
                    {
                        done = pb;
                        advance(i, difference_type(n - pb));
                        uninitialized_copy(first, i, b_pb);
                        done = n;
                        t = b_n;
                    }
                    else
                    {
                        done = n;
                        t = b_n;
                    }
                    copy(i, last, t);
                }
                size_ += n;
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                destroy(beg, beg + difference_type(done));
                for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
                {
                    alloc_.deallocate(buf_.front(), alloc_.m_);
                    buf_.pop_front();
                }
                if (buf_invalidated)
                    buf_.swap(orig_buf);
                start_ = oldstart;
                throw;
            }
            #endif
        }
        else // pos &gt;= size_ / 2
        {
            size_type new_buffers = 0;
            buf_type orig_buf;
            bool buf_invalidated = false;
            size_type e = capacity() - (start_ + size_);
            bool done = false;
            if (e &lt; n)
                buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);
            iterator t2;
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                if (pe == 0) // insert at end()
                    uninitialized_copy(first, last, end());
                else // pos in [size_ / 2, size_)
                {
                    iterator ei = end();
                    iterator e_n = ei - difference_type(n);
                    iterator e_pe = pe == n ? e_n : ei - difference_type(pe);
                    iterator t1;
                    if (pe &gt;= n)
                    {
                        t1 = e_n;
                        t2 = ei;
                    }
                    else
                    {
                        t1 = e_pe;
                        t2 = ei + difference_type(n - pe);
                    }
                    uninitialized_copy(t1, ei, t2);
                    done = true;
                    if (pe &gt;= n)
                    {
                        if (pe &gt; n)
                            copy_backward(e_pe, e_n, ei);
                        copy(first, last, e_pe);
                    }
                    else if (n &gt; pe)
                    {
                        const value_type* i = first;
                        advance(i, difference_type(pe));
                        copy(first, i, e_pe);
                        uninitialized_copy(i, last, ei);
                    }
                }
                size_ += n;
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                if (done)
                    destroy(t2, end() + difference_type(n));
                for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
                {
                    buf_.pop_back();
                    pointer&amp; p = buf_.back();
                    alloc_.deallocate(p, alloc_.m_);
                    p = 0;
                }
                if (buf_invalidated)
                    buf_.swap(orig_buf);
                throw;
            }
            #endif
        }
        invalidate_iterators();
    }

#endif

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::pop_front()
{
    __destroy(&amp;front());
    ++start_;
    if (--size_ == 0)
    {
        for (size_type i = buf_.size() - 2; i &gt; 0; --i)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
        }
        start_ = alloc_.m_ / 2;
    }
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::pop_back()
{
    __destroy(&amp;back());
    --size_;
    while (capacity() - (start_ + size_) &gt;= 3 * alloc_.m_ / 2)
    {
        buf_.pop_back();
        pointer&amp; p = buf_.back();
        alloc_.deallocate(p, alloc_.m_);
        p = 0;
    }
    if (size_ == 0)
    {
        for (size_type i = buf_.size() - 2; i &gt; 0; --i)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
        }
        start_ = alloc_.m_ / 2;
    }
}

template &lt;class T, class Allocator&gt;
inline
typename deque&lt;T, Allocator&gt;::iterator
deque&lt;T, Allocator&gt;::erase(iterator position)
{
    return erase(position, position + 1);
}

template &lt;class T, class Allocator&gt;
typename deque&lt;T, Allocator&gt;::iterator
deque&lt;T, Allocator&gt;::erase(iterator first, iterator last)
{
    if (first == last)
        return first;
    const size_type pb = first.pos_ - start_;
    const size_type pe = size_ - (last.pos_ - start_);
    const size_type diff = size_type(last - first);
    if (pb &lt; pe)
    {
        if (pb == 0)  // erase from beginning, no copying necessary
        {
            destroy(first, last);
            start_ += diff;
            size_ -= diff;
        }
        else  // erase from beginning, needs copying
        {
            iterator bi = begin();
            copy_backward(bi, first, last);
            destroy(bi, bi + difference_type(diff));
            start_ += diff;
            size_ -= diff;
            invalidate_iterators();
        }
    }
    else  // pb &gt;= pe - erase from end
    {
        if (pe == 0)  // erase from end, no copying necessary
            destroy(first, last);
        else  // erase from end, needs copying
        {
            iterator ei = end();
            copy(last, ei, first);
            destroy(first + difference_type(pe), ei);
            invalidate_iterators();
        }
        size_ -= diff;
        while (capacity() - (start_ + size_) &gt;= 3 * alloc_.m_ / 2)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
        }
    }
    if (size_ == 0)
    {
        for (size_type i = buf_.size() - 2; i &gt; 0; --i)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
        }
        start_ = alloc_.m_ / 2;
    }
    return make_iterator(start_ + pb);
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::swap(deque&lt;T,Allocator&gt;&amp; x)
{
    if (this != &amp;x)
    {
        _STD::swap(alloc_, x.alloc_);
        _STD::swap(buf_, x.buf_);
        _STD::swap(start_, x.start_);
        _STD::swap(size_, x.size_);
    }
}

template &lt;class T, class Allocator&gt;
void
deque&lt;T, Allocator&gt;::clear()
{
    if (!buf_.empty())  // hh 981209
    {
        destroy(begin(), end());
        size_ = 0;
        for (size_type i = buf_.size() - 2; i &gt; 0; --i)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
        }
        start_ = alloc_.m_ / 2;
    }
}

template &lt;class T, class Allocator&gt;
inline
bool
operator==(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y)
{
    return x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());
}

template &lt;class T, class Allocator&gt;
inline
bool
operator!=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y)
{
    return !(x == y);
}

template &lt;class T, class Allocator&gt;
inline
bool
operator&lt; (const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y)
{
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template &lt;class T, class Allocator&gt;
inline
bool
operator&gt; (const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y)
{
    return y &lt; x;
}

template &lt;class T, class Allocator&gt;
inline
bool
operator&gt;=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y)
{
    return !(x &lt; y);
}

template &lt;class T, class Allocator&gt;
inline
bool
operator&lt;=(const deque&lt;T,Allocator&gt;&amp; x, const deque&lt;T,Allocator&gt;&amp; y)
{
    return !(y &lt; x);
}

template &lt;class T, class Allocator&gt;
inline
void
swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y)
{
    x.swap(y);
}

#if !defined(_MSL_NO_PARTIAL_SPECIALIZATION) &amp;&amp; !defined(_MSL_NO_MEMBER_TEMPLATE) &amp;&amp; !defined(_Inhibit_Container_Optimization)

    // Specialize for T* to save on code bloat

    // void*

    template &lt;class Allocator&gt;
    class deque&lt;void*, Allocator&gt;
    {
        template &lt;bool b&gt; struct chooser {};
    public:
        // types:
        typedef typename Allocator::reference         reference;
        typedef typename Allocator::const_reference   const_reference;
        class                                         iterator;
        class                                         const_iterator;
        typedef typename Allocator::size_type         size_type;
        typedef typename Allocator::difference_type   difference_type;
        typedef void*                                 value_type;
        typedef Allocator                             allocator_type;
        typedef typename Allocator::pointer           pointer;
        typedef typename Allocator::const_pointer     const_pointer;
        typedef _STD::reverse_iterator&lt;iterator&gt;       reverse_iterator;
        typedef _STD::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
    private:
        typedef _MSL_REBIND (pointer) buf_allocator;
        typedef __cdeque&lt;pointer, buf_allocator&gt; buf_type;
    public:
        friend class iterator;
        class iterator
            : public _STD::iterator&lt;random_access_iterator_tag, value_type, difference_type, pointer, reference&gt;
        {
        public:
            iterator() {}
            reference operator * () const {return *cur_;}
            pointer operator -&gt; () const {return cur_;}
            iterator&amp; operator ++ ()
            {
                ++pos_;
                if (++cur_ == end_)
                {
                    difference_type buf_size = end_ - *beg_;
                    ++beg_;
                    pointer beg = *beg_;
                    cur_ = beg;
                    end_ = beg + buf_size;
                }
                return *this;
            }
            iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}
            iterator&amp; operator -- ()
            {
                --pos_;
                pointer beg = *beg_;
                if (cur_ != beg)
                    --cur_;
                else
                {
                    difference_type buf_size = end_ - beg;
                    --beg_;
                    end_ = *beg_ + buf_size;
                    cur_ = end_ - 1;
                }
                return *this;
            }
            iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}
            iterator&amp; operator += (difference_type n)
            {
                if (n &lt; 0)
                    return (*this) -= -n;
                pos_ += n;
                difference_type room = end_ - cur_ ;
                if (n &lt; room)
                    cur_ += n;
                else
                {
                    difference_type buf_size = end_ - *beg_;
                    n -= room;
                    beg_ += n / buf_size + 1;
                    pointer beg = *beg_;
                    cur_ = beg + n % buf_size;
                    end_ = beg + buf_size;
                }
                return *this;
            }
            iterator operator + (difference_type n) const {return iterator(*this) += n;}
            iterator&amp; operator -= (difference_type n)
            {
                if (n &lt; 0)
                    return (*this) += -n;
                pos_ -= n;
                pointer beg = *beg_;
                difference_type room = cur_ - beg + 1;
                if (n &lt; room)
                    cur_ -= n;
                else
                {
                    difference_type buf_size = end_ - beg;
                    n -= room;
                    beg_ -= n / buf_size + 1;
                    end_ = *beg_ + buf_size;
                    cur_ = end_ - 1 - n % buf_size;
                }
                return *this;
            }
            iterator operator - (difference_type n) const {return iterator(*this) -= n;}
            difference_type operator - (const iterator&amp; rhs) const {return difference_type(pos_ - rhs.pos_);}
            reference operator [] (difference_type i) const {iterator tmp(*this); tmp += i; return *tmp;}
            friend bool operator ==(const iterator&amp; x, const iterator&amp; y) {return x.cur_ == y.cur_;}  // hh 990720
            friend bool operator !=(const iterator&amp; x, const iterator&amp; y) {return x.cur_ != y.cur_;}
            friend bool operator &lt; (const iterator&amp; x, const iterator&amp; y) {return x.pos_ &lt;  y.pos_;}
            friend bool operator &lt;=(const iterator&amp; x, const iterator&amp; y) {return x.pos_ &lt;= y.pos_;}
            friend bool operator &gt; (const iterator&amp; x, const iterator&amp; y) {return x.pos_ &gt;  y.pos_;}
            friend bool operator &gt;=(const iterator&amp; x, const iterator&amp; y) {return x.pos_ &gt;= y.pos_;}
            friend iterator operator + (difference_type n, const iterator&amp; rhs)
                {return iterator(rhs) += n;}
        private:
            buf_type::iterator beg_;
            pointer cur_;
            pointer end_;
            size_type pos_;

            iterator(const buf_type::iterator&amp; beg, pointer cur, pointer end, size_type pos)
                : beg_(beg),
                  cur_(cur),
                  end_(end),
                  pos_(pos)
            {}

            friend class deque;
            friend class deque::const_iterator;
        };

        friend class const_iterator;
        class const_iterator
            : public _STD::iterator&lt;random_access_iterator_tag, value_type, difference_type, const_pointer, const_reference&gt;
        {
        public:
            const_iterator() {}
            const_iterator(const deque::iterator&amp; rhs) : beg_(rhs.beg_), cur_(rhs.cur_), end_(rhs.end_), pos_(rhs.pos_) {}
            const_reference operator * () const {return *cur_;}
            const_pointer operator -&gt; () const {return cur_;}
            const_iterator&amp; operator ++ ()
            {
                ++pos_;
                if (++cur_ == end_)
                {
                    difference_type buf_size = end_ - *beg_;
                    ++beg_;
                    pointer beg = *beg_;
                    cur_ = beg;
                    end_ = beg + buf_size;
                }
                return *this;
            }
            const_iterator operator ++ (int) {const_iterator tmp(*this); ++(*this); return tmp;}
            const_iterator&amp; operator -- ()
            {
                --pos_;
                pointer beg = *beg_;
                if (cur_ != beg)
                    --cur_;
                else
                {
                    difference_type buf_size = end_ - beg;
                    --beg_;
                    end_ = *beg_ + buf_size;
                    cur_ = end_ - 1;
                }
                return *this;
            }
            const_iterator operator -- (int) {const_iterator tmp(*this); --(*this); return tmp;}
            const_iterator&amp; operator += (difference_type n)
            {
                if (n &lt; 0)
                    return (*this) -= -n;
                pos_ += n;
                difference_type room = end_ - cur_ ;
                if (n &lt; room)
                    cur_ += n;
                else
                {
                    difference_type buf_size = end_ - *beg_;
                    n -= room;
                    beg_ += n / buf_size + 1;
                    pointer beg = *beg_;
                    cur_ = beg + n % buf_size;
                    end_ = beg + buf_size;
                }
                return *this;
            }
            const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}
            const_iterator&amp; operator -= (difference_type n)
            {
                if (n &lt; 0)
                    return (*this) += -n;
                pos_ -= n;
                pointer beg = *beg_;
                difference_type room = cur_ - beg + 1;
                if (n &lt; room)
                    cur_ -= n;
                else
                {
                    difference_type buf_size = end_ - beg;
                    n -= room;
                    beg_ -= n / buf_size + 1;
                    end_ = *beg_ + buf_size;
                    cur_ = end_ - 1 - n % buf_size;
                }
                return *this;
            }
            const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}
            difference_type operator - (const const_iterator&amp; rhs) const {return difference_type(pos_ - rhs.pos_);}
            const_reference operator [] (difference_type i) const {const_iterator tmp(*this); tmp += i; return *tmp;}
            friend bool operator ==(const const_iterator&amp; x, const const_iterator&amp; y) {return x.cur_ == y.cur_;}  // hh 990720
            friend bool operator !=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.cur_ != y.cur_;}
            friend bool operator &lt; (const const_iterator&amp; x, const const_iterator&amp; y) {return x.pos_ &lt;  y.pos_;}
            friend bool operator &lt;=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.pos_ &lt;= y.pos_;}
            friend bool operator &gt; (const const_iterator&amp; x, const const_iterator&amp; y) {return x.pos_ &gt;  y.pos_;}
            friend bool operator &gt;=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.pos_ &gt;= y.pos_;}
            friend const_iterator operator + (difference_type n, const const_iterator&amp; rhs)
                {return const_iterator(rhs) += n;}
        private:
            buf_type::const_iterator beg_;
            const_pointer cur_;
            const_pointer end_;
            size_type pos_;

            const_iterator(const buf_type::const_iterator&amp; beg, const_pointer cur, const_pointer end, size_type pos)
                : beg_(beg),
                  cur_(cur),
                  end_(end),
                  pos_(pos)
            {}

            friend class deque;
        };

        // _lib.deque.cons_ construct/copy/destroy:
        explicit deque(const Allocator&amp; = Allocator());
        explicit deque(size_type n, const value_type&amp; value = 0, const Allocator&amp; = Allocator());
        template &lt;class InputIterator&gt;
            deque(InputIterator first, InputIterator last, const Allocator&amp; a = Allocator())
                : alloc_(a, default_bufsize_s),
                  buf_(buf_allocator(a)),
                  start_(0),
                  size_(0)
            {
                choose_init(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
        deque(const deque&amp; x);
        ~deque();
        deque&amp; operator=(const deque&amp; x);
        template &lt;class InputIterator&gt;
            inline
            void assign(InputIterator first, InputIterator last)
            {
                choose_assign(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
        void assign(size_type n, const value_type&amp; t);
        allocator_type get_allocator() const;
        // iterators:
        iterator               begin();
        const_iterator         begin() const;
        iterator               end();
        const_iterator         end() const;
        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator       rend();
        const_reverse_iterator rend() const;
        // _lib.deque.capacity_ capacity:
        size_type size() const;
        size_type max_size() const;
        void      resize(size_type sz, value_type c = 0);
        bool      empty() const;

        // element access:
        reference       operator[](size_type n);
        const_reference operator[](size_type n) const;
        reference       at(size_type n);
        const_reference at(size_type n) const;
        reference       front();
        const_reference front() const;
        reference       back();
        const_reference back() const;
        // _lib.deque.modifiers_ modifiers:
        void push_front(const value_type&amp; x);
        void push_back(const value_type&amp; x);
        iterator insert(iterator position, const value_type&amp; x);
        void     insert(iterator position, size_type n, const value_type&amp; x);
        template &lt;class InputIterator&gt;
            inline
            void insert(iterator position, InputIterator first, InputIterator last)
            {
                choose_insert(position, first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
        void pop_front();
        void pop_back();
        iterator erase(iterator position);
        iterator erase(iterator first, iterator last);
        void     swap(deque&amp;);
        void     clear();
    private:
        static const size_type min_buf_size_s = 8;
        static const size_type min_foot_print_s = 512;
        static const size_type default_bufsize_s = sizeof(value_type) * min_buf_size_s &lt; min_foot_print_s ?
                                                   min_foot_print_s / sizeof(value_type) : min_buf_size_s;
        _EmptyMemberOpt&lt;Allocator, size_type&gt; alloc_;  // alloc_.m_ is bufsize_
        buf_type buf_;
        size_type start_;
        size_type size_;

        template &lt;class InputIterator&gt;
            inline
            void
            choose_init(InputIterator first, InputIterator last, chooser&lt;true&gt;)
            {
                init(static_cast&lt;size_type&gt;(first), reinterpret_cast&lt;value_type&gt;(last));  // hh 981208
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_init(InputIterator first, InputIterator last, chooser&lt;false&gt;)
            {
                init(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            init(InputIterator first, InputIterator last, input_iterator_tag)
            {
                #ifndef _MSL_NO_EXCEPTIONS
                try
                {
                #endif
                    for (; first != last; ++first)
                        push_back(*first);
                #ifndef _MSL_NO_EXCEPTIONS
                }
                catch (...)
                {
                    tear_down();
                    throw;
                }
                #endif
            }

        template &lt;class ForwardIterator&gt;
            void
            init(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
            {
                size_ = (size_type)distance(first, last);
                if (size_ &gt; max_size())
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;deque::construction length error&quot;);
                    #else
                        __msl_error(&quot;deque::construction length error\n&quot;);
                    #endif
                if (size_ &gt; 0)
                {
                    init_buf();
                    if (alloc_.m_ &lt; size_)
                        alloc_.m_ = size_;
                    pointer tmp = alloc_.allocate(alloc_.m_);
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        buf_.front() = tmp;
                        buf_.push_back(0);
                        start_ = (alloc_.m_ - size_) / 2;
                        copy(first, last, tmp + start_);
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        alloc_.deallocate(tmp, alloc_.m_);
                        throw;
                    }
                    #endif
                }
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_assign(InputIterator first, InputIterator last, chooser&lt;true&gt;)
            {
                assign(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_assign(InputIterator first, InputIterator last, chooser&lt;false&gt;)
            {
                do_assign(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            do_assign(InputIterator first, InputIterator last, input_iterator_tag)
            {
                deque temp(first, last, get_allocator());
                const deque&amp; tempr = temp;
                do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
            }

        template &lt;class ForwardIterator&gt;
            void
            do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
            {
                size_type n = (size_type)distance(first, last);
                if (n &gt; max_size())
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;deque::assign length error&quot;);
                    #else
                        __msl_error(&quot;deque::assign length error\n&quot;);
                    #endif
                if (buf_.empty())
                    init_buf();
                while (n &gt; capacity())
                {
                    pointer tmp = alloc_.allocate(alloc_.m_);
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        buf_.back() = tmp;
                        buf_.push_back(0);
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        alloc_.deallocate(tmp, alloc_.m_);
                        throw;
                    }
                    #endif
                }
                start_ = (capacity() - n) / 2;
                while (start_ &gt;= alloc_.m_)
                {
                    buf_.pop_back();
                    pointer&amp; p = buf_.back();
                    alloc_.deallocate(p, alloc_.m_);
                    p = 0;
                    start_ = (capacity() - n) / 2;
                }
                copy(first, last, begin());
                size_ = n;
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_insert(iterator position, InputIterator first, InputIterator last,
                chooser&lt;true&gt;)
            {
                insert(position, static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_insert(iterator position, InputIterator first, InputIterator last,
                chooser&lt;false&gt;)
            {
                do_insert(position, first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            do_insert(iterator position, InputIterator first, InputIterator last,
                input_iterator_tag)
            {
                deque temp(first, last, get_allocator());
                const deque&amp; tempr = temp;
                do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());
            }

        template &lt;class ForwardIterator&gt;
            void
            do_insert(iterator position, ForwardIterator first, ForwardIterator last,
                forward_iterator_tag)
            {
                size_type n = (size_type)distance(first, last);
                if (n == 0)
                    return;
                size_type ms = max_size();
                if (n &gt; ms || size_ &gt; ms - n)
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;deque::insert length error&quot;);
                    #else
                        __msl_error(&quot;deque::insert length error\n&quot;);
                    #endif
                if (buf_.empty())
                    init_buf();
                size_type pb = position.pos_ - start_;
                size_type pe = size_ - pb;
                if (pb &lt;= pe)  // hh 981210
                {
                    if (start_ &lt; n)
                        grow_buf_front(n);
                    else
                        start_ -= n;
                    if (pb == 0) // insert at begin()
                        copy(first, last, begin());
                    else // pos in [1, size_ / 2)
                    {
                        iterator b = begin();
                        copy(b + difference_type(n), b + difference_type(n + pb), b);
                        copy(first, last, b + difference_type(pb));
                    }
                    size_ += n;
                }
                else // pos &gt;= size_ / 2
                {
                    size_type e = capacity() - (start_ + size_);
                    if (e &lt; n)
                        grow_buf_back(e, n);
                    if (pe == 0) // insert at end()
                        copy(first, last, end());
                    else // pos in [size_ / 2, size_)
                    {
                        iterator e = end();
                        iterator p = e - difference_type(pe);
                        copy_backward(p, e, e + difference_type(n));
                        copy(first, last, p);
                    }
                    size_ += n;
                }
                invalidate_iterators();
            }

        void init(size_type n, const value_type&amp; value);
        void tear_down();
        void invalidate_iterators();
        iterator make_iterator(size_type pos);
        const_iterator make_iterator(size_type pos) const;
        void init_buf();
        size_type capacity() const;
        void grow_buf_front(size_type n);
        void grow_buf_back(size_type e, size_type n);
    };

    // Implementation deque&lt;void*&gt;

    template &lt;class Allocator&gt;
    inline
    void
    deque&lt;void*, Allocator&gt;::invalidate_iterators()
    {
        while (start_ &gt;= 3 * alloc_.m_ / 2)
        {
            alloc_.deallocate(buf_.front(), alloc_.m_);
            buf_.pop_front();
            start_ -= alloc_.m_;
        }
    }

    template &lt;class Allocator&gt;
    typename deque&lt;void*, Allocator&gt;::iterator
    deque&lt;void*, Allocator&gt;::make_iterator(size_type pos)
    {
        buf_type::iterator b = buf_.begin();
        pointer cur;
        pointer beg;
        if (pos &lt; alloc_.m_)
        {
            if (!buf_.empty())
                beg = *b;
            else
                beg = 0;
            cur = beg + pos;
        }
        else
        {
            b += difference_type(pos / alloc_.m_);
            beg = *b;
            cur = beg + pos % alloc_.m_;
        }
        return iterator(b, cur, beg + alloc_.m_, pos);
    }

    template &lt;class Allocator&gt;
    typename deque&lt;void*, Allocator&gt;::const_iterator
    deque&lt;void*, Allocator&gt;::make_iterator(size_type pos) const
    {
        buf_type::const_iterator b = buf_.begin();
        const_pointer cur;
        const_pointer beg;
        if (pos &lt; alloc_.m_)
        {
            if (!buf_.empty())
                beg = *b;
            else
                beg = 0;
            cur = beg + pos;
        }
        else
        {
            b += difference_type(pos / alloc_.m_);
            beg = *b;
            cur = beg + pos % alloc_.m_;
        }
        return const_iterator(b, cur, beg + alloc_.m_, pos);
    }

    template &lt;class Allocator&gt;
    inline
    void
    deque&lt;void*, Allocator&gt;::init_buf()
    {
        buf_.reserve(2);
        buf_.resize(1);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::size_type
    deque&lt;void*, Allocator&gt;::capacity() const
    {
        return (buf_.size() - 1) * alloc_.m_;
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::grow_buf_front(size_type n)
    {
        bool buf_invalidated = false;
        size_type oldstart = start_;
        size_type new_buffers = 0;
        buf_type orig_buf;
        size_type nc = n;
        nc -= start_;
        while (true)
        {
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                if (!buf_invalidated &amp;&amp; buf_.size() == buf_.capacity())
                {
                    buf_.swap(orig_buf);
                    buf_invalidated = true;
                    buf_.reserve(2*orig_buf.capacity());
                    buf_.assign(orig_buf.begin(), orig_buf.end());
                }
                buf_.push_front(tmp);
                ++new_buffers;  // hh 981210
                start_ += alloc_.m_;
                if (nc &lt;= alloc_.m_)
                {
                    if (size_ != 0)  // hh 981210
                        start_ -= n;
                    else
                        start_ = (capacity() - n) / 2;
                    break;
                }
                nc -= alloc_.m_;
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
                {
                    alloc_.deallocate(buf_.front(), alloc_.m_);
                    buf_.pop_front();
                }
                if (buf_invalidated)
                    buf_.swap(orig_buf);
                start_ = oldstart;
                throw;
            }
            #endif
        }
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::grow_buf_back(size_type e, size_type n)
    {
        bool buf_invalidated = false;
        buf_type orig_buf;
        size_type new_buffers = 0;
        size_type nc = n;
        nc -= e;
        while (true)
        {
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                if (!buf_invalidated &amp;&amp; buf_.size() == buf_.capacity())
                {
                    buf_.swap(orig_buf);
                    buf_invalidated = true;
                    buf_.reserve(2*orig_buf.capacity());
                    buf_.assign(orig_buf.begin(), orig_buf.end());
                }
                buf_.back() = tmp;
                buf_.push_back(0);
                ++new_buffers;
                if (nc &lt;= alloc_.m_)
                    break;
                nc -= alloc_.m_;
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                if (!buf_.empty())
                    buf_.back() = 0;
                for (size_type i = 0; i &lt; new_buffers; ++i)  // hh 981210
                {
                    buf_.pop_back();
                    pointer&amp; p = buf_.back();
                    alloc_.deallocate(p, alloc_.m_);
                    p = 0;
                }
                if (buf_invalidated)
                    buf_.swap(orig_buf);
                throw;
            }
            #endif
        }
    }

    template &lt;class Allocator&gt;
    deque&lt;void*, Allocator&gt;::deque(const Allocator&amp; a)
        : alloc_(a, default_bufsize_s),
          buf_(buf_allocator(a)),
          start_(0),
          size_(0)
    {
    }

    template &lt;class Allocator&gt;
    deque&lt;void*, Allocator&gt;::deque(size_type n, const value_type&amp; value, const Allocator&amp; a)
        : alloc_(a, default_bufsize_s),
          buf_(buf_allocator(a)),
          start_(0),
          size_(0)
    {
        init(n, value);
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::init(size_type n, const value_type&amp; value)
    {
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::construction length error&quot;);
            #else
                __msl_error(&quot;deque::construction length error\n&quot;);
            #endif
        if (n &gt; 0)
        {
            init_buf();
            if (alloc_.m_ &lt; n)
                alloc_.m_ = n;
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                buf_.front() = tmp;
                buf_.push_back(0);
                size_ = n;
                start_ = (alloc_.m_ - size_) / 2;
                fill_n(tmp + start_, size_, value);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                throw;
            }
            #endif
        }
    }

    template &lt;class Allocator&gt;
    deque&lt;void*, Allocator&gt;::deque(const deque&amp; x)
        : alloc_(x.alloc_, default_bufsize_s),
          buf_(buf_allocator(alloc_)),
          start_(0),
          size_(x.size_)
    {
        if (size_ &gt; 0)
        {
            init_buf();
            if (alloc_.m_ &lt; size_)
                alloc_.m_ = size_;
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                buf_.front() = tmp;
                buf_.push_back(0);
                start_ = (alloc_.m_ - size_) / 2;
                copy(x.begin(), x.end(), tmp + start_);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                throw;
            }
            #endif
        }
    }

    template &lt;class Allocator&gt;
    inline
    deque&lt;void*, Allocator&gt;::~deque()
    {
        tear_down();
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::tear_down()
    {
        if (!buf_.empty())
        {
            buf_type::iterator e = --buf_.end();
            for (buf_type::iterator i = buf_.begin(); i != e; ++i)
                alloc_.deallocate(*i, alloc_.m_);
        }
    }

    template &lt;class Allocator&gt;
    deque&lt;void*,Allocator&gt;&amp;
    deque&lt;void*, Allocator&gt;::operator=(const deque&amp; x)
    {
        if (this != &amp;x)
            assign(x.begin(), x.end());
        return *this;
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::assign(size_type n, const value_type&amp; t)
    {
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::assign length error&quot;);
            #else
                __msl_error(&quot;deque::assign length error\n&quot;);
            #endif
        if (buf_.empty())
            init_buf();
        while (n &gt; capacity())
        {
            pointer tmp = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                buf_.back() = tmp;
                buf_.push_back(0);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(tmp, alloc_.m_);
                buf_.back() = 0;
                throw;
            }
            #endif
        }
        start_ = (capacity() - n) / 2;
        while (start_ &gt;= alloc_.m_)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
            start_ = (capacity() - n) / 2;
        }
        fill_n(begin(), n, t);
        size_ = n;
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::allocator_type
    deque&lt;void*, Allocator&gt;::get_allocator() const
    {
        return alloc_;
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::iterator
    deque&lt;void*, Allocator&gt;::begin()
    {
        return make_iterator(start_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::const_iterator
    deque&lt;void*, Allocator&gt;::begin() const
    {
        return make_iterator(start_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::iterator
    deque&lt;void*, Allocator&gt;::end()
    {   
        return make_iterator(start_ + size_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::const_iterator
    deque&lt;void*, Allocator&gt;::end() const
    {   
        return make_iterator(start_ + size_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::reverse_iterator
    deque&lt;void*, Allocator&gt;::rbegin()
    {
        return reverse_iterator(end());
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::const_reverse_iterator
    deque&lt;void*, Allocator&gt;::rbegin() const
    {
        return const_reverse_iterator(end());
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::reverse_iterator
    deque&lt;void*, Allocator&gt;::rend()
    {
        return reverse_iterator(begin());
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::const_reverse_iterator
    deque&lt;void*, Allocator&gt;::rend() const
    {
        return const_reverse_iterator(begin());
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::size_type
    deque&lt;void*, Allocator&gt;::size() const
    {
        return size_;
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::size_type
    deque&lt;void*, Allocator&gt;::max_size() const
    {
        return alloc_.max_size();
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::resize(size_type sz, value_type c)
    {
        if (sz &gt; size())
            insert(end(), sz-size(), c);
        else if (sz &lt; size())
            erase(begin() + difference_type(sz), end());
    }

    template &lt;class Allocator&gt;
    inline
    bool
    deque&lt;void*, Allocator&gt;::empty() const
    {
        return size_ == 0;
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::reference
    deque&lt;void*, Allocator&gt;::operator[](size_type n)
    {
        size_type i = n + start_;
        return *(buf_[i / alloc_.m_] + i % alloc_.m_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::const_reference
    deque&lt;void*, Allocator&gt;::operator[](size_type n) const
    {
        size_type i = n + start_;
        return *(buf_[i / alloc_.m_] + i % alloc_.m_);
    }

    template &lt;class Allocator&gt;
    typename deque&lt;void*, Allocator&gt;::reference
    deque&lt;void*, Allocator&gt;::at(size_type n)
    {
        if (n &gt;= size_)
            #ifndef _MSL_NO_EXCEPTIONS
                throw out_of_range(&quot;deque::at index out of range&quot;);
            #else
                __msl_error(&quot;deque::at index out of range&quot;);
            #endif
        size_type i = n + start_;
        return *(buf_[i / alloc_.m_] + i % alloc_.m_);
    }

    template &lt;class Allocator&gt;
    typename deque&lt;void*, Allocator&gt;::const_reference
    deque&lt;void*, Allocator&gt;::at(size_type n) const
    {
        if (n &gt;= size_)
            #ifndef _MSL_NO_EXCEPTIONS
                throw out_of_range(&quot;deque::at index out of range&quot;);
            #else
                __msl_error(&quot;deque::at index out of range&quot;);
            #endif
        size_type i = n + start_;
        return *(buf_[i / alloc_.m_] + i % alloc_.m_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::reference
    deque&lt;void*, Allocator&gt;::front()
    {
        return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::const_reference
    deque&lt;void*, Allocator&gt;::front() const
    {
        return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::reference
    deque&lt;void*, Allocator&gt;::back()
    {
        size_type i = start_ + size_ - 1;
        return *(buf_[i / alloc_.m_] + i % alloc_.m_);
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::const_reference
    deque&lt;void*, Allocator&gt;::back() const
    {
        size_type i = start_ + size_ - 1;
        return *(buf_[i / alloc_.m_] + i % alloc_.m_);
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::push_front(const value_type&amp; x)
    {
        if (size_ &gt; max_size() - 1)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::push_front length error&quot;);
            #else
                __msl_error(&quot;deque::push_front length error\n&quot;);
            #endif
        if (buf_.empty())
            init_buf();
        if (start_ == 0)
            grow_buf_front(1);
        else
            --start_;
        if (start_ &lt; alloc_.m_)
            *(buf_.front() + start_) = x;
        else
            *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_) = x;
        ++size_;
        invalidate_iterators();
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::push_back(const value_type&amp; x)
    {
        if (size_ &gt; max_size() - 1)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::insert length error&quot;);
            #else
                __msl_error(&quot;deque::insert length error\n&quot;);
            #endif
        if (buf_.empty())
            init_buf();
        {
            if (capacity() == start_ + size_)
                grow_buf_back(0, 1);
            size_type pos = start_ + size_;
            if (pos &lt; alloc_.m_)
                *(buf_.front() + pos) = x;
            else
                *(buf_[pos / alloc_.m_] + pos % alloc_.m_) = x;
            ++size_;
        }
        invalidate_iterators();
    }

    template &lt;class Allocator&gt;
    typename deque&lt;void*, Allocator&gt;::iterator
    deque&lt;void*, Allocator&gt;::insert(iterator position, const value_type&amp; x)
    {
        difference_type pos = position - begin();
        insert(position, 1, x);
        return begin() + pos;
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::insert(iterator position, size_type n, const value_type&amp; x)
    {
        if (n == 0)
            return;
        size_type ms = max_size();
        if (n &gt; ms || size_ &gt; ms - n)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;deque::insert length error&quot;);
            #else
                __msl_error(&quot;deque::insert length error\n&quot;);
            #endif
        if (buf_.empty())
            init_buf();
        size_type pb = position.pos_ - start_;
        size_type pe = size_ - pb;
        if (pb &lt;= pe)  // hh 981210
        {
            size_type new_buffers = 0;
            size_type oldstart = start_;
            if (start_ &lt; n)
                grow_buf_front(n);
            else
                start_ -= n;
            if (pb == 0) // insert at begin()
                fill_n(begin(), n, x);
            else // pos in [1, size_ / 2)
            {
                iterator b = begin();
                copy(b + difference_type(n), b + difference_type(n + pb), b);
                fill_n(b + difference_type(pb), n, x);
            }
            size_ += n;
        }
        else // pos &gt;= size_ / 2
        {
            size_type e = capacity() - (start_ + size_);
            if (e &lt; n)
                grow_buf_back(e, n);
            if (pe == 0) // insert at end()
                fill_n(end(), n, x);
            else // pos in [size_ / 2, size_)
            {
                iterator e = end();
                iterator p = e - difference_type(pe);
                copy_backward(p, e, e + difference_type(n));
                fill_n(p, n, x);
            }
            size_ += n;
        }
        invalidate_iterators();
    }

    template &lt;class Allocator&gt;
    inline
    void
    deque&lt;void*, Allocator&gt;::pop_front()
    {
        ++start_;
        if (--size_ == 0)
        {
            for (size_type i = buf_.size() - 2; i &gt; 0; --i)
            {
                buf_.pop_back();
                pointer&amp; p = buf_.back();
                alloc_.deallocate(p, alloc_.m_);
                p = 0;
            }
            start_ = alloc_.m_ / 2;
        }
    }

    template &lt;class Allocator&gt;
    inline
    void
    deque&lt;void*, Allocator&gt;::pop_back()
    {
        --size_;
        while (capacity() - (start_ + size_) &gt;= 3 * alloc_.m_ / 2)
        {
            buf_.pop_back();
            pointer&amp; p = buf_.back();
            alloc_.deallocate(p, alloc_.m_);
            p = 0;
        }
        if (size_ == 0)
        {
            for (size_type i = buf_.size() - 2; i &gt; 0; --i)
            {
                buf_.pop_back();
                pointer&amp; p = buf_.back();
                alloc_.deallocate(p, alloc_.m_);
                p = 0;
            }
            start_ = alloc_.m_ / 2;
        }
    }

    template &lt;class Allocator&gt;
    inline
    typename deque&lt;void*, Allocator&gt;::iterator
    deque&lt;void*, Allocator&gt;::erase(iterator position)
    {
        return erase(position, position + 1);
    }

    template &lt;class Allocator&gt;
    typename deque&lt;void*, Allocator&gt;::iterator
    deque&lt;void*, Allocator&gt;::erase(iterator first, iterator last)
    {
        if (first == last)
            return first;
        const size_type pb = first.pos_ - start_;
        const size_type pe = size_ - (last.pos_ - start_);
        const size_type diff = size_type(last - first);
        if (pb &lt; pe)
        {
            if (pb == 0)  // erase from beginning, no copying necessary
            {
                start_ += diff;
                size_ -= diff;
            }
            else  // erase from beginning, needs copying
            {
                copy_backward(begin(), first, last);
                start_ += diff;
                size_ -= diff;
                invalidate_iterators();
            }
        }
        else  // pb &gt;= pe - erase from end
        {
            if (pe != 0)  // erase from end, needs copying
            {
                copy(last, end(), first);
                invalidate_iterators();
            }
            size_ -= diff;
            while (capacity() - (start_ + size_) &gt;= 3 * alloc_.m_ / 2)
            {
                buf_.pop_back();
                pointer&amp; p = buf_.back();
                alloc_.deallocate(p, alloc_.m_);
                p = 0;
            }
        }
        if (size_ == 0)
        {
            for (size_type i = buf_.size() - 1; i &gt; 0; --i)
            {
                buf_.pop_back();
                pointer&amp; p = buf_.back();
                alloc_.deallocate(p, alloc_.m_);
                p = 0;
            }
            start_ = alloc_.m_ / 2;
        }
        return make_iterator(start_ + pb);
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::swap(deque&amp; x)
    {
        if (this != &amp;x)
        {
            _STD::swap(alloc_, x.alloc_);
            _STD::swap(buf_, x.buf_);
            _STD::swap(start_, x.start_);
            _STD::swap(size_, x.size_);
        }
    }

    template &lt;class Allocator&gt;
    void
    deque&lt;void*, Allocator&gt;::clear()
    {
        if (!buf_.empty())  // hh 981209
        {
            size_ = 0;
            for (size_type i = buf_.size() - 2; i &gt; 0; --i)
            {
                buf_.pop_back();
                pointer&amp; p = buf_.back();
                alloc_.deallocate(p, alloc_.m_);
                p = 0;
            }
            start_ = alloc_.m_ / 2;
        }
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator==(const deque&lt;void*,Allocator&gt;&amp; x, const deque&lt;void*,Allocator&gt;&amp; y)
    {
        return x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator!=(const deque&lt;void*,Allocator&gt;&amp; x, const deque&lt;void*,Allocator&gt;&amp; y)
    {
        return !(x == y);
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&lt; (const deque&lt;void*,Allocator&gt;&amp; x, const deque&lt;void*,Allocator&gt;&amp; y)
    {
        return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&gt; (const deque&lt;void*,Allocator&gt;&amp; x, const deque&lt;void*,Allocator&gt;&amp; y)
    {
        return y &lt; x;
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&gt;=(const deque&lt;void*,Allocator&gt;&amp; x, const deque&lt;void*,Allocator&gt;&amp; y)
    {
        return !(x &lt; y);
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&lt;=(const deque&lt;void*,Allocator&gt;&amp; x, const deque&lt;void*,Allocator&gt;&amp; y)
    {
        return !(y &lt; x);
    }

    template &lt;class Allocator&gt;
    inline
    void
    swap(deque&lt;void*,Allocator&gt;&amp; x, deque&lt;void*,Allocator&gt;&amp; y)
    {
        x.swap(y);
    }

    // T*

    template &lt;class T, class Allocator&gt;
    class deque&lt;T*, Allocator&gt;
        : private deque&lt;void*, Allocator::rebind&lt;void*&gt;::other&gt;
    {
        typedef deque&lt;void*, Allocator::rebind&lt;void*&gt;::other&gt; base;
        typedef base::allocator_type base_allocator;
    public:
        // types:
        typedef typename Allocator::reference         reference;
        typedef typename Allocator::const_reference   const_reference;
        class                                         iterator;
        class                                         const_iterator;
        typedef typename Allocator::size_type         size_type;
        typedef typename Allocator::difference_type   difference_type;
        typedef T*                                    value_type;
        typedef Allocator                             allocator_type;
        typedef typename Allocator::pointer           pointer;
        typedef typename Allocator::const_pointer     const_pointer;
        typedef _STD::reverse_iterator&lt;iterator&gt;       reverse_iterator;
        typedef _STD::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;

        class iterator
            : public _STD::iterator&lt;random_access_iterator_tag, value_type,
                difference_type, pointer, reference&gt;
        {
        public:
            iterator() {}
            explicit iterator(const base::iterator&amp; i) : i_(i) {}
            operator base::iterator() const {return i_;}
            reference operator * () const {return reference(*i_);}
            pointer operator -&gt; () const {return pointer(i_.operator-&gt;());}
            iterator&amp; operator ++ () {++i_; return *this;}
            iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}
            iterator&amp; operator -- () {--i_; return *this;}
            iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}
            iterator&amp; operator += (difference_type n) {i_ += n; return *this;}
            iterator operator + (difference_type n) const {return iterator(*this) += n;}
            iterator&amp; operator -= (difference_type n) {i_ -= n; return *this;}
            iterator operator - (difference_type n) const {return iterator(*this) -= n;}
            difference_type operator - (const iterator&amp; rhs) const {return i_ - rhs.i_;}
            reference operator [] (difference_type i) const {return reference(i_[i]);}
            friend bool operator ==(const iterator&amp; x, const iterator&amp; y) {return x.i_ == y.i_;}  // hh 990720
            friend bool operator !=(const iterator&amp; x, const iterator&amp; y) {return x.i_ != y.i_;}
            friend bool operator &lt; (const iterator&amp; x, const iterator&amp; y) {return x.i_ &lt;  y.i_;}
            friend bool operator &lt;=(const iterator&amp; x, const iterator&amp; y) {return x.i_ &lt;= y.i_;}
            friend bool operator &gt; (const iterator&amp; x, const iterator&amp; y) {return x.i_ &gt;  y.i_;}
            friend bool operator &gt;=(const iterator&amp; x, const iterator&amp; y) {return x.i_ &gt;= y.i_;}
            friend iterator operator + (difference_type n, const iterator&amp; rhs)
                {return iterator(rhs) += n;}
        private:
            base::iterator i_;

            friend class deque::const_iterator;
        };

        class const_iterator
            : public _STD::iterator&lt;random_access_iterator_tag, value_type,
                difference_type, const_pointer, const_reference&gt;
        {
        public:
            const_iterator() {}
            const_iterator(const deque::iterator&amp; rhs) : i_(rhs.i_) {}
            explicit const_iterator(const base::const_iterator&amp; i) : i_(i) {}
            operator base::const_iterator() const {return i_;}
            const_reference operator * () const {return const_reference(*i_);}
            const_pointer operator -&gt; () const {return const_pointer(i_.operator-&gt;());}
            const_iterator&amp; operator ++ () {++i_; return *this;}
            const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}
            const_iterator&amp; operator -- () {--i_; return *this;}
            const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}
            const_iterator&amp; operator += (difference_type n) {i_ += n; return *this;}
            const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}
            const_iterator&amp; operator -= (difference_type n) {i_ -= n; return *this;}
            const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}
            difference_type operator - (const const_iterator&amp; rhs) const {return i_ - rhs.i_;}
            const_reference operator [] (difference_type i) const {return const_reference(i_[i]);}
            friend bool operator ==(const const_iterator&amp; x, const const_iterator&amp; y) {return x.i_ == y.i_;}  // hh 990720
            friend bool operator !=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.i_ != y.i_;}
            friend bool operator &lt; (const const_iterator&amp; x, const const_iterator&amp; y) {return x.i_ &lt;  y.i_;}
            friend bool operator &lt;=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.i_ &lt;= y.i_;}
            friend bool operator &gt; (const const_iterator&amp; x, const const_iterator&amp; y) {return x.i_ &gt;  y.i_;}
            friend bool operator &gt;=(const const_iterator&amp; x, const const_iterator&amp; y) {return x.i_ &gt;= y.i_;}
            friend const_iterator operator + (difference_type n, const const_iterator&amp; rhs)
                {return const_iterator(rhs) += n;}
        private:
            base::const_iterator i_;
        };

        // _lib.deque.cons_ construct/copy/destroy:
        explicit deque(const Allocator&amp; = Allocator());
        explicit deque(size_type n, const value_type&amp; value = 0, const Allocator&amp; = Allocator());
        template &lt;class InputIterator&gt;
            inline
            deque(InputIterator first, InputIterator last, const Allocator&amp; a = Allocator())
                : base(first, last, base_allocator(a))
            {
            }
        template &lt;class InputIterator&gt;
            inline
            void assign(InputIterator first, InputIterator last)
            {
                base::assign(first, last);
            }
        void assign(size_type n, const value_type&amp; t);
        allocator_type get_allocator() const;
        // iterators:
        iterator               begin();
        const_iterator         begin() const;
        iterator               end();
        const_iterator         end() const;
        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator       rend();
        const_reverse_iterator rend() const;
        // _lib.deque.capacity_ capacity:
        size_type size() const;
        size_type max_size() const;
        void      resize(size_type sz, value_type c = 0);
        bool      empty() const;

        // element access:
        reference       operator[](size_type n);
        const_reference operator[](size_type n) const;
        reference       at(size_type n);
        const_reference at(size_type n) const;
        reference       front();
        const_reference front() const;
        reference       back();
        const_reference back() const;
        // _lib.deque.modifiers_ modifiers:
        void push_front(const value_type&amp; x);
        void push_back(const value_type&amp; x);
        iterator insert(iterator position, const value_type&amp; x);
        void     insert(iterator position, size_type n, const value_type&amp; x);
        template &lt;class InputIterator&gt;
            void insert(iterator position, InputIterator first, InputIterator last)
            {
                base::insert(position, first, last);
            }
        void pop_front();
        void pop_back();
        iterator erase(iterator position);
        iterator erase(iterator first, iterator last);
        void     swap(deque&amp;);
        void     clear();
    };

    // Implementation deque&lt;T*&gt;

    template &lt;class T, class Allocator&gt;
    inline
    deque&lt;T*, Allocator&gt;::deque(const Allocator&amp; a)
        : base(base_allocator(a))
    {
    }

    template &lt;class T, class Allocator&gt;
    inline
    deque&lt;T*, Allocator&gt;::deque(size_type n, const value_type&amp; value, const Allocator&amp; a)
        : base(n, value, base_allocator(a))
    {
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::assign(size_type n, const value_type&amp; t)
    {
        base::assign(n, t);
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::allocator_type
    deque&lt;T*, Allocator&gt;::get_allocator() const
    {
        return base::get_allocator();
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::iterator
    deque&lt;T*, Allocator&gt;::begin()
    {
        return iterator(base::begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::const_iterator
    deque&lt;T*, Allocator&gt;::begin() const
    {
        return const_iterator(base::begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::iterator
    deque&lt;T*, Allocator&gt;::end()
    {   
        return iterator(base::end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::const_iterator
    deque&lt;T*, Allocator&gt;::end() const
    {   
        return const_iterator(base::end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::reverse_iterator
    deque&lt;T*, Allocator&gt;::rbegin()
    {
        return reverse_iterator(end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::const_reverse_iterator
    deque&lt;T*, Allocator&gt;::rbegin() const
    {
        return const_reverse_iterator(end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::reverse_iterator
    deque&lt;T*, Allocator&gt;::rend()
    {
        return reverse_iterator(begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::const_reverse_iterator
    deque&lt;T*, Allocator&gt;::rend() const
    {
        return const_reverse_iterator(begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::size_type
    deque&lt;T*, Allocator&gt;::size() const
    {
        return base::size();
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::size_type
    deque&lt;T*, Allocator&gt;::max_size() const
    {
        return base::max_size();
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::resize(size_type sz, value_type c)
    {
        base::resize(sz, c);
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    deque&lt;T*, Allocator&gt;::empty() const
    {
        return base::empty();
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::reference
    deque&lt;T*, Allocator&gt;::operator[](size_type n)
    {
        return reference(base::operator[](n));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::const_reference
    deque&lt;T*, Allocator&gt;::operator[](size_type n) const
    {
        return const_reference(base::operator[](n));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::reference
    deque&lt;T*, Allocator&gt;::at(size_type n)
    {
        return reference(base::at(n));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::const_reference
    deque&lt;T*, Allocator&gt;::at(size_type n) const
    {
        return const_reference(base::at(n));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::reference
    deque&lt;T*, Allocator&gt;::front()
    {
        return reference(base::front());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::const_reference
    deque&lt;T*, Allocator&gt;::front() const
    {
        return const_reference(base::front());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::reference
    deque&lt;T*, Allocator&gt;::back()
    {
        return reference(base::back());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::const_reference
    deque&lt;T*, Allocator&gt;::back() const
    {
        return const_reference(base::back());
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::push_front(const value_type&amp; x)
    {
        base::push_front(x);
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::push_back(const value_type&amp; x)
    {
        base::push_back(x);
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::iterator
    deque&lt;T*, Allocator&gt;::insert(iterator position, const value_type&amp; x)
    {
        return iterator(base::insert(position, x));
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::insert(iterator position, size_type n, const value_type&amp; x)
    {
        base::insert(position, n, x);
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::pop_front()
    {
        base::pop_front();
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::pop_back()
    {
        base::pop_back();
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::iterator
    deque&lt;T*, Allocator&gt;::erase(iterator position)
    {
        return iterator(base::erase(position));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename deque&lt;T*, Allocator&gt;::iterator
    deque&lt;T*, Allocator&gt;::erase(iterator first, iterator last)
    {
        return iterator(base::erase(first, last));
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::swap(deque&amp; x)
    {
        base::swap((base&amp;)x);
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    deque&lt;T*, Allocator&gt;::clear()
    {
        base::clear();
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator==(const deque&lt;T*,Allocator&gt;&amp; x, const deque&lt;T*,Allocator&gt;&amp; y)
    {
        return x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator!=(const deque&lt;T*,Allocator&gt;&amp; x, const deque&lt;T*,Allocator&gt;&amp; y)
    {
        return !(x == y);
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator&lt; (const deque&lt;T*,Allocator&gt;&amp; x, const deque&lt;T*,Allocator&gt;&amp; y)
    {
        return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator&gt; (const deque&lt;T*,Allocator&gt;&amp; x, const deque&lt;T*,Allocator&gt;&amp; y)
    {
        return y &lt; x;
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator&gt;=(const deque&lt;T*,Allocator&gt;&amp; x, const deque&lt;T*,Allocator&gt;&amp; y)
    {
        return !(x &lt; y);
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator&lt;=(const deque&lt;T*,Allocator&gt;&amp; x, const deque&lt;T*,Allocator&gt;&amp; y)
    {
        return !(y &lt; x);
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    swap(deque&lt;T*,Allocator&gt;&amp; x, deque&lt;T*,Allocator&gt;&amp; y)
    {
        x.swap(y);
    }

#endif // !defined(_MSL_NO_PARTIAL_SPECIALIZATION) &amp;&amp; !defined(_MSL_NO_MEMBER_TEMPLATE) &amp;&amp; !defined(_Inhibit_Container_Optimization)

#ifndef _MSL_NO_CPP_NAMESPACE
    } // namespace std
#endif

#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _DEQUE

// hh 971220 fixed MOD_INCLUDE
// hh 971221 Changed filename from deque.h to deque
// hh 971221 Made include guards standard
// hh 971221 Added qualified name to const_iterator
// hh 971221 Added qualified name to iterator
// hh 971230 added RC_INVOKED wrapper
// hh 980105 changed pointer &amp; reference to const versions in const_iterator base class
// hh 980105 rewrote some constructors to get rid of unused arg dq warning
// hh 980111 &lt;string&gt; added so deque could throw a stdexcept
// hh 980111 made at and operator[] standard compliant
// hh 980713 Temporarily moved member templates into class definition to support compiler
// hh 980902 #ifdef'd out exception code when ndef MSIPL_EXCEPT
// hh 981027 rewrote
// hh 981208 changed static_cast to reinterpret_cast on the value_type (pointer specialization only)
// hh 981209 Protected clear() from an empty buf_
// hh 981210 Modified insertion into front half to preserve outstanding iterators under exceptions
//           and made it more efficient when the initial size is zero.
// hh 981210 Added forgotten for loop in insert
// hh 981220 Rewrote iterators to gain higher performance
// hh 981220 Added typename to appropriate return types
// hh 981220 Modifed some method signitures to simplified syntax
// hh 981220 Added class modifier to several friend declarations
// hh 990120 changed name of MSIPL flags
// hh 990720 Made iterator comparison methods global friends.
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>