<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File char_io.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-char_ioc">File char_io.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_30eb297d72d9bf6e37ae97b245365a16/"><strong>MSL_C</strong></a> <strong>&gt;</strong> <a href="../dir_5ff331ae3d8ec7992933a87ab898fc05/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_296ea1c022f8cfa02577b9a5b06211f5/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../char__io_8c/"><strong>char_io.c</strong></a></p>
<p><a href="../char__io_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/01/22 23:40:32 $ 
 *  $Revision: 1.7 $ 
 *  $NoKeywords: $ 
 *
 *      Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/*
 *  char_io.c
 *
 *  Routines
 *  --------
 *      fgetc
 *      getc
 *      getchar
 *
 *      fgets
 *      gets
 *
 *      ungetc
 *
 *      fputc
 *      putc
 *      putchar
 *
 *      fputs
 *      puts
 *
 *      __get_char
 *      __put_char
 *
 *      __ungotten
 *
 *
 */

#include &lt;stdio.h&gt;
#include &quot;ansi_files.h&quot;
#include &quot;buffer_io.h&quot;
#include &quot;char_io.h&quot;
#include &quot;misc_io.h&quot;

#ifndef __m56800__                      /* mm 981029 */
int __get_char(FILE * file)
{
    int state, ioresult;

    file-&gt;buffer_len = 0;

    if (file-&gt;state.error || file-&gt;mode.file_kind == __closed_file)
        return(EOF);

    state = file-&gt;state.io_state;

    if (state == __writing || !(file-&gt;mode.io_mode &amp; __read))
    {
        set_error(file);
        return(EOF);
    }

    if (state &gt;= __rereading)
    {
        file-&gt;state.io_state--;

        if (state == __rereading)
            file-&gt;buffer_len = file-&gt;saved_buffer_len;

        return(file-&gt;ungetc_buffer[state - __rereading]);
    }
    else
        file-&gt;state.io_state = __reading;

    ioresult = __load_buffer(file, NULL, __align_buffer);

    if (ioresult || !file-&gt;buffer_len)
    {
        if (ioresult == __io_error)
            set_error(file);
        else
            set_eof(file);

        return(EOF);
    }

    file-&gt;buffer_len--;

    return(*file-&gt;buffer_ptr++);
}
#endif  /* #ifndef __m56800__ */           /* mm 981029 */

int fgetc(FILE * file)
{
    return(getc(file));
}

int (getc)(FILE * file)
{
    return(getc(file));
}

#ifndef __m56800__                      /* mm 981029 */
int (getchar)(void)
{
    return(getchar());
}
#endif  /* #ifndef __m56800__ */           /* mm 981029 */

char * fgets(char * s, int n, FILE * file)
{
    char *  p = s;
    int         c;

    if (--n &lt; 0)
        return(NULL);

    if (n)
        do
        {
            c = getc(file);

            if (c == EOF)
                if (file-&gt;state.eof &amp;&amp; p != s)
                    break;
                else
                    return(NULL);

            *p++ = c;
        }
        while (c != '\n' &amp;&amp; --n);

    *p = 0;

    return(s);
}

char * gets(char * s)
{
    char *  p = s;
    int         c;
    FILE *  file = stdin;

    for (;;)
    {
        c = getc(file);

        if (c == EOF)
            if (file-&gt;state.eof &amp;&amp; p != s)
                break;
            else
                return(NULL);

        if (c == '\n')
            break;

        *p++ = c;
    }

    *p = 0;

    return(s);
}

#ifndef __m56800__                      /* mm 981029 */
int ungetc(int c, FILE * file)
{
    int state = file-&gt;state.io_state;

#ifndef __NO_WIDE_CHAR                                      /* mm 980205 */
    if (fwide(file, -1) &gt;= 0)
        return(EOF);
#endif /* __NO_WIDE_CHAR */                                 /* mm 980205 */

    if (state == __writing || state == __rereading + __ungetc_buffer_size - 1 || c == EOF)
        return(EOF);

    if (state &lt; __rereading)
    {   
        file-&gt;saved_buffer_len = file-&gt;buffer_len;
        file-&gt;buffer_len       = 0;

        state = file-&gt;state.io_state = __rereading;
    }
    else
        state = ++file-&gt;state.io_state;

    file-&gt;ungetc_buffer[state - __rereading] = c;

    file-&gt;state.eof = 0;

    return((unsigned char) c);
}
#endif  /* #ifndef __m56800__ */           /* mm 981029 */

int __ungotten(FILE * file)
{
    if (file-&gt;state.io_state &lt; __rereading)
        return(EOF);

    return(file-&gt;ungetc_buffer[file-&gt;state.io_state - __rereading]);
}

#ifndef __m56800__                      /* mm 981029 */
int __put_char(int c, FILE * file)
{
    int kind = file-&gt;mode.file_kind;

    file-&gt;buffer_len = 0;

    if (file-&gt;state.error || kind == __closed_file)
        return(EOF);

    if (kind == __console_file)
        __stdio_atexit();

    if (file-&gt;state.io_state == __neutral)
        if (file-&gt;mode.io_mode &amp; __write)
        {
#ifndef _No_Disk_File_OS_Support
            if (file-&gt;mode.io_mode &amp; __append)
                if (fseek(file, 0, SEEK_END))
                    return(0);
#endif

            file-&gt;state.io_state = __writing;

            __prep_buffer(file);
        }

    if (file-&gt;state.io_state != __writing)
    {
        set_error(file);
        return(EOF);
    }

    if (file-&gt;mode.buffer_mode == _IOFBF || file-&gt;buffer_ptr - file-&gt;buffer == file-&gt;buffer_size)
        if (__flush_buffer(file, NULL))
        {
            set_error(file);
            return(EOF);
        }

     file-&gt;buffer_len--;
    *file-&gt;buffer_ptr++ = c;

    if (file-&gt;mode.buffer_mode != _IOFBF)
    {
        if ((file-&gt;mode.buffer_mode == _IONBF || c == '\n'))
            if (__flush_buffer(file, NULL))
            {
                set_error(file);
                return(EOF);
            }

        file-&gt;buffer_len = 0;
    }

    return((unsigned char) c);
}

#endif  /* #ifndef __m56800__ */           /* mm 981029 */

int fputc(int c, FILE * file)
{
    return(putc(c, file));
}

int (putc)(int c, FILE * file)
{
    return(putc(c, file));
}

#ifndef __m56800__                      /* mm 981029 */
int (putchar)(int c)
{
    return(putchar(c));
}
#endif  /* #ifndef __m56800__ */           /* mm 981029 */

int fputs(const char * s, FILE * file)
{
    int c;

    while ((c = *s++) != 0)
        if (putc(c, file) == EOF)
            return(EOF);

    return(0);
}

int puts(const char * s)
{
    int         c;
    FILE *  file = stdout;

    while ((c = *s++) != 0)
        if (putc(c, file) == EOF)
            return(EOF);

    c = '\n';

    if (putc(c, file) == EOF)
        return(EOF);

    return(0);
}

/*  Change Record
 *  08-Sep-95 JFH  First code release.
 *  16-Oct-95 JFH  Added __ungotten for SIOUX PascalHook
 *  08-Jan-96 JFH  At the behest of Be, I put in real output line buffering.
 *  22-Jan-96 JFH  Bracketed getc(), getchar(), putc(), and putchar() by #ifndef __cplusplus
 *                               (they are inlined in &lt;stdio.h&gt;).
 *  12-Feb-96 JFH  Added call to __stdio_atexit in __put_char for console files (so they will
 *                               get flushed and closed properly).
 *  19-Feb-96 JFH  Added check for closed files to __get_char and __put_char.
 *   4-Mar-96 JFH  Allowed ungetc to work when a file is in the __neutral io_state.
 *  25-Apr-96 JFH  Modified __get_char, ungetc, and __ungotten to account for multi-level 'ungetc'.
 *  12-Jun-97 FS   Added #if __dest_os == __ppc_eabi_bare for Motorola 821
 *  10-Jul-97 SCM  Removed __ppc_eabi_bare conditions after implementing
 *                  serial console IO for non-os systems.
 *  20-Jul-97 MEA  Changed __no_os to _No_Disk_File_OS_Support.
 *  mm 980204      Changes to file structure to support wide characters
 *  mm 981029     Excluded certain functions for __m56800__
*/
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>