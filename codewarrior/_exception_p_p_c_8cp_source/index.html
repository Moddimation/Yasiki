<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File ExceptionPPC.cp - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-exceptionppccp">File ExceptionPPC.cp</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_e69745e3285a8d4f155d29d88e1a7b6b/"><strong>Runtime</strong></a> <strong>&gt;</strong> <a href="../dir_1789e36d750963f536ec280b459db2bf/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../_exception_p_p_c_8cp/"><strong>ExceptionPPC.cp</strong></a></p>
<p><a href="../_exception_p_p_c_8cp/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">//
//  ExceptionPPC.cp     -   Exception Handling Runtime Support for CodeWarrior(PowerPC)
//
//  Copyright ã‚¥ 1995-1997 Metrowerks, Inc.  All rights reserved.
//
//
//  POWERPC STACK FRAME FORMAT
//
//  The PowerPC runtime architecture uses a grow-down stack with a single stack
//  pointer at the low address end. The stack has the following organization:
//  
//
//  LOW ADDRESSES   |                       |
//                  |                       |
//                  |-----------------------|
//                  |   GPR save area       |
//                  |-----------------------|   Can be used by frameless leaf routines
//                  |   FPR save area       |
//  Callee's SP   =&gt;|-----------------------|
//                  |       Callee's        |
//                  |     linkage area      |
//                  |-----------------------|
//                  |       Callee's        |   Storage for parameters passed to
//                  |   parameter area      |   routines called by callee
//                  |-----------------------|
//                  |       Callee's        |
//                  |   local variables     |
//                  |-----------------------|
//                  |   alignment gap 1     |
//                  |-----------------------|
//                  |   GPR save area       |   Storage for nonvolatile GPRs used by callee
//                  |-----------------------|
//                  |   alignment gap 2     |
//                  |-----------------------|
//                  |   FPR save area       |   Storage for nonvolatile FPRs used by callee
//  Caller's SP   =&gt;|-----------------------|
//                  |       Caller's        |
//                  |     linkage area      |
//                  |-----------------------|
//                  |       Caller's        |   Storage for parameters passed to
//                  |   parameter area      |   callee
//                  |-----------------------|
//                  |       Caller's        |
//                  |   local variables     |
//                  |-----------------------|
//                  |                       |
//  HIGH ADDRESSES  |                       |
//
//
//  where the &quot;linkage area&quot; looks like this:
//
//
//                  |-----------------------|
//              0   | Stack Frame Back Link |   Pointer to caller's frame
//                  |-----------------------|
//              4   |       Saved CR        |   Our CR (saved by routines we call)
//                  |-----------------------|
//              8   |       Saved LR        |   Our LR (saved by routines we call)
//                  |-----------------------|
//              12  |       (Reserved)      |
//                  |-----------------------|
//              16  |       (Reserved)      |
//                  |-----------------------|
//              20  |   Saved TOC Pointer   |   Our TOC (saved by cross-TOC glue)
//                  |-----------------------|
//
//
//  To unwind the stack, we start with a return address and SP for the routine which
//  threw the exception. The next return address can be found by following the
//  back-link at 0(SP) and accessing the saved LR in that frame.
//
//  Restoring registers is slightly more tricky. If 'saved_CR' is true, we restore
//  the CR from the callers linkage area. For saved GPRs and FPRs we start with
//  the callers SP; the &lt;n&gt; saved FPRs will be at &lt;callers SP&gt; - (8 * &lt;n&gt;) and the
//  &lt;m&gt; saved GPRs will be the (&lt;m&gt; * 4) words ending at at &lt;callers SP&gt; - (8 * &lt;n&gt;)
//  adjusted so that the last word ends on a 16-byte boundary. (See below)
//
//

#if __MWERKS__
#pragma exceptions on
#endif

#define __NOSTRING__    //  do not include &lt;string&gt;

#include &lt;stdlib.h&gt;
#include &lt;MWCPlusLib.h&gt;
#include &lt;exception.h&gt;
#include &quot;ExceptionPPC.h&quot;
#include &lt;NMWException.h&gt;   // ra 990322 changed from &quot;&quot; to &lt;&gt;

#if __PPC_EABI__
#include &lt;__ppc_eabi_linker.h&gt;      /* linker-generated symbol declarations */
#define RETURN_ADDRESS 4
#else
#define RETURN_ADDRESS 8
#define nofralloc
#endif

#if 1
#define INLINE          static              //  static for debugging
#else
#define INLINE          inline              //  inline for shipping code
#endif

#if __VEC__
#pragma options align=power
#endif

#if __VEC__
union MWEVector128 {
    __vector unsigned long          vul;
    unsigned long                   l[4];
    unsigned short                  s[8];
    unsigned char                   c[16];
};
typedef union MWEVector128 MWEVector128;
#endif

//  typedefs

typedef struct ThrowContext {
#if __VEC__
    MWEVector128 VR[32];                    //  VR0-VR31 (not all are saved/restored)
    MWEVector128 vscr;
    unsigned long vrsave;
#endif
#ifndef _No_Floating_Point_Regs
    double      FPR[32];                    //  FPR0-FPR31  (not all are saved/restored)
#endif
    long        GPR[32];                    //  GPR0-GPR31  (not all are saved/restored)
    long        CR;                         //  CR0-CR7
    char*       SP;                         //  stack pointer during unwind (used for linkage)
    char*       FP;                         //  frame pointer during unwind (used for locals)
    char*       throwSP;                    //  stack pointer at throw
    char*       returnaddr;                 //  return address
    char*       throwtype;                  //  throw type argument (0L: rethrow: throw; )
    void*       location;                   //  location argument (0L: rethrow: throw; )
    void*       dtor;                       //  dtor argument
    CatchInfo   *catchinfo;                 //  pointer to rethrow CatchInfo (or 0L)    
}   ThrowContext;

typedef struct MWExceptionInfo {
    ExceptionTableSmall*    exception_record;       //  pointer to exception table (small or large)
    char*           current_function;       //  pointer to current function
    char*           action_pointer;         //  pointer to action
    char*           code_section;           //  base of code section for fragment containing table
    char*           data_section;           //  base of data section for fragment containing table
    char*           TOC;                    //  TOC pointer for fragment containing table
}   MWExceptionInfo;

typedef struct FragmentInfo {
    ExceptionTableIndex*    exception_start;    //  start of exception table index for fragment
    ExceptionTableIndex*    exception_end;      //  end of exception table index for fragment
    char*                   code_start;         //  start of code section for fragment
    char*                   code_end;           //  end of code section for fragment
    char*                   data_start;         //  start of data section for fragment
    char*                   data_end;           //  end of data section for fragment
    char*                   TOC;                //  TOC pointer for fragment
    int                     active;             //  true: fragmentinfo element is registered
} FragmentInfo;

typedef struct ProcessInfo {
    __eti_init_info*        exception_info;     //  start of exception table index for fragment
    char*                   TOC;                //  TOC pointer for fragment
    int                     active;             //  true: fragmentinfo element is registered
} ProcessInfo;

typedef struct ActionIterator {
    MWExceptionInfo info;                   //  pointer to exception record
    char*           current_SP;             //  current stack pointer
    char*           current_FP;             //  current frame pointer (SP or R31)
    long            current_R31;            //  current R31
}   ActionIterator;

#if __VEC__
#pragma options align=reset
#endif

#if __PPC_EABI__
#define MAXFRAGMENTS __CW_MAX_PROCESSES__   //  maximum # of code fragments we can register
static ProcessInfo fragmentinfo[MAXFRAGMENTS];
#else
#define MAXFRAGMENTS    32                  //  maximum # of code fragments we can register
static FragmentInfo fragmentinfo[MAXFRAGMENTS];
#endif


typedef void (*DeleteFunc)(void *);


#if __PPC_EABI__
/************************************************************************/
/* Purpose..: Register a code fragment and its exception tables         */
/* Input....: pointer to __eti_init_info structure              */
/* Input....: TOC for fragment                                          */
/* Return...: unique ID for __ex_unregister_fragment                    */
/************************************************************************/
int __register_fragment(struct __eti_init_info *info, char *TOC)
{
    ProcessInfo *f;
    int i;

    //  find a free entry in the fragment table
    for(i=0,f=fragmentinfo;i&lt;MAXFRAGMENTS;++i,++f) if(f-&gt;active==0)
    {
        f-&gt;exception_info=info;
        f-&gt;TOC=TOC;
        f-&gt;active=1;
        return(i);
    }
    //  couldn't register the fragment
    return(-1);
}
#else
/************************************************************************/
/* Purpose..: Register a code fragment and its exception tables         */
/* Input....: pointer to start of fragments code section                */
/* Input....: pointer to end   of fragments code section                */
/* Input....: pointer to start of fragments data section                */
/* Input....: pointer to end   of fragments data section                */
/* Input....: pointer to start of fragments exception table index       */
/* Input....: pointer to end   of fragments exception table index       */
/* Input....: RTOC for fragment                                         */
/* Return...: unique ID for __ex_unregister_fragment                    */
/************************************************************************/
int __register_fragment(char *code_start, char *code_end,
                        char *data_start, char *data_end,
                        char *exception_start, char *exception_end,
                        char *TOC)
{
    FragmentInfo *f;
    int i;

    //  find a free entry in the fragment table
    for(i=0,f=fragmentinfo;i&lt;MAXFRAGMENTS;++i,++f) if(f-&gt;active==0)
    {
        f-&gt;code_start=code_start;
        f-&gt;code_end=code_end;
        f-&gt;data_start=data_start;
        f-&gt;data_end=data_end;
        f-&gt;exception_start=(ExceptionTableIndex *)exception_start;
        f-&gt;exception_end=(ExceptionTableIndex *)exception_end;
        f-&gt;TOC=TOC;
        f-&gt;active=1;
        return(i);
    }
    //  couldn't register the fragment
    return(-1);
}
#endif

/************************************************************************/
/* Purpose..: Un-register a code fragment and its exception tables      */
/* Input....: unique ID assigned in __ex_register_fragment              */
/* Return...: ---                                                       */
/************************************************************************/
#if __PPC_EABI__
void __unregister_fragment(int fragmentID)
{
    ProcessInfo *f;

    if(fragmentID&gt;=0 &amp;&amp; fragmentID&lt;MAXFRAGMENTS)
    {
        f = &amp;fragmentinfo[fragmentID];
        f-&gt;exception_info=0;
        f-&gt;TOC=0;
        f-&gt;active=0;
    }
}
#else
void __unregister_fragment(int fragmentID)
{
    FragmentInfo *f;

    if(fragmentID&gt;=0 &amp;&amp; fragmentID&lt;MAXFRAGMENTS)
    {
        f = &amp;fragmentinfo[fragmentID];
        f-&gt;code_start=0; f-&gt;code_end=0;
        f-&gt;data_start=0; f-&gt;data_end=0;
        f-&gt;exception_start=0; f-&gt;exception_end=0;
        f-&gt;TOC=0;
        f-&gt;active=0;
    }
}
#endif

/************************************************************************/
/* Purpose..: Get an exception fragment record pointer                  */
/* Input....: pointer to return address                                 */
/* Return...: pointer to FragmentInfo struct                            */
/************************************************************************/
#if __PPC_EABI__
static int ExPPC_FindExceptionFragment(char *returnaddr, FragmentInfo *frag)
{
    ProcessInfo *f;
    int i;
    __eti_init_info *eti_info;

    for(i=0,f=fragmentinfo;i&lt;MAXFRAGMENTS;++i,++f) if(f-&gt;active)
    {
        eti_info = f-&gt;exception_info;
        while (1) {
            if (eti_info-&gt;code_size == 0) break;
            if(returnaddr&gt;=eti_info-&gt;code_start &amp;&amp; 
                    returnaddr&lt;(char*)eti_info-&gt;code_start+eti_info-&gt;code_size) {
                frag-&gt;exception_start = (ExceptionTableIndex *)eti_info-&gt;eti_start;
                frag-&gt;exception_end = (ExceptionTableIndex *)eti_info-&gt;eti_end;
                    /* the starts and ends are only used to find the fragment  */ 
                frag-&gt;code_start = 0;
                frag-&gt;code_end = 0;
                frag-&gt;data_start = 0;
                frag-&gt;data_end = 0;
                frag-&gt;TOC = f-&gt;TOC;
                frag-&gt;active = f-&gt;active;
                return(1);
            }
            eti_info++;
        }
    }

    return(0);
}
#else
static FragmentInfo *ExPPC_FindExceptionFragment(char *returnaddr)
{
    FragmentInfo *f;
    int i;

    for(i=0,f=fragmentinfo;i&lt;MAXFRAGMENTS;++i,++f) if(f-&gt;active)
    {
        if(returnaddr&gt;=f-&gt;code_start &amp;&amp; returnaddr&lt;f-&gt;code_end) return(f);
    }

    return(0);
}
#endif

/************************************************************************/
/* Purpose..: Get a exception record pointer                            */
/* Input....: pointer to return address                                 */
/* Input....: pointer to MWExceptionInfo struct for result              */
/* Return...: ---                                                       */
/************************************************************************/
static void ExPPC_FindExceptionRecord(char *returnaddr,MWExceptionInfo *info)
{
    FragmentInfo *fragment;
#if __PPC_EABI__
    FragmentInfo frag;
#endif
    ExceptionTableIndex *exceptionindex,*p;
    unsigned long returnoffset;
    long i,m,n;

    //  so far we haven't found anything
    info-&gt;exception_record=0;
    info-&gt;action_pointer=0;

    //  find the exception table for the fragment containing 'returnaddr'
#if __PPC_EABI__
    if ((ExPPC_FindExceptionFragment(returnaddr, &amp;frag))==0) return;
    fragment = &amp;frag;
#else
    if ((fragment=ExPPC_FindExceptionFragment(returnaddr))==0) return;
#endif
    info-&gt;code_section=fragment-&gt;code_start;
    info-&gt;data_section=fragment-&gt;data_start;
    info-&gt;TOC=fragment-&gt;TOC;

    //  binary-search the exception table index for a function containing 'returnaddr'
    returnoffset=returnaddr-fragment-&gt;code_start;
    exceptionindex=fragment-&gt;exception_start;
    for(i=0,n=fragment-&gt;exception_end-fragment-&gt;exception_start;;)
    {
        if(i&gt;n) return;
        p=&amp;exceptionindex[m=(i+n)/2];
        if(returnoffset&lt;p-&gt;functionoffset) n=m-1;
        else if(returnoffset&gt;p-&gt;functionoffset+ETI_GetFunctionSize(p-&gt;eti_field)) i=m+1;
        else break;
    }
    info-&gt;current_function=fragment-&gt;code_start+p-&gt;functionoffset;
    info-&gt;exception_record=ETI_GetDirectStore(p-&gt;eti_field)?(ExceptionTableSmall *)(&amp;p-&gt;exceptionoffset)
                                        :(ExceptionTableSmall *)(fragment-&gt;data_start+p-&gt;exceptionoffset);

    //  find the set of actions to perform for an exception thrown from 'returnaddr'
    returnoffset-=p-&gt;functionoffset;

    if ( ET_IsLargeTable(info-&gt;exception_record-&gt;et_field) )
    {
        ExceptionTableLarge *etl = (ExceptionTableLarge *) info-&gt;exception_record;
        ExceptionRangeLarge *erl; 

        for( erl = etl-&gt;ranges; erl-&gt;start != 0; erl++ )
        {
            unsigned long range_end = erl-&gt;start + (erl-&gt;size * 4);     // large range is 256K (64K * 4) ... (+4?)

            if ( erl-&gt;start &lt;= returnoffset &amp;&amp; range_end &gt;= returnoffset )
            {
                info-&gt;action_pointer = (char *) etl + erl-&gt;action; 
                break;
            }
        }
    }
    else
    {
#if __VEC__
        ExceptionTableSmall *ets        = (ExceptionTableSmall *)       info-&gt;exception_record;
        ExceptionTableSmallVector *etsv = (ExceptionTableSmallVector *) info-&gt;exception_record;
        ExceptionRangeSmall *ers;

        if ( ET_HasVectorInfo(info-&gt;exception_record-&gt;et_field) ) {
            for( ers = etsv-&gt;ranges; ers-&gt;start != 0; ers++ ) {
                if( ers-&gt;start &lt;= returnoffset &amp;&amp; ers-&gt;end &gt;= returnoffset) {
                    info-&gt;action_pointer = (char *) etsv + ers-&gt;action; 
                    break;
                }
            }
        }
        else {
            for( ers = ets-&gt;ranges; ers-&gt;start != 0; ers++ ) {
                if( ers-&gt;start &lt;= returnoffset &amp;&amp; ers-&gt;end &gt;= returnoffset) {
                    info-&gt;action_pointer = (char *) ets + ers-&gt;action; 
                    break;
                }
            }
        }
#else
        ExceptionTableSmall *ets = (ExceptionTableSmall *) info-&gt;exception_record;
        ExceptionRangeSmall *ers;

        for( ers = ets-&gt;ranges; ers-&gt;start != 0; ers++ )
        {
            if( ers-&gt;start &lt;= returnoffset &amp;&amp; ers-&gt;end &gt;= returnoffset)
            {
                info-&gt;action_pointer = (char *) ets + ers-&gt;action; 
                break;
            }
        }
#endif

    }
}

/************************************************************************/
/* Purpose..: Find R31 saved in given stack frame                       */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to topmost exception record                       */
/* Return...: pointer to return PC                                      */
/************************************************************************/
static long ExPPC_PopR31(char *SP,MWExceptionInfo *info)
{
#ifndef _No_Floating_Point_Regs
    double *FPR_save_area;
#endif
    long *GPR_save_area;
    int saved_GPRs, saved_FPRs;

#ifndef _No_Floating_Point_Regs
    //  find saved FPRs
    saved_FPRs=ET_GetSavedFPRs(info-&gt;exception_record-&gt;et_field);
    FPR_save_area=(double *)(SP-saved_FPRs*8);

    //  find saved GPRs
    saved_GPRs=ET_GetSavedGPRs(info-&gt;exception_record-&gt;et_field);
    GPR_save_area=(long *)FPR_save_area;
    if(saved_FPRs&amp;1) GPR_save_area-=2;  // 8-byte gap if # saved FPRs is odd
#else
    //  find saved GPRs
    saved_GPRs=ET_GetSavedGPRs(info-&gt;exception_record-&gt;et_field);
    GPR_save_area=(long *)SP;
#endif

    //  return saved R31
    return(GPR_save_area[-1]);  //  R31 is last register saved, has highest address
}

/************************************************************************/
/* Purpose..: Return current exception action type                      */
/* Input....: pointer to ActionIterator                                 */
/* Return...: action type                                               */
/************************************************************************/
static exaction_type ExPPC_CurrentAction(const ActionIterator *iter)
{
    if(iter-&gt;info.action_pointer==0) return EXACTION_ENDOFLIST;
    return ((ex_destroylocal *)iter-&gt;info.action_pointer)-&gt;action&amp;EXACTION_MASK;
}

/************************************************************************/
/* Purpose..: Move to next action in Exception Table                    */
/* Input....: pointer to ActionIterator                                 */
/* Return...: next action type                                          */
/************************************************************************/
static exaction_type ExPPC_NextAction(ActionIterator *iter)
{
    exaction_type   action;

    for(;;)
    {
        if( iter-&gt;info.action_pointer==0
        ||  ((action=((ex_destroylocal *)iter-&gt;info.action_pointer)-&gt;action)&amp;EXACTION_ENDBIT)!=0 )
        {   //  end of action list: find next exception record
            char *return_addr, *callers_SP;

            //  get LR saved in linkage area of caller
            callers_SP=*(char **)iter-&gt;current_SP;
            if(ET_GetSavedGPRs(iter-&gt;info.exception_record-&gt;et_field)) iter-&gt;current_R31=ExPPC_PopR31(callers_SP,&amp;iter-&gt;info);
            return_addr=*(char **)(callers_SP+RETURN_ADDRESS);
            ExPPC_FindExceptionRecord(return_addr,&amp;iter-&gt;info);
            if(iter-&gt;info.exception_record==0) terminate(); //  cannot find matching exception record
            //  pop down to caller's stack frame
            iter-&gt;current_SP=callers_SP;
            iter-&gt;current_FP=(ET_GetHasFramePtr(iter-&gt;info.exception_record-&gt;et_field))?(char *)iter-&gt;current_R31:iter-&gt;current_SP;
            if(iter-&gt;info.action_pointer==0) continue;      //  no actions
        }
        else
        {
            switch(action)
            {
            case EXACTION_DESTROYLOCAL:
                iter-&gt;info.action_pointer+=sizeof(ex_destroylocal); break;
            case EXACTION_DESTROYLOCALCOND:
                iter-&gt;info.action_pointer+=sizeof(ex_destroylocalcond); break;
            case EXACTION_DESTROYLOCALPOINTER:
                iter-&gt;info.action_pointer+=sizeof(ex_destroylocalpointer); break;
            case EXACTION_DESTROYLOCALARRAY:
                iter-&gt;info.action_pointer+=sizeof(ex_destroylocalarray); break;
            case EXACTION_DESTROYBASE:
            case EXACTION_DESTROYMEMBER:
                iter-&gt;info.action_pointer+=sizeof(ex_destroymember); break;
            case EXACTION_DESTROYMEMBERCOND:
                iter-&gt;info.action_pointer+=sizeof(ex_destroymembercond); break;
            case EXACTION_DESTROYMEMBERARRAY:
                iter-&gt;info.action_pointer+=sizeof(ex_destroymemberarray); break;
            case EXACTION_DELETEPOINTER:
                iter-&gt;info.action_pointer+=sizeof(ex_deletepointer); break;
            case EXACTION_DELETEPOINTERCOND:
                iter-&gt;info.action_pointer+=sizeof(ex_deletepointercond); break;
            case EXACTION_CATCHBLOCK:
                iter-&gt;info.action_pointer+=sizeof(ex_catchblock); break;
            case EXACTION_CATCHBLOCK_32:
                iter-&gt;info.action_pointer+=sizeof(ex_catchblock_32); break;
            case EXACTION_ACTIVECATCHBLOCK:
                iter-&gt;info.action_pointer+=sizeof(ex_activecatchblock); break;
            case EXACTION_SPECIFICATION:
                iter-&gt;info.action_pointer+=sizeof(ex_specification)+((ex_specification *)iter-&gt;info.action_pointer)-&gt;specs*sizeof(void *); break;
            default:
                terminate();    //  error
            }
        }
        action=((ex_destroylocal *)iter-&gt;info.action_pointer)-&gt;action&amp;EXACTION_MASK;
        if(action==EXACTION_BRANCH)
        {   //  skip to target action--we never return EXACTION_BRANCH to caller!
            iter-&gt;info.action_pointer=((char *)iter-&gt;info.exception_record)+((ex_branch *)iter-&gt;info.action_pointer)-&gt;target;
            action=((ex_destroylocal *)iter-&gt;info.action_pointer)-&gt;action&amp;EXACTION_MASK;
        }
        return action;
    }
}

/************************************************************************/
/* Purpose..: Restore registers                                         */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to topmost exception record                       */
/* Return...: pointer to return PC                                      */
/************************************************************************/
static char *ExPPC_PopStackFrame(ThrowContext *context,MWExceptionInfo *info)
{
    char *SP, *callers_SP;
#ifndef _No_Floating_Point_Regs
    double *FPR_save_area;
#endif
    long *GPR_save_area;
    int saved_GPRs, saved_FPRs;
#if __VEC__
    MWEVector128 *VR_save_area;
    int saved_VRs;
#endif
    int i, j;

    //  obtain current and callers frame pointers
    SP=context-&gt;SP; callers_SP=*(char **)SP;

    //  restore saved FPRs
#ifndef _No_Floating_Point_Regs
    saved_FPRs=ET_GetSavedFPRs(info-&gt;exception_record-&gt;et_field);
    FPR_save_area=(double *)(callers_SP-saved_FPRs*8);
    for(i=32-saved_FPRs, j=0;i&lt;32;++i,++j) context-&gt;FPR[i]=FPR_save_area[j];
#endif

    //  restore saved GPRs
    saved_GPRs=ET_GetSavedGPRs(info-&gt;exception_record-&gt;et_field);
//  GPR_save_area=(long *)(((long)FPR_save_area&amp;0xFFFFFFF0)-saved_GPRs*4);
//  for(i=32-saved_GPRs, j=0;i&lt;32;++i,++j) context-&gt;GPR[i]=GPR_save_area[j];
#ifndef _No_Floating_Point_Regs
    GPR_save_area=(long *)FPR_save_area;
#if !__PPC_EABI__
    if(saved_FPRs&amp;1) GPR_save_area-=2;  // 8-byte gap if # saved FPRs is odd
#endif
    GPR_save_area-=saved_GPRs;
#else
    GPR_save_area = (long *)(callers_SP-saved_GPRs*4);
#endif
    for(i=32-saved_GPRs, j=0;i&lt;32;++i,++j) context-&gt;GPR[i]=GPR_save_area[j];

#if __VEC__
    //  restore saved VRs
    if ( ET_HasVectorInfo(info-&gt;exception_record-&gt;et_field) )
    {
        ExceptionTableSmallVector *etsv = (ExceptionTableSmallVector *) info-&gt;exception_record;
        int vrsavesize                  = ET_GetSavedVRSAVE(etsv-&gt;et_field) ? sizeof(long) : 0;
        saved_VRs                       = ET_GetSavedVRs(etsv-&gt;et_field);

        VR_save_area    =   (MWEVector128 *) GPR_save_area;
        VR_save_area    -=  vrsavesize;
        VR_save_area    -=  saved_VRs;

        VR_save_area    =  (MWEVector128 *) ( (unsigned int) VR_save_area &amp; 0xFFFFFFF0 );       // align to 16-byte boundary

        for(i=32-saved_VRs, j=0;i&lt;32;++i,++j) context-&gt;VR[i]=VR_save_area[j];
    }
#endif

    //  restore saved CR
#if !__PPC_EABI__ // ignore for now (never saved)
    if(ET_GetSavedCR(info-&gt;exception_record-&gt;et_field)) context-&gt;CR=*(long *)(callers_SP+4);
#endif

    //  restore saved SP (back link)
    context-&gt;SP=callers_SP;

    //  return new return_addr
    return(*(char **)(callers_SP+RETURN_ADDRESS));
}

/************************************************************************/
/* Purpose..: Unwind ex_destroylocal struct                             */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_destroylocal struct                         */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DestroyLocal(ThrowContext *context,const ex_destroylocal *ex)
{
    DTORCALL_COMPLETE(ex-&gt;dtor,context-&gt;FP+ex-&gt;local);
}

/************************************************************************/
/* Purpose..: Unwind ex_destroylocalcond struct                         */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_destroylocalcond struct                     */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DestroyLocalCond(ThrowContext *context,const ex_destroylocalcond *ex)
{
    int cond = ex_destroylocalcond_GetRegCond(ex-&gt;dlc_field)    ? (local_cond_type) context-&gt;GPR[ex-&gt;cond]
                            : *(local_cond_type *)(context-&gt;FP+ex-&gt;cond);

    if(cond) DTORCALL_COMPLETE(ex-&gt;dtor,context-&gt;FP+ex-&gt;local);
}

/************************************************************************/
/* Purpose..: Unwind ex_destroylocalpointer struct                      */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_destroylocalpointer struct                  */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DestroyLocalPointer(ThrowContext *context,const ex_destroylocalpointer *ex)
{
    void *pointer = ex_destroylocalpointer_GetRegPointer(ex-&gt;dlp_field) ? (void *) context-&gt;GPR[ex-&gt;pointer]
                                    : *(void **)(context-&gt;FP+ex-&gt;pointer);

    DTORCALL_COMPLETE(ex-&gt;dtor,pointer);
}

/************************************************************************/
/* Purpose..: Unwind ex_destroylocalarray struct                        */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_destroylocalarray struct                    */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DestroyLocalArray(ThrowContext *context,const ex_destroylocalarray *ex)
{
    char *ptr   = context-&gt;FP+ex-&gt;localarray;
    long n      = ex-&gt;elements;
    long size   = ex-&gt;element_size;

    for(ptr=ptr+size*n; n&gt;0; n--)
    {
        ptr-=size; DTORCALL_COMPLETE(ex-&gt;dtor,ptr);
    }
}

/************************************************************************/
/* Purpose..: Unwind ex_destroymember struct                            */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_destroymember struct                        */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DestroyMember(ThrowContext *context,const ex_destroymember *ex)
{
    char *objectptr = ex_destroymember_GetRegPointer(ex-&gt;dm_field)  ? (char *) context-&gt;GPR[ex-&gt;objectptr]
                                        : *(char **)(context-&gt;FP+ex-&gt;objectptr);

    DTORCALL_COMPLETE(ex-&gt;dtor,objectptr+ex-&gt;offset);
}

/************************************************************************/
/* Purpose..: Unwind ex_destroymember struct                            */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_destroymember struct                        */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DestroyBase(ThrowContext *context,const ex_destroymember *ex)
{
    char *objectptr = ex_destroymember_GetRegPointer(ex-&gt;dm_field)  ? (char *) context-&gt;GPR[ex-&gt;objectptr]
                                        : *(char **)(context-&gt;FP+ex-&gt;objectptr);

    DTORCALL_PARTIAL(ex-&gt;dtor,objectptr+ex-&gt;offset);
}

/************************************************************************/
/* Purpose..: Unwind ex_destroymembercond struct                        */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_destroymembercond struct                    */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DestroyMemberCond(ThrowContext *context,const ex_destroymembercond *ex)
{
    char *objectptr = ex_destroymembercond_GetRegPointer(ex-&gt;dmc_field) ? (char *) context-&gt;GPR[ex-&gt;objectptr]
                                        : *(char **)(context-&gt;FP+ex-&gt;objectptr);
    int cond = ex_destroymembercond_GetRegCond(ex-&gt;dmc_field)   ? (vbase_ctor_arg_type) context-&gt;GPR[ex-&gt;cond]
                            : *(vbase_ctor_arg_type *)(context-&gt;FP+ex-&gt;cond);

    if(cond) DTORCALL_PARTIAL(ex-&gt;dtor,objectptr+ex-&gt;offset);
}

/************************************************************************/
/* Purpose..: Unwind ex_destroymemberarray struct                       */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_destroymemberarray struct                   */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DestroyMemberArray(ThrowContext *context,const ex_destroymemberarray *ex)
{
    char *ptr   = ex_destroymemberarray_GetRegPointer(ex-&gt;dma_field)    ? (char *) context-&gt;GPR[ex-&gt;objectptr]
                                    : *(char **)(context-&gt;FP+ex-&gt;objectptr);
    long n      = ex-&gt;elements;
    long size   = ex-&gt;element_size;

    // msw 11/28/97 -   Bug fix.
    ptr += ex-&gt;offset;

    for(ptr=ptr+size*n; n&gt;0; n--)
    {
        ptr-=size; DTORCALL_COMPLETE(ex-&gt;dtor,ptr);
    }
}

/************************************************************************/
/* Purpose..: Unwind ex_deletepointer struct                            */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_deletepointer struct                        */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DeletePointer(ThrowContext *context,const ex_deletepointer *ex)
{
    char *objectptr = ex_deletepointer_GetRegPointer(ex-&gt;dp_field)  ? (char *) context-&gt;GPR[ex-&gt;objectptr]
                                        : *(char **)(context-&gt;FP+ex-&gt;objectptr);

    ((DeleteFunc) ex-&gt;deletefunc)(objectptr);
}

/************************************************************************/
/* Purpose..: Unwind ex_deletepointercond struct                        */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to ex_deletepointercond struct                    */
/* Return...: ---                                                       */
/************************************************************************/
INLINE void ExPPC_DeletePointerCond(ThrowContext *context,const ex_deletepointercond *ex)
{
    char *objectptr = ex_deletepointercond_GetRegPointer(ex-&gt;dpc_field) ? (char *) context-&gt;GPR[ex-&gt;objectptr]
                                        : *(char **)(context-&gt;FP+ex-&gt;objectptr);
    int cond = ex_deletepointercond_GetRegCond(ex-&gt;dpc_field)   ? (local_cond_type) context-&gt;GPR[ex-&gt;cond]
                            : *(local_cond_type *)(context-&gt;FP+ex-&gt;cond);

    if(cond) ((DeleteFunc) ex-&gt;deletefunc)(objectptr);
}

/************************************************************************/
/* Purpose..: Unwind stack                                              */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to topmost action                                 */
/* Input....: pointer to catcher                                        */
/* Return...: ---                                                       */
/************************************************************************/
static void ExPPC_UnwindStack(ThrowContext *context,MWExceptionInfo *info,void *catcher)
{
    exaction_type   action;

#pragma exception_terminate     //  this will prevent exception exits during unwindind

    for(;;)
    {
        if(info-&gt;action_pointer==0)
        {
            char *return_addr;

            return_addr=ExPPC_PopStackFrame(context,info);
            ExPPC_FindExceptionRecord(return_addr,info);
            if(info-&gt;exception_record==0) terminate();      //  cannot find matching exception record
            context-&gt;FP=(ET_GetHasFramePtr(info-&gt;exception_record-&gt;et_field))?(char *)context-&gt;GPR[31]:context-&gt;SP;
            continue;
        }

        action=((ex_destroylocal *)info-&gt;action_pointer)-&gt;action;
        switch(action&amp;EXACTION_MASK)
        {
        case EXACTION_BRANCH:
            info-&gt;action_pointer=((char *)info-&gt;exception_record)+((ex_branch *)info-&gt;action_pointer)-&gt;target; break;

        case EXACTION_DESTROYLOCAL:
            ExPPC_DestroyLocal(context,(ex_destroylocal *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_destroylocal); break;

        case EXACTION_DESTROYLOCALCOND:
            ExPPC_DestroyLocalCond(context,(ex_destroylocalcond *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_destroylocalcond); break;

        case EXACTION_DESTROYLOCALPOINTER:
            ExPPC_DestroyLocalPointer(context,(ex_destroylocalpointer *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_destroylocalpointer); break;

        case EXACTION_DESTROYLOCALARRAY:
            ExPPC_DestroyLocalArray(context,(ex_destroylocalarray *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_destroylocalarray); break;

        case EXACTION_DESTROYBASE:
            ExPPC_DestroyBase(context,(ex_destroymember *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_destroymember); break;

        case EXACTION_DESTROYMEMBER:
            ExPPC_DestroyMember(context,(ex_destroymember *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_destroymember); break;

        case EXACTION_DESTROYMEMBERCOND:
            ExPPC_DestroyMemberCond(context,(ex_destroymembercond *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_destroymembercond); break;

        case EXACTION_DESTROYMEMBERARRAY:
            ExPPC_DestroyMemberArray(context,(ex_destroymemberarray *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_destroymemberarray); break;

        case EXACTION_DELETEPOINTER:
            ExPPC_DeletePointer(context,(ex_deletepointer *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_deletepointer); break;

        case EXACTION_DELETEPOINTERCOND:
            ExPPC_DeletePointerCond(context,(ex_deletepointercond *)info-&gt;action_pointer);
            info-&gt;action_pointer+=sizeof(ex_deletepointercond); break;

        case EXACTION_CATCHBLOCK:
            if(catcher==(void *)info-&gt;action_pointer) return;   //  finished unwinding
            info-&gt;action_pointer+=sizeof(ex_catchblock); break;

        case EXACTION_CATCHBLOCK_32:
            if(catcher==(void *)info-&gt;action_pointer) return;   //  finished unwinding
            info-&gt;action_pointer+=sizeof(ex_catchblock_32); break;

        case EXACTION_ACTIVECATCHBLOCK:
            {
                CatchInfo       *catchinfo;

                catchinfo=(CatchInfo *)(context-&gt;FP+((ex_activecatchblock *)info-&gt;action_pointer)-&gt;cinfo_ref);
                if ( catchinfo-&gt;dtor )
                {
                    // re-throwing exception from this block
                    if ( context-&gt;location == catchinfo-&gt;location )
                    {
                        // pass destruction responsibility to re-thrown exception
                        context-&gt;dtor = catchinfo-&gt;dtor;
                    }
                    else
                    {
                        DTORCALL_COMPLETE(catchinfo-&gt;dtor,catchinfo-&gt;location);
                    }
                }
                info-&gt;action_pointer+=sizeof(ex_activecatchblock);
            }
            break;

        case EXACTION_SPECIFICATION:
            if(catcher==(void *)info-&gt;action_pointer) return;   //  finished unwinding
            info-&gt;action_pointer+=sizeof(ex_specification)+((ex_specification *)info-&gt;action_pointer)-&gt;specs*sizeof(void *);
            break;

        default:
            terminate();            //  error
        }
        if(action&amp;EXACTION_ENDBIT) info-&gt;action_pointer=0;
    }
}

/************************************************************************/
/* Purpose..: Check if an exception is in a specification list          */
/* Input....: pointer to exception type string                          */
/* Input....: pointer to specification list                             */
/* Return...: ---                                                       */
/************************************************************************/
static int ExPPC_IsInSpecification(char *extype,ex_specification *spec)
{
    long    i,offset;

    for(i=0; i&lt;spec-&gt;specs; i++)
    {
        if(__throw_catch_compare(extype,spec-&gt;spec[i],&amp;offset)) return 1;
    }
    return 0;
}

/************************************************************************/
/* Purpose..: Unexpected handler                                        */
/* Input....: pointer to throw context                                  */
/* Return...: --- (this function will never return)                     */
/************************************************************************/
extern void __unexpected(CatchInfo* catchinfo)
{   
    ex_specification *unexp=(ex_specification *)catchinfo-&gt;stacktop;

#pragma exception_magic

    try {
        unexpected();
    }
    catch(...)
    {   //  unexpected throws an exception =&gt; check if the exception matches the specification
        if(ExPPC_IsInSpecification((char *)((CatchInfo *)&amp;__exception_magic)-&gt;typeinfo,unexp))
        {   //  new exception is in specification list =&gt; rethrow
            throw;
        }
        if(ExPPC_IsInSpecification(&quot;!bad_exception!!&quot;,unexp))
        {   //  &quot;bad_exception&quot; is in specification list =&gt; throw bad_exception()
            throw bad_exception();
        }
        if(ExPPC_IsInSpecification(&quot;!std::bad_exception!!&quot;,unexp))
        {   //  &quot;bad_exception&quot; is in specification list =&gt; throw bad_exception()
            throw bad_exception();
        }
        //  cannot handle exception =&gt; terminate();
    }
    terminate();
}

/************************************************************************/
/* Purpose..: Restore registers and branch to catcher                   */
/* Input....: pointer to throw context                                  */
/* Input....: destination RTOC                                          */
/* Input....: destination PC                                            */
/* Return...: ---                                                       */
/************************************************************************/
static asm void ExPPC_LongJump(register ThrowContext *context, register void *newRTOC, register void *newPC)
{
#if __ALTIVEC__ || __PPC_EABI__
        nofralloc
#endif

        mr          r8,newPC    
        mr          RTOC,newRTOC        //  restore RTOC
        lwz         r0,context-&gt;CR      //  restore CR
        mtcrf       255,r0

#if __VEC__
        lwz         r5,context-&gt;vrsave  
        bl          __setLR             // set LR to address of setLR               
__setLR:    

        oris        r5,r5,0x8000        // indicate vr0 also in-use
        mtvrsave    r5
        clrlwi      r5,r5,20            // clear left 20 bits
        cntlzw      r5,r5               // find first nonvolatile VR used
        slwi        r5,r5,3             // multiply by 8 for index past __longjmpv20
        mflr        r6

        addi        r6,r6,__longjmpv20 - __setLR - (20 * 8)
        add         r6,r6,r5
        mtlr        r6
        blr                             // jump to index past __longjmpv20

__longjmpv20:       
        la          r31,context-&gt;VR[20]
        lvx         vr20,r0,r31
        la          r31,context-&gt;VR[21]
        lvx         vr21,r0,r31
        la          r31,context-&gt;VR[22]
        lvx         vr22,r0,r31
        la          r31,context-&gt;VR[23]
        lvx         vr23,r0,r31
        la          r31,context-&gt;VR[24]
        lvx         vr24,r0,r31
        la          r31,context-&gt;VR[25]
        lvx         vr25,r0,r31
        la          r31,context-&gt;VR[26]
        lvx         vr26,r0,r31
        la          r31,context-&gt;VR[27]
        lvx         vr27,r0,r31
        la          r31,context-&gt;VR[28]
        lvx         vr28,r0,r31
        la          r31,context-&gt;VR[29]
        lvx         vr29,r0,r31
        la          r31,context-&gt;VR[30]
        lvx         vr30,r0,r31
        la          r31,context-&gt;VR[31]
        lvx         vr31,r0,r31
#endif

        //  restore R13-R31
#if __PPC_EABI__
    #if !__option(use_lmw_stmw)
        lwz         r14,context-&gt;GPR[14]
        lwz         r15,context-&gt;GPR[15]
        lwz         r16,context-&gt;GPR[16]
        lwz         r17,context-&gt;GPR[17]
        lwz         r18,context-&gt;GPR[18]
        lwz         r19,context-&gt;GPR[19]
        lwz         r20,context-&gt;GPR[20]
        lwz         r21,context-&gt;GPR[21]
        lwz         r22,context-&gt;GPR[22]
        lwz         r23,context-&gt;GPR[23]
        lwz         r24,context-&gt;GPR[24]
        lwz         r25,context-&gt;GPR[25]
        lwz         r26,context-&gt;GPR[26]
        lwz         r27,context-&gt;GPR[27]
        lwz         r28,context-&gt;GPR[28]
        lwz         r29,context-&gt;GPR[29]
        lwz         r30,context-&gt;GPR[30]
        lwz         r31,context-&gt;GPR[31]
    #else
        lmw         r13,context-&gt;GPR[13]
    #endif
#else
        lmw         r13,context-&gt;GPR[13]
#endif

#ifndef _No_Floating_Point_Regs
        //  restore FP14-FP31
        lfd         fp14,context-&gt;FPR[14]
        lfd         fp15,context-&gt;FPR[15]
        lfd         fp16,context-&gt;FPR[16]
        lfd         fp17,context-&gt;FPR[17]
        lfd         fp18,context-&gt;FPR[18]
        lfd         fp19,context-&gt;FPR[19]
        lfd         fp20,context-&gt;FPR[20]
        lfd         fp21,context-&gt;FPR[21]
        lfd         fp22,context-&gt;FPR[22]
        lfd         fp23,context-&gt;FPR[23]
        lfd         fp24,context-&gt;FPR[24]
        lfd         fp25,context-&gt;FPR[25]
        lfd         fp26,context-&gt;FPR[26]
        lfd         fp27,context-&gt;FPR[27]
        lfd         fp28,context-&gt;FPR[28]
        lfd         fp29,context-&gt;FPR[29]
        lfd         fp30,context-&gt;FPR[30]
        lfd         fp31,context-&gt;FPR[31]
#endif


        mtlr        r8                      //  restore PC (LR)

#if __VEC__
        la          r5,context-&gt;vscr
        lvewx       vr0,r0,r5               // load 32 bits into lo 32 bits of v0
        mtvscr      vr0

        lwz         r5,context-&gt;vrsave      // restore vrsave, remove usage of bit 0
        mtvrsave    r5
#endif

        //  restore SP to stack top at throw: discards exception-handling frames
        //  but not exception temporaries
        lwz         SP,context-&gt;throwSP
        //  move stack frame back-link from catcher's linkage area to new top of
        //  stack; this effectively pops all intermediate frames.
        lwz         r3,context-&gt;SP
        lwz         r3,0(r3)
        stw         r3,0(SP)
        //  jump to exception handler
        blr
}

/************************************************************************/
/* Purpose..: Handle unexpected exception                               */
/* Input....: pointer to throw context                                  */
/* Input....: pointer to topmost MWExceptionInfo struct                 */
/* Input....: pointer to specification record                           */
/* Return...: ---                                                       */
/************************************************************************/
static void ExPPC_HandleUnexpected(ThrowContext *context,MWExceptionInfo *info,ex_specification *unexp)
{
    CatchInfo   *catchinfo;

#pragma exception_terminate     //  this will prevent exception exits during unwinding

    ExPPC_UnwindStack(context,info,unexp);  //  unwind stack to failing specification

    //  initialize catch info struct
    catchinfo=(CatchInfo *)(context-&gt;FP+unexp-&gt;cinfo_ref);
    catchinfo-&gt;location     = context-&gt;location;
    catchinfo-&gt;typeinfo     = context-&gt;throwtype;
    catchinfo-&gt;dtor         = context-&gt;dtor;
    catchinfo-&gt;stacktop     = unexp;        //  the __unexpected will never call __end_catch
                                            //  so we can resue this field
    //  jump to exception handler
    ExPPC_LongJump(context,info-&gt;TOC,info-&gt;current_function+unexp-&gt;pcoffset);
}

/************************************************************************/
/* Purpose..: Throw (rethrow) current exception                         */
/* Input....: pointer to throw context                                  */
/* Return...: ---                                                       */
/************************************************************************/
static void ExPPC_ThrowHandler(ThrowContext *context)
{
    ActionIterator  iter;
    MWExceptionInfo info;
    exaction_type   action;
    CatchInfo       *catchinfo;
    long            offset;

    //  find first ExceptionRecord

    ExPPC_FindExceptionRecord(context-&gt;returnaddr, &amp;info);
    if(info.exception_record==0) terminate();   //  cannot find matching exception record
    context-&gt;FP=(ET_GetHasFramePtr(info.exception_record-&gt;et_field))?(char *)context-&gt;GPR[31]:context-&gt;SP;

    if(context-&gt;throwtype==0)
    {   //  rethrow, find most recent exception
        iter.info       = info;
        iter.current_SP = context-&gt;SP;
        iter.current_FP = context-&gt;FP;
        iter.current_R31 = context-&gt;GPR[31];
        for(action=ExPPC_CurrentAction(&amp;iter);; action=ExPPC_NextAction(&amp;iter))
        {
            switch(action)
            {
            case EXACTION_ACTIVECATCHBLOCK:
                break;

            case EXACTION_ENDOFLIST:
            case EXACTION_DESTROYLOCAL:
            case EXACTION_DESTROYLOCALCOND:
            case EXACTION_DESTROYLOCALPOINTER:
            case EXACTION_DESTROYLOCALARRAY:
            case EXACTION_DESTROYBASE:
            case EXACTION_DESTROYMEMBER:
            case EXACTION_DESTROYMEMBERCOND:
            case EXACTION_DESTROYMEMBERARRAY:
            case EXACTION_DELETEPOINTER:
            case EXACTION_DELETEPOINTERCOND:
            case EXACTION_CATCHBLOCK:
            case EXACTION_CATCHBLOCK_32:
            case EXACTION_SPECIFICATION:
                continue;

            case EXACTION_TERMINATE:
            default:
                terminate();            //  cannot find find most recent exception
            }
            break;
        }
        catchinfo=(CatchInfo *)(iter.current_FP+((ex_activecatchblock *)iter.info.action_pointer)-&gt;cinfo_ref);
        context-&gt;throwtype  = (char *)catchinfo-&gt;typeinfo;
        context-&gt;location   = catchinfo-&gt;location;
        context-&gt;dtor       = 0;
        // original active catch block is still responsible for destruction
        context-&gt;catchinfo  = catchinfo;
    }
    else context-&gt;catchinfo=0L;

    //  find matching exception handler

    iter.info       = info;
    iter.current_SP = context-&gt;SP;
    iter.current_FP = context-&gt;FP;
    iter.current_R31 = context-&gt;GPR[31];
    for(action=ExPPC_CurrentAction(&amp;iter);; action=ExPPC_NextAction(&amp;iter))
    {
        switch(action)
        {
        case EXACTION_CATCHBLOCK_32:
            if(__throw_catch_compare(context-&gt;throwtype,((ex_catchblock_32 *)iter.info.action_pointer)-&gt;catch_type,&amp;offset))
            {
                break;
            }
            continue;
        case EXACTION_CATCHBLOCK:
            if(__throw_catch_compare(context-&gt;throwtype,((ex_catchblock *)iter.info.action_pointer)-&gt;catch_type,&amp;offset))
            {
                break;
            }
            continue;

        case EXACTION_SPECIFICATION:
            if(!ExPPC_IsInSpecification(context-&gt;throwtype,(ex_specification *)iter.info.action_pointer))
            {   //  unexpected specification
                ExPPC_HandleUnexpected(context,&amp;info,(ex_specification *)iter.info.action_pointer);
                //  we will never return from this function call
            }
            continue;

        case EXACTION_ENDOFLIST:
        case EXACTION_DESTROYLOCAL:
        case EXACTION_DESTROYLOCALCOND:
        case EXACTION_DESTROYLOCALPOINTER:
        case EXACTION_DESTROYLOCALARRAY:
        case EXACTION_DESTROYBASE:
        case EXACTION_DESTROYMEMBER:
        case EXACTION_DESTROYMEMBERCOND:
        case EXACTION_DESTROYMEMBERARRAY:
        case EXACTION_DELETEPOINTER:
        case EXACTION_DELETEPOINTERCOND:
        case EXACTION_ACTIVECATCHBLOCK:
            continue;

        case EXACTION_TERMINATE:
        default:
            terminate();            //  cannot find matching catch block
        }
        break;
    }

    //  we have found a matching catch block
    if (action == EXACTION_CATCHBLOCK_32) {
        ex_catchblock_32    *catchblock_32;
        catchblock_32=(ex_catchblock_32 *)iter.info.action_pointer;

        ExPPC_UnwindStack(context,&amp;info,catchblock_32);

        //  initialize catch info struct
        catchinfo=(CatchInfo *)(context-&gt;FP+catchblock_32-&gt;cinfo_ref);
        catchinfo-&gt;location     = context-&gt;location;
        catchinfo-&gt;typeinfo     = context-&gt;throwtype;
        catchinfo-&gt;dtor         = context-&gt;dtor;

        if(*context-&gt;throwtype=='*')
        {
            //  pointer match (create a pointer copy with adjusted offset)
            catchinfo-&gt;sublocation  = &amp;catchinfo-&gt;pointercopy;
            catchinfo-&gt;pointercopy  = *(long *)context-&gt;location+offset;
        }
        else
        {   //  traditional or class match (directly adjust offset)
            catchinfo-&gt;sublocation  = (char *)context-&gt;location+offset;
        }

        //  remember eventual stacktop (restored from catchinfo at end of catch block)
        //  catchinfo-&gt;stacktop = context-&gt;SP;  //  saved at try { ... } instead

        //  jump to exception handler
        ExPPC_LongJump(context,info.TOC,info.current_function+catchblock_32-&gt;catch_pcoffset);
    } else {
        ex_catchblock   *catchblock;

        catchblock=(ex_catchblock *)iter.info.action_pointer;
        ExPPC_UnwindStack(context,&amp;info,catchblock);

        //  initialize catch info struct
        catchinfo=(CatchInfo *)(context-&gt;FP+catchblock-&gt;cinfo_ref);
        catchinfo-&gt;location     = context-&gt;location;
        catchinfo-&gt;typeinfo     = context-&gt;throwtype;
        catchinfo-&gt;dtor         = context-&gt;dtor;
        if(*context-&gt;throwtype=='*')
        {   //  pointer match (create a pointer copy with adjusted offset)
            catchinfo-&gt;sublocation  = &amp;catchinfo-&gt;pointercopy;
            catchinfo-&gt;pointercopy  = *(long *)context-&gt;location+offset;
        }
        else
        {   //  traditional or class match (directly adjust offset)
            catchinfo-&gt;sublocation  = (char *)context-&gt;location+offset;
        }

        //  remember eventual stacktop (restored from catchinfo at end of catch block)
    //  catchinfo-&gt;stacktop = context-&gt;SP;  //  saved at try { ... } instead

        //  jump to exception handler
        ExPPC_LongJump(context,info.TOC,info.current_function+catchblock-&gt;catch_pcoffset);
    }
}


#if __VEC__
#pragma altivec_vrsave off

/************************************************************************/
/* Purpose..: Throw (rethrow) current exception                         */
/* Input....: pointer to throw type (0L: rethrow)                       */
/* Input....: pointer to complete throw object (0L: rethrow)            */
/* Input....: pointer to throw object destructor (0L: no destructor     */
/* Return...: ---                                                       */
/************************************************************************/
asm void __throw(char *throwtype, void *location, void *dtor)
{
        ThrowContext    throwcontext;

        nofralloc                       // user is responsible for stack frame

//
// PROLOGUE
//
        mflr        r0
        mr          r11,r30             // save high 2 nonvolatiles in r11 and r12
        stw         r31,-4(sp)
        mr          r12,r31
        stw         r30,-8(sp)
        stw         r0,8(sp)
        stw         r3,24(sp)
        stw         r4,28(sp)

        mr          r30,sp              // save callerSP in r30
        stw         r5,32(sp)

        clrrwi      sp,sp,4             // clear the right 4 bits to 16-byte align new frame

                                        // frame size calculated by:
                                        // sizeof(ThrowContext) 
                                        // + 24 bytes for linkage area 
                                        // + 8 for 16-byte alignment
                                        // + 32 for parameter area size

        stwu        r30,-(sizeof(ThrowContext) + 32 + 24 + 8) (SP)

//
// MAIN FUNCTION BODY
//
        addi        r31,sp,64           // offset of throwcontext calculated by:
                                        // SP + 24 bytes for linkage area + 8 for 16-byte alignment
                                        //    + 32 for parameter area size


        stmw        r13,ThrowContext.GPR[13](r31)
        stw         r11,ThrowContext.GPR[30](r31)   // restore register state as it was on entry to this routine
        stw         r12,ThrowContext.GPR[31](r31)

        mfvrsave    r5
        stw         r5,ThrowContext.vrsave(r31)

        bl          __setLR             // set LR to address of setLR               
__setLR:    

        stw         r5,ThrowContext.vrsave(r31)
        clrlwi      r5,r5,20            // clear left 20 bits
        cntlzw      r5,r5               // find first nonvolatile VR used
        slwi        r5,r5,3             // multiply by 8 for index past __setjmpv20
        mflr        r4

        addi        r4,r4,__setjmpv20 - __setLR - (20 * 8)
        add         r4,r4,r5
        mtlr        r4

        blr                             // jump to index past __setjmpv20

__setjmpv20:        
        li          r3,ThrowContext.VR[20]
        stvx        vr20,r3,r31
        li          r3,ThrowContext.VR[21]
        stvx        vr21,r3,r31
        li          r3,ThrowContext.VR[22]
        stvx        vr22,r3,r31
        li          r3,ThrowContext.VR[23]
        stvx        vr23,r3,r31
        li          r3,ThrowContext.VR[24]
        stvx        vr24,r3,r31
        li          r3,ThrowContext.VR[25]
        stvx        vr25,r3,r31
        li          r3,ThrowContext.VR[26]
        stvx        vr26,r3,r31
        li          r3,ThrowContext.VR[27]
        stvx        vr27,r3,r31
        li          r3,ThrowContext.VR[28]
        stvx        vr28,r3,r31
        li          r3,ThrowContext.VR[29]
        stvx        vr29,r3,r31
        li          r3,ThrowContext.VR[30]
        stvx        vr30,r3,r31
        li          r3,ThrowContext.VR[31]
        stvx        vr31,r3,r31

        mfvrsave    r6
        oris        r6,r6,0x8000        // indicate vr0 in-use
        mtvrsave    r6

        mfvscr      vr0                 // mfvscr is context-synchronizing, so this will take many cycles
        la          r5,ThrowContext.vscr(r31)
        stvewx      vr0,r0,r5           // store 32 bits out of lo 32 bits of v0

        li          r5,0x0000           // indicate that no vector registers are being used now
        mtvrsave    r5                  // This is OK because we just saved the non-volatile set and exercised our right
                                        // to trash all the volatile vector registers


        //  save FPRs so we can restore them during stack unwind
#ifndef _No_Floating_Point_Regs
        stfd        fp14,ThrowContext.FPR[14](r31)
        stfd        fp15,ThrowContext.FPR[15](r31)
        stfd        fp16,ThrowContext.FPR[16](r31)
        stfd        fp17,ThrowContext.FPR[17](r31)
        stfd        fp18,ThrowContext.FPR[18](r31)
        stfd        fp19,ThrowContext.FPR[19](r31)
        stfd        fp20,ThrowContext.FPR[20](r31)
        stfd        fp21,ThrowContext.FPR[21](r31)
        stfd        fp22,ThrowContext.FPR[22](r31)
        stfd        fp23,ThrowContext.FPR[23](r31)
        stfd        fp24,ThrowContext.FPR[24](r31)
        stfd        fp25,ThrowContext.FPR[25](r31)
        stfd        fp26,ThrowContext.FPR[26](r31)
        stfd        fp27,ThrowContext.FPR[27](r31)
        stfd        fp28,ThrowContext.FPR[28](r31)
        stfd        fp29,ThrowContext.FPR[29](r31)
        stfd        fp30,ThrowContext.FPR[30](r31)
        stfd        fp31,ThrowContext.FPR[31](r31)
#endif
        //  save CR so we can restore it during stack unwind
        mfcr        r3
        stw         r3,ThrowContext.CR(r31);
        //  tcp-&gt;SP = tcp-&gt;throwSP = &lt;stack pointer of caller&gt;;
        //  tcp-&gt;returnaddr = &lt;return address into caller&gt;;
        lwz         r3,0(sp)
        lwz         r4,8(r3)
        stw         r3,ThrowContext.SP(r31);
        stw         r3,ThrowContext.throwSP(r31);
        stw         r4,ThrowContext.returnaddr(r31);
        //  tcp-&gt;throwtype = throwtype;
        lwz         r3,throwtype(r30)   // using callerSP
        stw         r3,ThrowContext.throwtype(r31)
        //  tcp-&gt;location = location;
        lwz         r3,location(r30)    // using callerSP
        stw         r3,ThrowContext.location(r31)
        //  tcp-&gt;dtor = dtor;
        lwz         r3,dtor(r30)        // using callerSP
        stw         r3,ThrowContext.dtor(r31)
        //  call __ex_throwhandler(&amp;throwcontext);

        mr          r3,r31
        bl          ExPPC_ThrowHandler
        nop

//
// EPILOGUE
//      
        lwz         r0,8(r30)           // fetch old LR from linkage area
        mr          sp,r30              // restore caller's SP from nonvolatile r30
        mtlr        r0                  // restore LR so we can return
        lwz         r31,-4(sp)          // restore nonvolatile r30 and r31 callerSP-relative
        lwz         r30,-8(sp)
        blr
}

#pragma debug_listing  off
#pragma altivec_vrsave on

#else

/************************************************************************/
/* Purpose..: Throw (rethrow) current exception                         */
/* Input....: pointer to throw type (0L: rethrow)                       */
/* Input....: pointer to complete throw object (0L: rethrow)            */
/* Input....: pointer to throw object destructor (0L: no destructor     */
/* Return...: ---                                                       */
/************************************************************************/
asm void __throw(char *throwtype, void *location, void *dtor)
{
        ThrowContext throwcontext;

        //  allocate a stack frame so we can use symbolic access to locals
        fralloc

        //  save GPRs so we can restore them during stack unwind
#if __PPC_EABI__
    #if !__option(use_lmw_stmw)
        stw         r14,throwcontext.GPR[14]
        stw         r15,throwcontext.GPR[15]
        stw         r16,throwcontext.GPR[16]
        stw         r17,throwcontext.GPR[17]
        stw         r18,throwcontext.GPR[18]
        stw         r19,throwcontext.GPR[19]
        stw         r20,throwcontext.GPR[20]
        stw         r21,throwcontext.GPR[21]
        stw         r22,throwcontext.GPR[22]
        stw         r23,throwcontext.GPR[23]
        stw         r24,throwcontext.GPR[24]
        stw         r25,throwcontext.GPR[25]
        stw         r26,throwcontext.GPR[26]
        stw         r27,throwcontext.GPR[27]
        stw         r28,throwcontext.GPR[28]
        stw         r29,throwcontext.GPR[29]
        stw         r30,throwcontext.GPR[30]
        stw         r31,throwcontext.GPR[31]
    #else
        stmw        r13,throwcontext.GPR[13]
    #endif
#else
        stmw        r13,throwcontext.GPR[13]
#endif

#ifndef _No_Floating_Point_Regs
        //  save FPRs so we can restore them during stack unwind
        stfd        fp14,throwcontext.FPR[14]
        stfd        fp15,throwcontext.FPR[15]
        stfd        fp16,throwcontext.FPR[16]
        stfd        fp17,throwcontext.FPR[17]
        stfd        fp18,throwcontext.FPR[18]
        stfd        fp19,throwcontext.FPR[19]
        stfd        fp20,throwcontext.FPR[20]
        stfd        fp21,throwcontext.FPR[21]
        stfd        fp22,throwcontext.FPR[22]
        stfd        fp23,throwcontext.FPR[23]
        stfd        fp24,throwcontext.FPR[24]
        stfd        fp25,throwcontext.FPR[25]
        stfd        fp26,throwcontext.FPR[26]
        stfd        fp27,throwcontext.FPR[27]
        stfd        fp28,throwcontext.FPR[28]
        stfd        fp29,throwcontext.FPR[29]
        stfd        fp30,throwcontext.FPR[30]
        stfd        fp31,throwcontext.FPR[31]
#endif

        //  save CR so we can restore it during stack unwind
        mfcr        r3
        stw         r3,throwcontext.CR;
        //  throwcontext.SP = throwcontext.throwSP = &lt;stack pointer of caller&gt;;
        //  throwcontext.returnaddr = &lt;return address into caller&gt;;
        lwz         r3,0(sp)
        lwz         r4,RETURN_ADDRESS(r3)
        stw         r3,throwcontext.SP;
        stw         r3,throwcontext.throwSP;
        stw         r4,throwcontext.returnaddr;
        //  throwcontext.throwtype = throwtype;
        lwz         r3,throwtype
        stw         r3,throwcontext.throwtype
        //  throwcontext.location = location;
        lwz         r3,location
        stw         r3,throwcontext.location
        //  throwcontext.dtor = dtor;
        lwz         r3,dtor
        stw         r3,throwcontext.dtor
        //  call __ex_throwhandler(&amp;throwcontext);

        la          r3,throwcontext
        bl          ExPPC_ThrowHandler
        nop
        //  (will never get here)
        frfree
        blr
}

#endif


/************************************************************************/
/* Purpose..: Deinitialize CatchInfo struct                             */
/* Input....: pointer to catchinfo struct                               */
/* Return...: ---                                                       */
/************************************************************************/
void __end__catch(CatchInfo *catchinfo)
{
    if (catchinfo-&gt;location &amp;&amp; catchinfo-&gt;dtor)
        DTORCALL_COMPLETE(catchinfo-&gt;dtor,catchinfo-&gt;location);
}

</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>