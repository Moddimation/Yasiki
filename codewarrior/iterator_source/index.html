<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File iterator - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-iterator">File iterator</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_1d8bcf55c9e1564519df8a05b1def2d1/"><strong>MSL_C++</strong></a> <strong>&gt;</strong> <a href="../dir_fc42de24ef3c14a5dea3aca327bd2ec9/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_f262df31fb8e04d575b9a3aa2e30ecf8/"><strong>Include</strong></a> <strong>&gt;</strong> <a href="../iterator/"><strong>iterator</strong></a></p>
<p><a href="../iterator/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/12/09 17:58:50 $ 
 *  $Revision: 1.13.4.1 $ 
 *  $NoKeywords: $ 
 *
 *      Portions Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/**
 **  iterator
 **/

#ifndef _ITERATOR
#define _ITERATOR

#include &lt;mslconfig&gt;

#include &lt;cstddef&gt;
#include &lt;iosfwd&gt;

#ifndef RC_INVOKED

#pragma options align=native
#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
    namespace std {
#endif

//  lib.iterator.primitives, primitives:

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: public input_iterator_tag {};
struct bidirectional_iterator_tag: public forward_iterator_tag {};
struct random_access_iterator_tag: public bidirectional_iterator_tag {};

template&lt;class Iterator&gt;
struct iterator_traits
{
    typedef typename Iterator::difference_type   difference_type;
    typedef typename Iterator::value_type        value_type;
    typedef typename Iterator::pointer           pointer;
    typedef typename Iterator::reference         reference;
    typedef typename Iterator::iterator_category iterator_category;
};

#ifndef _MSL_NO_PARTIAL_SPECIALIZATION

    template&lt;class T&gt;
    struct iterator_traits&lt;T*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef T                          value_type;
        typedef T*                         pointer;
        typedef T&amp;                         reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;class T&gt;
    struct iterator_traits&lt;const T*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef T                          value_type;
        typedef const T*                   pointer;
        typedef const T&amp;                   reference;
        typedef random_access_iterator_tag iterator_category;
    };

    #define __MSL_FIX_ITERATORS__(myType)

#else  // _MSL_NO_PARTIAL_SPECIALIZATION

    #ifndef _MSL_NO_BOOL

        template&lt;&gt;
        struct iterator_traits&lt;bool*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef bool                       value_type;
            typedef bool*                      pointer;
            typedef bool&amp;                      reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;const bool*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef bool                       value_type;
            typedef const bool*                pointer;
            typedef const bool&amp;                reference;
            typedef random_access_iterator_tag iterator_category;
        };

    #endif

    template&lt;&gt;
    struct iterator_traits&lt;char*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef char                       value_type;
        typedef char*                      pointer;
        typedef char&amp;                      reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const char*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef char                       value_type;
        typedef const char*                pointer;
        typedef const char&amp;                reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;signed char*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef signed char                value_type;
        typedef signed char*               pointer;
        typedef signed char&amp;               reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const signed char*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef signed char                value_type;
        typedef const signed char*         pointer;
        typedef const signed char&amp;         reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;unsigned char*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef unsigned char              value_type;
        typedef unsigned char*             pointer;
        typedef unsigned char&amp;             reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const unsigned char*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef unsigned char              value_type;
        typedef const unsigned char*       pointer;
        typedef const unsigned char&amp;       reference;
        typedef random_access_iterator_tag iterator_category;
    };

    #ifndef _MSL_NO_WCHART

        template&lt;&gt;
        struct iterator_traits&lt;wchar_t*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef wchar_t                    value_type;
            typedef wchar_t*                   pointer;
            typedef wchar_t&amp;                   reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;const wchar_t*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef wchar_t                    value_type;
            typedef const wchar_t*             pointer;
            typedef const wchar_t&amp;             reference;
            typedef random_access_iterator_tag iterator_category;
        };

    #endif

    template&lt;&gt;
    struct iterator_traits&lt;short*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef short                      value_type;
        typedef short*                     pointer;
        typedef short&amp;                     reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const short*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef short                      value_type;
        typedef const short*               pointer;
        typedef const short&amp;               reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;unsigned short*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef unsigned short             value_type;
        typedef unsigned short*            pointer;
        typedef unsigned short&amp;            reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const unsigned short*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef unsigned short             value_type;
        typedef const unsigned short*      pointer;
        typedef const unsigned short&amp;      reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;int*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef int                        value_type;
        typedef int*                       pointer;
        typedef int&amp;                       reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const int*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef int                        value_type;
        typedef const int*                 pointer;
        typedef const int&amp;                 reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;unsigned int*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef unsigned int               value_type;
        typedef unsigned int*              pointer;
        typedef unsigned int&amp;              reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const unsigned int*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef unsigned int               value_type;
        typedef const unsigned int*        pointer;
        typedef const unsigned int&amp;        reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;long*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef long                       value_type;
        typedef long*                      pointer;
        typedef long&amp;                      reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const long*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef long                       value_type;
        typedef const long*                pointer;
        typedef const long&amp;                reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;unsigned long*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef unsigned long              value_type;
        typedef unsigned long*             pointer;
        typedef unsigned long&amp;             reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template&lt;&gt;
    struct iterator_traits&lt;const unsigned long*&gt;
    {
        typedef ptrdiff_t                  difference_type;
        typedef unsigned long              value_type;
        typedef const unsigned long*       pointer;
        typedef const unsigned long&amp;       reference;
        typedef random_access_iterator_tag iterator_category;
    };

    #ifdef __MSL_LONGLONG_SUPPORT__

        template&lt;&gt;
        struct iterator_traits&lt;long long*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef long long                  value_type;
            typedef long long*                 pointer;
            typedef long long&amp;                 reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;const long long*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef long long                  value_type;
            typedef const long long*           pointer;
            typedef const long long&amp;           reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;unsigned long long*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef unsigned long long         value_type;
            typedef unsigned long long*        pointer;
            typedef unsigned long long&amp;        reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;const unsigned long long*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef unsigned long long         value_type;
            typedef const unsigned long long*  pointer;
            typedef const unsigned long long&amp;  reference;
            typedef random_access_iterator_tag iterator_category;
        };

    #endif  // __MSL_LONGLONG_SUPPORT__

    #ifndef _No_Floating_Point

        template&lt;&gt;
        struct iterator_traits&lt;float*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef float                      value_type;
            typedef float*                     pointer;
            typedef float&amp;                     reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;const float*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef float                      value_type;
            typedef const float*               pointer;
            typedef const float&amp;               reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;double*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef double                     value_type;
            typedef double*                    pointer;
            typedef double&amp;                    reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;const double*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef double                     value_type;
            typedef const double*              pointer;
            typedef const double&amp;              reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;long double*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef long double                value_type;
            typedef long double*               pointer;
            typedef long double&amp;               reference;
            typedef random_access_iterator_tag iterator_category;
        };

        template&lt;&gt;
        struct iterator_traits&lt;const long double*&gt;
        {
            typedef ptrdiff_t                  difference_type;
            typedef long double                value_type;
            typedef const long double*         pointer;
            typedef const long double&amp;         reference;
            typedef random_access_iterator_tag iterator_category;
        };

    #endif  // _No_Floating_Point

    //970415 bkoz via Dennis C. De Mars
    #define __MSL_FIX_ITERATORS__(myType)                     \
    template &lt;&gt;                                               \
    struct _STD::iterator_traits &lt;myType*&gt;                    \
    {                                                         \
        typedef ptrdiff_t                  difference_type;   \
        typedef myType                     value_type;        \
        typedef myType*                    pointer;           \
        typedef myType&amp;                    reference;         \
        typedef random_access_iterator_tag iterator_category; \
    };

#endif  // _MSL_NO_PARTIAL_SPECIALIZATION

template&lt;class Category, class T, class Distance = ptrdiff_t,
    class Pointer = T*, class Reference = T&amp;&gt;
struct iterator
{
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
    typedef Category  iterator_category;
};

//  lib.iterator.operations, iterator operations:

// advance

template &lt;class InputIterator, class Distance&gt;
inline
void
__advance(InputIterator&amp; i, Distance n, input_iterator_tag)
{
    for (; n &gt; 0; --n)
        ++i;
}

template &lt;class BidirectionalIterator, class Distance&gt;
inline
void
__advance(BidirectionalIterator&amp; i, Distance n, bidirectional_iterator_tag)
{
    if (n &gt;= 0)
        for (; n &gt; 0; --n)
            ++i;
    else
        for (; n &lt; 0; ++n)
            --i;
}

template &lt;class RandomAccessIterator, class Distance&gt;
inline
void
__advance(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag)
{
    i += n;
}

template &lt;class InputIterator, class Distance&gt;
inline
void
advance(InputIterator&amp; i, Distance n)
{
    __advance(i, n, iterator_traits&lt;InputIterator&gt;::iterator_category());
}

// distance

template &lt;class InputIterator&gt;
inline
typename iterator_traits&lt;InputIterator&gt;::difference_type
__distance(InputIterator first, InputIterator last, input_iterator_tag)
{
    typename iterator_traits&lt;InputIterator&gt;::difference_type result = 0;
    for (; first != last; ++first)
        ++result;
    return result;
}

template &lt;class RandomAccessIterator&gt;
inline
typename iterator_traits&lt;RandomAccessIterator&gt;::difference_type
__distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)
{
    return last - first;
}

template &lt;class InputIterator&gt;
inline
typename iterator_traits&lt;InputIterator&gt;::difference_type
distance(InputIterator first, InputIterator last)
{
    return __distance(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
}

//  lib.predef.iterators, predefined iterators:

// reverse_iterator

template &lt;class Iterator&gt;
class reverse_iterator
    : public iterator&lt;typename iterator_traits&lt;Iterator&gt;::iterator_category,
                      typename iterator_traits&lt;Iterator&gt;::value_type,
                      typename iterator_traits&lt;Iterator&gt;::difference_type,
                      typename iterator_traits&lt;Iterator&gt;::pointer,
                      typename iterator_traits&lt;Iterator&gt;::reference&gt;
{
protected:
    Iterator current;
public:
    typedef Iterator                                            iterator_type;
    typedef typename iterator_traits&lt;Iterator&gt;::difference_type difference_type;
    typedef typename iterator_traits&lt;Iterator&gt;::reference       reference;
    typedef typename iterator_traits&lt;Iterator&gt;::pointer         pointer;

    reverse_iterator();
    explicit reverse_iterator(Iterator x);
#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE
    template &lt;class U&gt; reverse_iterator(const reverse_iterator&lt;U&gt;&amp; u);
#else
    template &lt;class U&gt;
    inline
    reverse_iterator(const reverse_iterator&lt;U&gt;&amp; u)
        : current(u.base())
    {
    }
#endif
#endif

    Iterator base() const;      //  explicit
    reference operator*() const;
    pointer   operator-&gt;() const;

    reverse_iterator&amp; operator++();
    reverse_iterator  operator++(int);
    reverse_iterator&amp; operator--();
    reverse_iterator  operator--(int);

    reverse_iterator  operator+ (difference_type n) const;
    reverse_iterator&amp; operator+=(difference_type n);
    reverse_iterator  operator- (difference_type n) const;
    reverse_iterator&amp; operator-=(difference_type n);
    reference operator[](difference_type n) const;
};

template &lt;class BidirectionalIterator&gt;
inline
reverse_iterator&lt;BidirectionalIterator&gt;::reverse_iterator()
{
}

template &lt;class BidirectionalIterator&gt;
inline
reverse_iterator&lt;BidirectionalIterator&gt;::reverse_iterator(BidirectionalIterator x)
    : current(x)
{
}

#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE
    template &lt;class BidirectionalIterator&gt;
    template &lt;class U&gt;
    inline
    reverse_iterator&lt;BidirectionalIterator&gt;::reverse_iterator(const reverse_iterator&lt;U&gt;&amp; u)
        : current(u.base())
    {
    }
#endif
#endif

template &lt;class BidirectionalIterator&gt;
inline
BidirectionalIterator
reverse_iterator&lt;BidirectionalIterator&gt;::base() const
{
    return current;
}

template &lt;class BidirectionalIterator&gt;
inline
typename reverse_iterator&lt;BidirectionalIterator&gt;::reference
reverse_iterator&lt;BidirectionalIterator&gt;::operator*() const
{
    BidirectionalIterator tmp = current;
    return *--tmp;
}

template &lt;class BidirectionalIterator&gt;
inline
typename reverse_iterator&lt;BidirectionalIterator&gt;::pointer
reverse_iterator&lt;BidirectionalIterator&gt;::operator-&gt;() const
{
    return &amp;(operator*());
}

template &lt;class BidirectionalIterator&gt;
inline
reverse_iterator&lt;BidirectionalIterator&gt;&amp;
reverse_iterator&lt;BidirectionalIterator&gt;::operator++()
{
    --current;
    return *this;
}

template &lt;class BidirectionalIterator&gt;
inline
reverse_iterator&lt;BidirectionalIterator&gt;
reverse_iterator&lt;BidirectionalIterator&gt;::operator++(int)
{
    reverse_iterator tmp = *this;
    --current;
    return tmp;
}

template &lt;class BidirectionalIterator&gt;
inline
reverse_iterator&lt;BidirectionalIterator&gt;&amp;
reverse_iterator&lt;BidirectionalIterator&gt;::operator--()
{
    ++current;
    return *this;
}

template &lt;class BidirectionalIterator&gt;
inline
reverse_iterator&lt;BidirectionalIterator&gt;
reverse_iterator&lt;BidirectionalIterator&gt;::operator--(int)
{
    reverse_iterator tmp = *this;
    ++current;
    return tmp;
}

template &lt;class RandomAccessIterator&gt;
inline
reverse_iterator&lt;RandomAccessIterator&gt;
reverse_iterator&lt;RandomAccessIterator&gt;::operator+ (difference_type n) const
{
    return reverse_iterator(current - n);
}

template &lt;class RandomAccessIterator&gt;
inline
reverse_iterator&lt;RandomAccessIterator&gt;
reverse_iterator&lt;RandomAccessIterator&gt;::operator- (difference_type n) const
{
    return reverse_iterator(current + n);
}

template &lt;class RandomAccessIterator&gt;
inline
reverse_iterator&lt;RandomAccessIterator&gt;&amp;
reverse_iterator&lt;RandomAccessIterator&gt;::operator+=(difference_type n)
{
    current -= n;
    return *this;
}

template &lt;class RandomAccessIterator&gt;
inline
reverse_iterator&lt;RandomAccessIterator&gt;&amp;
reverse_iterator&lt;RandomAccessIterator&gt;::operator-=(difference_type n)
{
    current += n;
    return *this;
}

template &lt;class RandomAccessIterator&gt;
inline
typename reverse_iterator&lt;RandomAccessIterator&gt;::reference
reverse_iterator&lt;RandomAccessIterator&gt;::operator[](difference_type n) const
{
    return current[-n-1];
}

template &lt;class BidirectionalIterator&gt;
inline
bool
operator==(const reverse_iterator&lt;BidirectionalIterator&gt;&amp; x,
           const reverse_iterator&lt;BidirectionalIterator&gt;&amp; y)
{
    return static_cast&lt;bool&gt;(x.base() == y.base());
}

template &lt;class RandomAccessIterator&gt;
inline
bool
operator&lt; (const reverse_iterator&lt;RandomAccessIterator&gt;&amp; x,
           const reverse_iterator&lt;RandomAccessIterator&gt;&amp; y)
{
    return static_cast&lt;bool&gt;(x.base() &gt; y.base());
}

template &lt;class BidirectionalIterator&gt;
inline
bool
operator!=(const reverse_iterator&lt;BidirectionalIterator&gt;&amp; x,
           const reverse_iterator&lt;BidirectionalIterator&gt;&amp; y)
{
    return static_cast&lt;bool&gt;(x.base() != y.base());
}

template &lt;class RandomAccessIterator&gt;
inline
bool
operator&gt; (const reverse_iterator&lt;RandomAccessIterator&gt;&amp; x,
           const reverse_iterator&lt;RandomAccessIterator&gt;&amp; y)
{
    return static_cast&lt;bool&gt;(x.base() &lt; y.base());
}

template &lt;class RandomAccessIterator&gt;
inline
bool
operator&gt;=(const reverse_iterator&lt;RandomAccessIterator&gt;&amp; x,
           const reverse_iterator&lt;RandomAccessIterator&gt;&amp; y)
{
    return static_cast&lt;bool&gt;(x.base() &lt;= y.base());
}

template &lt;class RandomAccessIterator&gt;
bool
operator&lt;=(const reverse_iterator&lt;RandomAccessIterator&gt;&amp; x,
           const reverse_iterator&lt;RandomAccessIterator&gt;&amp; y)
{
    return static_cast&lt;bool&gt;(x.base() &gt;= y.base());
}

template &lt;class RandomAccessIterator&gt;
inline
typename reverse_iterator&lt;RandomAccessIterator&gt;::difference_type
operator-(const reverse_iterator&lt;RandomAccessIterator&gt;&amp; x,
          const reverse_iterator&lt;RandomAccessIterator&gt;&amp; y)
{
    return y.base() - x.base();
}

template &lt;class RandomAccessIterator&gt;
reverse_iterator&lt;RandomAccessIterator&gt;
operator+(typename reverse_iterator&lt;RandomAccessIterator&gt;::difference_type n,
          const reverse_iterator&lt;RandomAccessIterator&gt;&amp; x)
{
    return reverse_iterator&lt;RandomAccessIterator&gt;(x.base() - n);
}

// back_insert_iterator

template &lt;class Container&gt;
class back_insert_iterator
    : public iterator&lt;output_iterator_tag, void, void, void, void&gt;
{
protected:
    Container* container;

public:
    typedef Container container_type;
    explicit back_insert_iterator(Container&amp; x);
    back_insert_iterator&amp; operator=(typename Container::const_reference value);

    back_insert_iterator&amp; operator*();
    back_insert_iterator&amp; operator++();
    back_insert_iterator&amp; operator++(int);
};

template &lt;class Container&gt;
inline
back_insert_iterator&lt;Container&gt;::back_insert_iterator(Container&amp; x)
    : container(&amp;x)
{
}

template &lt;class Container&gt;
inline
back_insert_iterator&lt;Container&gt;&amp;
back_insert_iterator&lt;Container&gt;::operator=(typename Container::const_reference value)
{
    container-&gt;push_back(value);
    return *this;
}

template &lt;class Container&gt;
inline
back_insert_iterator&lt;Container&gt;&amp;
back_insert_iterator&lt;Container&gt;::operator*()
{
    return *this;
}

template &lt;class Container&gt;
inline
back_insert_iterator&lt;Container&gt;&amp;
back_insert_iterator&lt;Container&gt;::operator++()
{
    return *this;
}

template &lt;class Container&gt;
inline
back_insert_iterator&lt;Container&gt;&amp;
back_insert_iterator&lt;Container&gt;::operator++(int)
{
    return *this;
}

template &lt;class Container&gt;
inline
back_insert_iterator&lt;Container&gt;
back_inserter(Container&amp; x)
{
    return back_insert_iterator&lt;Container&gt;(x);
}

// front_insert_iterator

template &lt;class Container&gt;
class front_insert_iterator
    : public iterator&lt;output_iterator_tag, void, void, void, void&gt;
{
protected:
    Container* container;

public:
    typedef Container container_type;
    explicit front_insert_iterator(Container&amp; x);
    front_insert_iterator&amp; operator=(typename Container::const_reference value);

    front_insert_iterator&amp; operator*();
    front_insert_iterator&amp; operator++();
    front_insert_iterator&amp; operator++(int);
};

template &lt;class Container&gt;
inline
front_insert_iterator&lt;Container&gt;::front_insert_iterator(Container&amp; x)
    : container(&amp;x)
{
}

template &lt;class Container&gt;
inline
front_insert_iterator&lt;Container&gt;&amp;
front_insert_iterator&lt;Container&gt;::operator=(typename Container::const_reference value)
{
    container-&gt;push_front(value);
    return *this;
}

template &lt;class Container&gt;
inline
front_insert_iterator&lt;Container&gt;&amp;
front_insert_iterator&lt;Container&gt;::operator*()
{
    return *this;
}

template &lt;class Container&gt;
inline
front_insert_iterator&lt;Container&gt;&amp;
front_insert_iterator&lt;Container&gt;::operator++()
{
    return *this;
}

template &lt;class Container&gt;
inline
front_insert_iterator&lt;Container&gt;&amp;
front_insert_iterator&lt;Container&gt;::operator++(int)
{
    return *this;
}

template &lt;class Container&gt;
inline
front_insert_iterator&lt;Container&gt;
front_inserter(Container&amp; x)
{
    return front_insert_iterator&lt;Container&gt;(x);
}

// insert_iterator

template &lt;class Container&gt;
class insert_iterator
    : public iterator&lt;output_iterator_tag, void, void, void, void&gt;
{
protected:
    Container* container;
    typename Container::iterator iter;

public:
    typedef Container container_type;
    insert_iterator(Container&amp; x, typename Container::iterator i);
    insert_iterator&amp; operator=(typename Container::const_reference value);

    insert_iterator&amp; operator*();
    insert_iterator&amp; operator++();
    insert_iterator&amp; operator++(int);
};

template &lt;class Container&gt;
inline
insert_iterator&lt;Container&gt;::insert_iterator(Container&amp; x, typename Container::iterator i)
    : container(&amp;x),
      iter(i)
{
}

template &lt;class Container&gt;
inline
insert_iterator&lt;Container&gt;&amp;
insert_iterator&lt;Container&gt;::operator=(typename Container::const_reference value)
{
    iter = container-&gt;insert(iter, value);
    ++iter;
    return *this;
}

template &lt;class Container&gt;
inline
insert_iterator&lt;Container&gt;&amp;
insert_iterator&lt;Container&gt;::operator*()
{
    return *this;
}

template &lt;class Container&gt;
inline
insert_iterator&lt;Container&gt;&amp;
insert_iterator&lt;Container&gt;::operator++()
{
    return *this;
}

template &lt;class Container&gt;
inline
insert_iterator&lt;Container&gt;&amp;
insert_iterator&lt;Container&gt;::operator++(int)
{
    return *this;
}

#if !defined(__MWERKS__) || (defined(__MWERKS__) &amp;&amp; __MWERKS__ &gt; 0x2400)

    template &lt;class Container, class Iterator&gt;
    inline
    insert_iterator&lt;Container&gt;
    inserter(Container&amp; x, Iterator i)
    {
        return insert_iterator&lt;Container&gt;(x, typename Container::iterator(i));
    }

#else

    template &lt;class Container, class Iterator&gt;
    inline
    insert_iterator&lt;Container&gt;
    inserter(Container&amp; x, Iterator i)
    {
        return insert_iterator&lt;Container&gt;(x, Container::iterator(i));
    }

#endif

#ifndef _MSL_NO_IO

//  lib.stream.iterators, stream iterators:

// istream_iterator

template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;, class Distance = ptrdiff_t&gt;
class istream_iterator
    : public iterator&lt;input_iterator_tag, T, Distance, const T*, const T&amp;&gt;
{
public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_istream&lt;charT, traits&gt; istream_type;
    istream_iterator();
    istream_iterator(istream_type&amp; s);

    const T&amp; operator*() const;
    const T* operator-&gt;() const;
    istream_iterator&amp; operator++();
    istream_iterator  operator++(int);
private:
    basic_istream&lt;charT, traits&gt;* in_stream_;
    T value_;

    friend bool operator== &lt;T, charT, traits, Distance&gt;(const istream_iterator&amp; x,
                                                        const istream_iterator&amp; y);
    friend bool operator!= &lt;T, charT, traits, Distance&gt;(const istream_iterator&amp; x,
                                                        const istream_iterator&amp; y);
};

template &lt;class T, class charT, class traits, class Distance&gt;
inline
istream_iterator&lt;T, charT, traits, Distance&gt;::istream_iterator()
    : in_stream_(0)
{
}

template &lt;class T, class charT, class traits, class Distance&gt;
inline
istream_iterator&lt;T, charT, traits, Distance&gt;::istream_iterator(istream_type&amp; s)
    : in_stream_(&amp;s)
{
    if (!(*in_stream_ &gt;&gt; value_))
        in_stream_ = 0;
}

template &lt;class T, class charT, class traits, class Distance&gt;
inline
const T&amp;
istream_iterator&lt;T, charT, traits, Distance&gt;::operator*() const
{
    return value_;
}

template &lt;class T, class charT, class traits, class Distance&gt;
inline
const T*
istream_iterator&lt;T, charT, traits, Distance&gt;::operator-&gt;() const
{
    return &amp;value_;
}

template &lt;class T, class charT, class traits, class Distance&gt;
inline
istream_iterator&lt;T, charT, traits, Distance&gt;&amp;
istream_iterator&lt;T, charT, traits, Distance&gt;::operator++()
{
    if (!(*in_stream_ &gt;&gt; value_))
        in_stream_ = 0;
    return *this;
}

template &lt;class T, class charT, class traits, class Distance&gt;
inline
istream_iterator&lt;T, charT, traits, Distance&gt;
istream_iterator&lt;T, charT, traits, Distance&gt;::operator++(int)
{
    istream_iterator tmp(*this);
    operator++();
    return tmp;
}

template &lt;class T, class charT, class traits, class Distance&gt;
inline
bool
operator==(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
           const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y)
{
    return static_cast&lt;bool&gt;(x.in_stream_ == y.in_stream_);
}

template &lt;class T, class charT, class traits, class Distance&gt;
inline
bool
operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
           const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y)
{
    return static_cast&lt;bool&gt;(x.in_stream_ != y.in_stream_);
}

// ostream_iterator

template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt; &gt;
class ostream_iterator
    : public iterator&lt;output_iterator_tag, void, void, void, void&gt;
{
public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream&lt;charT,traits&gt; ostream_type;
    ostream_iterator(ostream_type&amp; s);
    ostream_iterator(ostream_type&amp; s, const charT* delimiter);
    ostream_iterator&amp; operator=(const T&amp; value);

    ostream_iterator&amp; operator*();
    ostream_iterator&amp; operator++();
    ostream_iterator&amp; operator++(int);
private:
    basic_ostream&lt;charT,traits&gt;* out_stream_;
    const charT* delim_;
};

template &lt;class T, class charT, class traits&gt;
inline
ostream_iterator&lt;T, charT, traits&gt;::ostream_iterator(ostream_type&amp; s)
    : out_stream_(&amp;s),
      delim_(0)
{
}

template &lt;class T, class charT, class traits&gt;
inline
ostream_iterator&lt;T, charT, traits&gt;::ostream_iterator(ostream_type&amp; s, const charT* delimiter)
    : out_stream_(&amp;s),
      delim_(delimiter)
{
}

template &lt;class T, class charT, class traits&gt;
inline
ostream_iterator&lt;T,charT,traits&gt;&amp;
ostream_iterator&lt;T, charT, traits&gt;::operator=(const T&amp; value)
{
    *out_stream_ &lt;&lt; value;
    if(delim_ != 0)
        *out_stream_ &lt;&lt; delim_;
    return *this;
}

template &lt;class T, class charT, class traits&gt;
inline
ostream_iterator&lt;T,charT,traits&gt;&amp;
ostream_iterator&lt;T, charT, traits&gt;::operator*()
{
    return *this;
}

template &lt;class T, class charT, class traits&gt;
inline
ostream_iterator&lt;T,charT,traits&gt;&amp;
ostream_iterator&lt;T, charT, traits&gt;::operator++()
{
    return *this;
}

template &lt;class T, class charT, class traits&gt;
inline
ostream_iterator&lt;T,charT,traits&gt;&amp;
ostream_iterator&lt;T, charT, traits&gt;::operator++(int)
{
    return *this;
}

// istreambuf_iterator

template&lt;class charT, class traits&gt;
class istreambuf_iterator
    : public iterator&lt;input_iterator_tag, charT, typename traits::off_type, charT*, charT&amp;&gt;
{
public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef typename traits::int_type     int_type;
    typedef basic_streambuf&lt;charT,traits&gt; streambuf_type;
    typedef basic_istream&lt;charT,traits&gt;   istream_type;

    class proxy
    {
    public:
        charT operator*()
        {
            return keep_;
        }
    private:
        charT keep_;
        basic_streambuf&lt;charT,traits&gt;* sbuf_;

        proxy(charT c, basic_streambuf&lt;charT, traits&gt;* sbuf)
            : keep_(c),
              sbuf_(sbuf)
        {
        }

        friend class istreambuf_iterator;
    };

    istreambuf_iterator() _MSL_THROW;
    istreambuf_iterator(istream_type&amp; s) _MSL_THROW;
    istreambuf_iterator(streambuf_type* s) _MSL_THROW;
    istreambuf_iterator(const proxy&amp; p) _MSL_THROW;
    charT operator*() const;
    istreambuf_iterator&amp; operator++();
    proxy operator++(int);
    bool equal(const istreambuf_iterator&amp; b) const;
private:
    streambuf_type* sbuf_;
};

template&lt;class charT, class traits&gt;
inline
istreambuf_iterator&lt;charT, traits&gt;::istreambuf_iterator() _MSL_THROW
    : sbuf_(0)
{
}

template&lt;class charT, class traits&gt;
inline
istreambuf_iterator&lt;charT, traits&gt;::istreambuf_iterator(istream_type&amp; s) _MSL_THROW
    : sbuf_(s.rdbuf())
{
    if (sbuf_ != 0 &amp;&amp; traits::eq_int_type(sbuf_-&gt;sgetc(), traits::eof()))
        sbuf_ = 0;
}

template&lt;class charT, class traits&gt;
inline
istreambuf_iterator&lt;charT, traits&gt;::istreambuf_iterator(streambuf_type* s) _MSL_THROW
    : sbuf_(s)
{
    if (sbuf_ != 0 &amp;&amp; traits::eq_int_type(sbuf_-&gt;sgetc(), traits::eof()))
        sbuf_ = 0;
}

template&lt;class charT, class traits&gt;
inline
istreambuf_iterator&lt;charT, traits&gt;::istreambuf_iterator(const proxy&amp; p) _MSL_THROW
    : sbuf_(p.sbuf_)
{
    if (sbuf_ != 0 &amp;&amp; traits::eq_int_type(sbuf_-&gt;sgetc(), traits::eof()))
        sbuf_ = 0;
}

template&lt;class charT, class traits&gt;
inline
charT
istreambuf_iterator&lt;charT, traits&gt;::operator*() const
{
    return traits::to_char_type(sbuf_-&gt;sgetc());
}

template&lt;class charT, class traits&gt;
inline
istreambuf_iterator&lt;charT, traits&gt;&amp;
istreambuf_iterator&lt;charT, traits&gt;::operator++()
{
    sbuf_-&gt;sbumpc();
    if (traits::eq_int_type(sbuf_-&gt;sgetc(), traits::eof()))
        sbuf_ = 0;
    return *this;
}

template&lt;class charT, class traits&gt;
inline
typename istreambuf_iterator&lt;charT, traits&gt;::proxy
istreambuf_iterator&lt;charT, traits&gt;::operator++(int)
{
    proxy result(traits::to_char_type(sbuf_-&gt;sbumpc()), sbuf_);
    if (traits::eq_int_type(sbuf_-&gt;sgetc(), traits::eof()))
        sbuf_ = 0;
    return result;
}

template&lt;class charT, class traits&gt;
inline
bool
istreambuf_iterator&lt;charT, traits&gt;::equal(const istreambuf_iterator&amp; b) const
{
    return static_cast&lt;bool&gt;(!(static_cast&lt;bool&gt;(sbuf_) ^ static_cast&lt;bool&gt;(b.sbuf_)));
}

template &lt;class charT, class traits&gt;
inline
bool
operator==(const istreambuf_iterator&lt;charT,traits&gt;&amp; a, const istreambuf_iterator&lt;charT,traits&gt;&amp; b)
{
    return a.equal(b);
}

template &lt;class charT, class traits&gt;
inline
bool
operator!=(const istreambuf_iterator&lt;charT,traits&gt;&amp; a, const istreambuf_iterator&lt;charT,traits&gt;&amp; b)
{
    return static_cast&lt;bool&gt;(!a.equal(b));
}

template &lt;class charT, class traits&gt;
class ostreambuf_iterator
    : public iterator&lt;output_iterator_tag, void, void, void, void&gt;
{
public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef basic_streambuf&lt;charT,traits&gt; streambuf_type;
    typedef basic_ostream&lt;charT,traits&gt;   ostream_type;

    ostreambuf_iterator(ostream_type&amp; s) _MSL_THROW;
    ostreambuf_iterator(streambuf_type* s) _MSL_THROW;
    ostreambuf_iterator&amp; operator=(charT c);

    ostreambuf_iterator&amp; operator*();
    ostreambuf_iterator&amp; operator++();
    ostreambuf_iterator&amp; operator++(int);
    bool failed() const _MSL_THROW;
private:
    streambuf_type* sbuf_;
};

template &lt;class charT, class traits&gt;
inline
ostreambuf_iterator&lt;charT, traits&gt;::ostreambuf_iterator(ostream_type&amp; s) _MSL_THROW
    : sbuf_(s.rdbuf())
{
}

template &lt;class charT, class traits&gt;
inline
ostreambuf_iterator&lt;charT, traits&gt;::ostreambuf_iterator(streambuf_type* s) _MSL_THROW
    : sbuf_(s)
{
}

template &lt;class charT, class traits&gt;
inline
ostreambuf_iterator&lt;charT, traits&gt;&amp;
ostreambuf_iterator&lt;charT, traits&gt;::operator=(charT c)
{
    if (sbuf_ != 0 &amp;&amp; traits::eq_int_type(sbuf_-&gt;sputc(c), traits::eof()))
        sbuf_ = 0;
    return *this;
}

template &lt;class charT, class traits&gt;
inline
ostreambuf_iterator&lt;charT, traits&gt;&amp;
ostreambuf_iterator&lt;charT, traits&gt;::operator*()
{
    return *this;
}

template &lt;class charT, class traits&gt;
inline
ostreambuf_iterator&lt;charT, traits&gt;&amp;
ostreambuf_iterator&lt;charT, traits&gt;::operator++()
{
    return *this;
}

template &lt;class charT, class traits&gt;
inline
ostreambuf_iterator&lt;charT, traits&gt;&amp;
ostreambuf_iterator&lt;charT, traits&gt;::operator++(int)
{
    return *this;
}

template &lt;class charT, class traits&gt;
inline
bool
ostreambuf_iterator&lt;charT, traits&gt;::failed() const _MSL_THROW
{
    return static_cast&lt;bool&gt;(sbuf_ == 0);
}

#endif // _MSL_NO_IO

#ifndef _MSL_NO_CPP_NAMESPACE
    } // namespace std
#endif

#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _ITERATOR

// hh 971220 fixed MOD_INCLUDE and MOD_C_INCLUDE
// hh 971222 added wrapper for alignment
// hh 971222 Changed filename from iterator.h to iterator
// hh 971222 Made include guards standard
// hh 971222 updated __MSL_FIX_ITERATORS__
// hh 971222 Added default argument to istream_iterator template argument charT per 24.5.1.3
// hh 971222 Added default argument to ostream_iterator template argument charT per 24.5.2.2
// hh 971227 Changed friend declarations in reverse_iterator.  This was overly
//           friendly, and besides, requires more compiler than we have right now.
// hh 971227 non-standard stuff commented out
// hh 971227 Pointer renamed to pointer in several places per standard
// hh 971227 Reference renamed to reference in several places per standard
// hh 971230 added RC_INVOKED wrapper
// hh 980106 if inlined compiler instantiates reverse_iterator::op[] whether it is need or not.
//           this causes problems with bidirectional iterators.
// hh 980107 Completed and organized list of built-in types for iterator_traits specialization
// hh 980114 Moved istream_iterator comparison methods out of template definition.
// hh 980408 wrapped with #ifndef _No_Floating_Point 
// hh 980518 added specialization for const T*
// hh 980518 removed __advance &amp; __distance specializations for Bidirectional and Forward iterators
// hh 980519 rewrote reverse_iterator
// hh 980514 rewrote istream_iterator
// hh 980702 modified inheritance structure of iterator tags to match standard
// hh 980702 modified istreambuf_iterator&lt;charT, traits&gt;::increment() so that it worked correctly
// hh 980713 Temporarily moved member templates into class definition to support compiler
// hh 980803 removed traits:: from int_type in istreambuf_iterator::increment()
// hh 980924 Fixed bug in istream_iterator
// hh 980924 Added typename
// hh 981001 Fixed copy constructor of reverse_iterator
// hh 981220 Added typename to appropriate return types
// hh 981220 Added class modifier to several friend declarations
// hh 990401 Put long long inside of #ifdef
// hh 990427 Rewrote.
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>