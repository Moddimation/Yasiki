<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File strtold.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-strtoldc">File strtold.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_30eb297d72d9bf6e37ae97b245365a16/"><strong>MSL_C</strong></a> <strong>&gt;</strong> <a href="../dir_5ff331ae3d8ec7992933a87ab898fc05/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_296ea1c022f8cfa02577b9a5b06211f5/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../strtold_8c/"><strong>strtold.c</strong></a></p>
<p><a href="../strtold_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/07/30 01:09:14 $ 
 *  $Revision: 1.8.4.1 $ 
 *  $NoKeywords: $ 
 *
 *      Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/*
 *  strtold.c
 *  
 *  Routines
 *  --------
 *      __strtold
 *      __strtod
 *
 *  Implementation
 *  --------------
 *          
 *      The string scanner is implemented as an extended Finite State Machine.
 *      A state diagram for it can be found in an accompanying TeachText
 *      document, 'strtod syntax' (too bad pictures can't be imbedded in
 *      comments) in the &quot;MSL Technical Notes&quot; directory. A textual description
 *      of it follows.
 *          
 *      The state transition loop dispatches to the appropriate code for the
 *      current state, while simultaneously watching for terminating
 *      conditions (field width exhausted, EOF encountered, final state
 *      reached).
 *          
 *      start
 *          
 *          Skip leading spaces. Once a non-space is seen, process sign (if any)
 *          and trasition to next state.
 *          
 *      sig_start
 *          
 *          Look for either a digit or a decimal point. If it is a digit zero,
 *          treat it specially.
 *          
 *      leading_sig_zeroes
 *          
 *          Leading zero digits are discarded, as they add nothing to the result.
 *          
 *      int_digit_loop
 *          
 *          Process digits from the integer part of the significand. We accept
 *          only so many significant digits (DBL_DIG), but the ones we discard
 *          have to be accounted for in the exponent.
 *          
 *          If a decimal point is seen, proceed to process a fractional part (if
 *          one is present).
 *          
 *      frac_start
 *          
 *          Having seen a leading decimal point, we must see at least one digit.
 *          If the field width expires before the transition from this state to
 *          the next, we fail.
 *          
 *      frac_digit_loop
 *          
 *          Process digits from the fractional part of the significand. We accept
 *          only so many significant digits (DBL_DIG), but the ones we discard
 *          have to be accounted for in the exponent.
 *      sig_end
 *          
 *          If an 'E' (or 'e') follows we go after an exponent; otherwise we're
 *          done.
 *          
 *      exp_start
 *          
 *          Process the sign (if any).
 *          
 *      leading_exp_digit
 *          
 *          Check the leading exponent digit. If it is a digit zero, treat it
 *          specially.
 *          
 *      leading_exp_zeroes
 *          
 *          Leading zero digits are discarded, as they add nothing to the result.
 *          
 *      exp_digit_loop
 *          
 *          Process digits from the exponent. We watch for short int overflow,
 *          even though the maximum exponent is probably considerably less than
 *          this. The latter will be checked during the actual decimal to binary
 *          conversion.
 *          
 *      finished
 *          
 *          Successful exit.
 *          
 *      failure
 *          
 *          Invalid input exit.
 *
 *      The end product is just the parsed input and its conversion to a
 *      'decimal' record la SANE and MathLib. '__dec2num' is used for conversion
 *      to binary. For other systems that don't provide decimal to binary
 *      conversion in this or a similar way, a routine will be provided.
 *
 *
 */

#ifndef _No_Floating_Point

#include &quot;ansi_fp.h&quot;
#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;float.h&gt;
#include &quot;lconv.h&quot;
#include &lt;limits.h&gt;
#include &lt;locale.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;string_io.h&quot;
#include &quot;strtold.h&quot;

enum scan_states {
    start               = 0x0001,
    sig_start           = 0x0002,
    leading_sig_zeroes  = 0x0004,
    int_digit_loop      = 0x0008,
    frac_start          = 0x0010,
    frac_digit_loop     = 0x0020,
    sig_end             = 0x0040,
    exp_start           = 0x0080,
    leading_exp_digit   = 0x0100,
    leading_exp_zeroes  = 0x0200,
    exp_digit_loop      = 0x0400,
    finished            = 0x0800,
    failure             = 0x1000
};

#define MAX_SIG_DIG 20               /* mm 970609  */

#define final_state(scan_state) (scan_state &amp; (finished | failure))

#define success(scan_state) (scan_state &amp; ( leading_sig_zeroes  |           \
                                        int_digit_loop          |           \
                                        frac_digit_loop         |           \
                                        leading_exp_zeroes      |           \
                                        exp_digit_loop          |           \
                                        finished        ))

#define fetch()     (count++, (*ReadProc)(ReadProcArg, 0, __GetAChar)) /* mm 990325 */
#define unfetch(c)  (*ReadProc)(ReadProcArg, c, __UngetAChar)           /* mm 990325 */

#if __INTEL__
#pragma k63d_calls off
#endif
long double __strtold(  int         max_width,
                        int (*ReadProc)(void *, int, int), /* mm 990325 */
                        void * ReadProcArg,                 /* mm 990325 */
                        int     * chars_scanned,
                        int     * overflow)
{
    int                     dot             = * (unsigned char *) __lconv.decimal_point;
    int                     scan_state      = start;
    int                     count           = 0;
    int                     spaces          = 0;     /* mm 970708 */
    int                     c;
    decimal                 d               = {0, 0, 0, {0, &quot;&quot;}};
    int                     sig_negative    = 0;
    int                     exp_negative    = 0;
    long                    exp_value       = 0;
    int                     exp_adjust      = 0;
    long double     result;

    *overflow = 0;

    c = fetch();

    while (count &lt;= max_width &amp;&amp; c != EOF &amp;&amp; !final_state(scan_state)) 
    {

        switch (scan_state)
        {
            case start:

                if (isspace(c))
                {
                    c = fetch();
                    count--;    /* 01-Jan-97 mani@be */
                    spaces++;   /* 01-Jan-97 mani@be */

                    break;
                }

                if (c == '+')
                    c = fetch();
                else if (c == '-')
                {
                    c = fetch();

                    sig_negative = 1;
                }

                scan_state = sig_start;

                break;

            case sig_start:

                if (c == dot)
                {
                    scan_state = frac_start;

                    c = fetch();

                    break;
                }

                if (!isdigit(c))
                {
                    scan_state = failure;

                    break;
                }

                if (c == '0')
                {
                    scan_state = leading_sig_zeroes;

                    c = fetch();

                    break;
                }

                scan_state = int_digit_loop;

                break;

            case leading_sig_zeroes:

                if (c == '0')
                {
                    c = fetch();

                    break;
                }

                scan_state = int_digit_loop;

                break;

            case int_digit_loop:

                if (!isdigit(c))
                {
                    if (c == dot)
                    {
                        scan_state = frac_digit_loop;

                        c = fetch();
                    }
                    else
                        scan_state = sig_end;

                    break;
                }

                if (d.sig.length &lt; MAX_SIG_DIG)          /*mm 970609 */
                    d.sig.text[d.sig.length++] = c;
                else
                    exp_adjust++;

                c = fetch();

                break;

            case frac_start:

                if (!isdigit(c))
                {
                    scan_state = failure;

                    break;
                }

                scan_state = frac_digit_loop;

                break;

            case frac_digit_loop:

                if (!isdigit(c))
                {
                    scan_state = sig_end;

                    break;
                }

                if (d.sig.length &lt; MAX_SIG_DIG)                /*mm 970609 */
                {
                    if ( c != '0' || d.sig.length)              /* __dec2num doesn't like leading zeroes*/
                        d.sig.text[d.sig.length++] = c;
                    exp_adjust--;
                }

                c = fetch();

                break;

            case sig_end:

                if (c == 'E' || c == 'e')
                {
                    scan_state = exp_start;

                    c = fetch();

                    break;
                }

                scan_state = finished;

                break;

            case exp_start:

                if (c == '+')
                    c = fetch();
                else if (c == '-')
                {
                    c = fetch();

                    exp_negative = 1;
                }

                scan_state = leading_exp_digit;

                break;

            case leading_exp_digit:

                if (!isdigit(c))
                {
                    scan_state = failure;

                    break;
                }

                if (c == '0')
                {
                    scan_state = leading_exp_zeroes;

                    c = fetch();

                    break;
                }

                scan_state = exp_digit_loop;

                break;

            case leading_exp_zeroes:

                if (c == '0')
                {
                    c = fetch();

                    break;
                }

                scan_state = exp_digit_loop;

                break;

            case exp_digit_loop:

                if (!isdigit(c))
                {
                    scan_state = finished;

                    break;
                }

                exp_value = exp_value*10 + (c - '0');

                if (exp_value &gt; SHRT_MAX)
                    *overflow = 1;

                c = fetch();

                break;
        }
    }

    if (!success(scan_state))
    {
        count = 0;   /* mf 092497 */
        *chars_scanned=0;
    }
    else
    {
        count--;
        *chars_scanned = count + spaces; /* 01-Jan-97 mani@be */
    }

    unfetch(c);

    if (exp_negative)
        exp_value = -exp_value;

    {
        int                         n = d.sig.length;
        unsigned char * p = &amp;d.sig.text[n];

        while (n-- &amp;&amp; *--p == '0')
            exp_adjust++;

        d.sig.length = n + 1;

        if (d.sig.length == 0)
            d.sig.text[d.sig.length++] = '0';
    }

    exp_value += exp_adjust;

    if (exp_value &lt; SHRT_MIN || exp_value &gt; SHRT_MAX)
        *overflow = 1;

    if (*overflow)
        if (exp_negative)
            return(0.0);
        else
            return(sig_negative ? -HUGE_VAL : HUGE_VAL);

    d.exp = exp_value;

    result = __dec2num(&amp;d);

/*
 *  Note: If you look at &lt;ansi_fp.h&gt; you'll see that __dec2num only supports double.
 *              If you look at &lt;float.h&gt; you'll see that long double == double. Ergo, the
 *              difference is moot *until* a truly long double type is supported.
 */

    if (result != 0.0 &amp;&amp; result &lt; LDBL_MIN)
    {
        *overflow = 1;
        result    = 0.0;
    }
    else if (result &gt; LDBL_MAX)
    {
        *overflow = 1;
        result    = HUGE_VAL;
    } 

    if (sig_negative)
        result = -result;

    return(result);
}

double strtod(const char * str, char ** end)
{
    long double value, abs_value;
    int                 count, overflow;

    __InStrCtrl isc;
    isc.NextChar         = (char *)str;
    isc.NullCharDetected = 0;

    value = __strtold(INT_MAX, &amp;__StringRead, (void *)&amp;isc, &amp;count, &amp;overflow);

    if (end)
        *end = (char *) str + count;

    abs_value = fabs(value);

    if (overflow || (value != 0.0 &amp;&amp; (abs_value &lt; DBL_MIN || abs_value &gt; DBL_MAX)))
        errno = ERANGE;

    return(value);
}

double atof(const char * str)
{
    return(strtod(str, NULL));
}
#if __INTEL__
#pragma k63d_calls reset
#endif

#endif /* ndef _No_Floating_Point */

/*  Change Record
 *  22-Jun-95 JFH  First code release.
 *  27-Jul-95 JFH  Removed stray SysBreak(). Added code to make use of the remembered sign of
 *                               of the significand.
 *  29-Sep-95 JFH  Discovered __dec2num doesn't like leading zeroes except for zeroes, so numbers
 *                               like .01 would get interpreted as zero. Fixed by suppressing leading zeroes.
 *  14-Nov-95 JFH  Fixed bug in strtod where value was checked against DBL_MIN and DBL_MAX instead
 *                               of the absolute value.
 *  25-Apr-96 JFH  Changed __strtold to return -HUGE_VAL instead of HUGE_VAL on overflow if a
 *                               minus sign was previously detected.
 *  15-Jul-97 SCM  Disabled when _No_Floating_Point is defined.
 *  01-Jan-97 mani@be   Fix a scanf bug dealing with white space. Things like
 *                      scanf(&quot;%5lx&quot;) weren't working properly when there was
 *                      white space.
 *  mm 970609      Changed the max number of significant digits to MAX_SIG_DIG(==32) instead of DBL_DIG
 *  mm 970708      Inserted Be changes
 *  mf 970924      If there are no digits in the string then the value of &amp;endp must remain unchanged
 *                 In this case the variable chars_scanned of strtold should be 0
 *  mm 990325      Made to work with input functions passed by pointers 
 *  mf 990420      turned off k6 calling convention
 *  mf 990420      had to provide k6 wrap internal function __strtold as well
 */
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>