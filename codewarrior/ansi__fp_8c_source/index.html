<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File ansi_fp.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-ansi_fpc">File ansi_fp.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_30eb297d72d9bf6e37ae97b245365a16/"><strong>MSL_C</strong></a> <strong>&gt;</strong> <a href="../dir_862c03c3c35584d0a555c3abef6e72a9/"><strong>MSL_Common_Embedded</strong></a> <strong>&gt;</strong> <a href="../dir_1e8f7e80780abef8fc1b2377af773d8e/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../ansi__fp_8c/"><strong>ansi_fp.c</strong></a></p>
<p><a href="../ansi__fp_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  Version 2.4  1998 March 10  */

/*  $Date: 1999/12/09 22:18:39 $ 
 *  $Revision: 1.3.2.1 $ 
 *  $NoKeywords: $ 
 *
 *      Copyright 1995-1998 Metrowerks, Inc.
 *      All rights reserved.
 */

/*
 *  ansi_fp.c
 *  
 *  Routines
 *  --------
 *      These are routines similar to those from MathLib needed by non-Mac systems.
 *      Note that we assume 8-byte doubles here.
 *
 *          __num2dec - same as num2dec, except that we don't support the FIXEDDECIMAL
 *                                  style result (all conversions are handled in printf using the
 *                                  FLOATDECIMAL output)
 *
 *          __dec2num - same as dec2num
 *
 *  Modification History
 *  --------------------
 *
 *  19-Oct-95 JFH  First code release.
 *  07-Dec-95 JFH  Changed Inf and NaN from zero-divide expressions to bit-pattern
 *                               references. Be's SCO barfed on the expressions.
 *  15-Jul-97 SCM  Disabled when _No_Floating_Point defined.
 */

#ifndef _No_Floating_Point

#include &quot;ansi_fp.h&quot;
#include &lt;errno.h&gt;
#include &lt;float.h&gt;
#include &lt;stdlib.h&gt;

static const double bit_values[] =
{
    1.0E+001,
    1.0E+002,
    1.0E+004,
    1.0E+008,
    1.0E+016,
    1.0E+032,
    1.0E+064,
    1.0E+128,
    1.0E+256
};

#define max_bits    511     /* (2**n)-1 where n is the number of elements in bit_values */

static const double digit_values[] =
{
    1.0E+01,
    1.0E+02,
    1.0E+03,
    1.0E+04,
    1.0E+05,
    1.0E+06,
    1.0E+07,
    1.0E+08
};

extern _INT32 __double_nan   [];      /* hh 971202  added extern, defined in float.c*/
#define Inf HUGE_VAL   /*  HUGE_VAL is the double encoding of infinity */
#define NaN (* (double *) __double_nan )

void __num2dec(const decform *f, double x, decimal *d)
{
    int     exp2;
    long    exp10;
    int     digits = f-&gt;digits;

/*
 *  Don't try to extract any more significant digits than are there.
 */

    if (digits &gt; DBL_DIG + 1)
        digits = DBL_DIG + 1;

/*
 *  We first deal with the special cases of zeroes, infinities and NaNs
 */

    d-&gt;sgn = 0;
    d-&gt;exp = 0;

    d-&gt;sig.length = 1;

    if (x == 0.0)
    {
        d-&gt;sig.text[0] = '0';
        return;
    }

    if (!isfinite(x))
    {
        d-&gt;sig.text[0] = isnan(x) ? 'N' : 'I';
        return;
    }

    d-&gt;sig.length = 0;

/*
 *  Now comes the easy part - we extract the sign.
 */

    if (x &lt; 0.0)
    {
        d-&gt;sgn = 1;
        x = -x;
    }

/*
 *  Next, we use frexp() to separate x into a fraction f and an exponent e. The
 *  fraction is a value between 0.5 and 1.0 such that f * (2**e) == x. This is
 *  basically how x is stored internally. All we're interested in is the
 *  exponent to approximate the factor of 10 by which to scale x to get rid of
 *  its exponent.
 */

    frexp(x, &amp;exp2);

/*
 *  We convert the base-2 exponent to a base-10 exponent by multiplying it by
 *  the base-10 logarithm of 2 (approximately .30102999566398). Rather than
 *  invoke the overhead of conversion to floating point and back, we instead
 *  multiply by 301029 and then divide by 1000000. The largest double exponent
 *  is 1024; 301029 * 1024 == 308253696, which can easily be represented by a
 *  long int.
 */

    exp10 = (exp2 * 301029) / 1000000;

/*
 *  Now we scale x by exp10. The easy way to do this would be simply to
 *  multiply or divide by 10, exp10 times. However, as noted above, the largest
 *  binary exponent is 1024. It's decimal equivalent is 1024 log 2 ナナ 308.
 *  That's potentially a lot of multiplies/divides. Alternatively, we can scan
 *  the decimal exponent bitwise and, for each bit 2**i, scale by a constant
 *  10**(2**i) if that bit is nonzero. This results in at most nine multiplies
 *  or divides.
 *
 *  Note that division usually consumes more cycles than multiplication.
 *  Therefore, we avoid doing multiple division operations by multiplying the
 *  scale factors together and then dividing only once.
 */

    {
        const double *  p = bit_values;
        int                         n = exp10;

        if (n &lt; 0)
        {
            for (n = -n; n; p++, n &gt;&gt;= 1)
                if (n &amp; 1)
                    x *= *p;
        }
        else if (n &gt; 0)
        {
            double f = 1.0;

            for (; n; p++, n &gt;&gt;= 1)
                if (n &amp; 1)
                    f *= *p;

            x /= f;
        }
    }

/*
 *  Now we scale up or down as necessary to ensure that x is &gt;= 0.1 and &lt; 1.0.
 *  This puts all the digits to the right of the decimal point.
 */

    while (x &gt;= 1.0)
    {
        x *= 0.1;
        ++exp10;
    }

    while (x &lt; 0.1)
    {
        x *= 10.0;
        --exp10;
    }

/*
 *  Now we pick off decimal digits from left to right up to eight at a time. We
 *  do this by shifting digits to the left of the decimal point and converting
 *  to long int to extract the shifted digits. We then decode the long int in
 *  the usual way.
 */

    {
        unsigned char * p = d-&gt;sig.text;
        int                         i;

        while (digits)
        {
            int     n = digits;
            long    long_x;

            if (n &gt; 8)
                n = 8;

            digits -= n;

            exp10 -= n;

            d-&gt;sig.length += n;

            p += n;

            x *= digit_values[n-1];

            long_x = (long) x;

            x -= (double) long_x;

            for (i = n + 1; --i;)
            {
                *--p = (long_x % 10) + '0';
                long_x /= 10;
            }

            p += n;
        }

/*
 *  We fill up any remaining requested digits with zeroes, but no more
 *  than fits in a decimal record.
 */

        digits = f-&gt;digits;

        if (digits &gt; SIGDIGLEN)
            digits = SIGDIGLEN;

        digits -= d-&gt;sig.length;

        if (digits &gt; 0)
        {
            for (i = digits + 1; --i;)
                *p++ = '0';

            d-&gt;sig.length += digits;

            exp10 -= digits;
        }
    }

/*
 *  Finally, don't forget to drop off the exponent...
 */

    d-&gt;exp = exp10;
}

double __dec2num(const decimal *d)
{
    double  x   = 0.0;
    int         sgn = d-&gt;sgn;
    long        exp = d-&gt;exp;
    int         len = d-&gt;sig.length;

/*
 *  Handle special cases
 */

    {
        char    c = *d-&gt;sig.text;

        if (len &lt; 1 || c == '0')
            return(0.0);

        if (c == 'I')
            return(sgn ? -Inf : Inf);

        if (c == 'N')
            return(NaN);
    }

/*
 *  Toss insignificant digits
 */

    if (len &gt; DBL_DIG + 1)
    {
        exp += len - (DBL_DIG + 1);
        len = DBL_DIG + 1;
    }

/*
 *  We're going to accumulate digits eight at a time (enough to fit into a long int).
 *  If the number of digits isn't evenly divisible by eight, the stragglers are on
 *  the left as far as we are concerned.
 */

    {
        int                 digits = len % 8;
        double              f;
        const unsigned char *   p = d-&gt;sig.text;

        if (!digits)
            digits = 8;

/*
 *  Once we're done we're going to shift the decimal point from the far right to the
 *  immediate right of the most significant digit. We make some adjustments here toward
 *  that end.
 */

        exp += len - 1;
        f    = pow(10.0, (len-1));

/*
 *  OK, let's do it...
 */

        while (digits)
        {
            int     i;
            long    long_x;

            for (i = digits + 1, long_x = 0; --i;)
                long_x = (long_x * 10) + (*p++ - '0');

            x = (x * 1e+08) + (double) long_x;

            if (!(len -= digits))
                break;

            digits = 8;
        }

        x /= f;
    }

/*
 *  We raise 10 to the exp power, making sure we don't overflow along the
 *  way. Then we multiply or divide x by the result, also guarding against
 *  overflow/underflow.
 */

    {
        const double *  p = bit_values;
        double                  f = 1.0;
        long                        n = labs(exp);

        if (n &gt; max_bits)
            if (exp &lt; 0)
                return(0.0);
            else
                return(sgn ? -Inf : Inf);

        f = 1.0;

        for (; n; p++, n &gt;&gt;= 1)
            if (n &amp; 1)
                if (f &gt; DBL_MAX / *p)
                    return(sgn ? -Inf : Inf);
                else
                    f *= *p;

        if (exp &lt; 0)
        {
            if (x &lt; DBL_MIN * f)
                return(0.0);
            else
                x /= f;
        }
        else if (exp &gt; 0)
        {
            if (x &gt; DBL_MAX / f)
                return(sgn ? -Inf : Inf);
            else
                x *= f;
        }
    }

    return(sgn ? -x : x);
}

#endif /* ndef _No_Floating_Point */

/*
    Change Record
 * hh 971206 fixed bug with __double_nan
*/
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>