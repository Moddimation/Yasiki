<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File strstream.cpp - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-strstreamcpp">File strstream.cpp</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_1d8bcf55c9e1564519df8a05b1def2d1/"><strong>MSL_C++</strong></a> <strong>&gt;</strong> <a href="../dir_fc42de24ef3c14a5dea3aca327bd2ec9/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_5dfda252c22d458fde1d653b341676b1/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../strstream_8cpp/"><strong>strstream.cpp</strong></a></p>
<p><a href="../strstream_8cpp/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/12/09 17:58:23 $ 
 *  $Revision: 1.6.6.1 $ 
 *  $NoKeywords: $ 
 *
 *      Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/************************************************************************/
/*  Project...: Standard C++ Library                                    */
/*  Name......: strstream.cpp                                           */
/*  Purpose...: &lt;strstream&gt; support                                     */
/************************************************************************/

#include &lt;strstream&gt;

#ifndef _MSL_NO_IO

#ifndef _MSL_NO_CPP_NAMESPACE
    namespace std {
#endif

// strstreambuf

strstreambuf::~strstreambuf()
{
    if ((strmode_ &amp; allocated) != 0 &amp;&amp; (strmode_ &amp; frozen) == 0)  // hh 990422
    {
        if (pfree_ != 0)
            pfree_(eback());
        else
            delete [] eback();
    }
}

void
strstreambuf::freeze(bool freezefl)
{
    if ((strmode_ &amp; dynamic) != 0)  // hh 990422
    {
        if (freezefl)
            strmode_ |= frozen;
        else
            strmode_ &amp;= (strstate)~frozen;
    }
}

strstreambuf::int_type
strstreambuf::overflow (int_type c)
{
    if (c == EOF)
        return 0;
    if (pptr() &lt; epptr())
    {
        *pptr() = (char)c;
        pbump(1);
        return c;
    }
    if ((strmode_ &amp; dynamic) == 0 || (strmode_ &amp; frozen) != 0)  // hh 990422
        return EOF;
    streamsize getlen = egptr() - eback();
    streamsize getpos = gptr() - eback();
    streamsize putstart = pbase() - eback(); // hh 990423
    streamsize putpos = pptr() - pbase();
    streamsize oldsize = epptr() - eback();  // hh 990423
    streamsize newsize;
    if (oldsize &lt; alsize_)
        newsize = alsize_;
    else
        newsize = 2 * oldsize;
    char* newbuffer;    // hh 990423
    if (palloc_ != 0)
        newbuffer = (char*)palloc_((size_t)newsize);
    else
        newbuffer = new(nothrow) char [newsize];
    if (newbuffer == 0)
        return EOF;
    strmode_ |= allocated;
    if (oldsize != 0)
    {
        char* p = newbuffer;
        char* g = eback();
        for (streamsize i = 0; i &lt; oldsize; ++i)
            *p++ = *g++;
        if (pfree_ != 0)
            pfree_(eback());
        else
            delete [] eback();
    }
    setg(newbuffer, newbuffer + getpos, newbuffer + getlen);
    setp(newbuffer + putstart, newbuffer + newsize);  // hh 980910, 990423
    pbump(putpos);
    *pptr() = (char)c;
    pbump(1);
    return c;
}

strstreambuf::int_type
strstreambuf::pbackfail(int_type c)
{
    if (gptr() &lt;= eback())
        return EOF;
    gbump(-1);
    if (c == EOF)
        return 0;
    if ((char)c == *gptr())
        return c;
    if ((strmode_ &amp; constant) == 0)  // hh 990422
    {
        *gptr() = (char)c;
        return c;
    }
    gbump(1);
    return EOF;
}

strstreambuf::int_type
strstreambuf::underflow()
{
    if (gptr() &lt; egptr())
        return (unsigned char)*gptr();
    if (egptr() &lt; pptr())
    {
        setg(eback(), gptr(), pptr());  // hh 990423
        return (unsigned char)*gptr();
    }
    return EOF;
}

strstreambuf::pos_type
strstreambuf::seekoff(off_type off, ios_base::seekdir way, ios_base::openmode which)
{
    ios_base::openmode inout = ios_base::in | ios_base::out;  // hh 990423
    if ((which &amp; inout) == inout &amp;&amp; way == ios_base::cur || (which &amp; inout) == 0)
        return pos_type(-1);
    off_type newoff = -1;
    if (which &amp; ios_base::in)
    {
        switch (way)
        {
        case ios_base::beg:
            newoff = 0;
            break;
        case ios_base::cur:
            newoff = gptr() - eback();
            break;
        case ios_base::end:
            newoff = egptr() - eback();
            break;
        default:
            return pos_type(-1);
        }
        newoff += off;
        if (newoff &lt; 0 || newoff &gt; egptr() - eback())
            return pos_type(-1);
        setg(eback(), eback()+newoff, egptr());
    }
    if (which &amp; ios_base::out)
    {
        switch (way)
        {
        case ios_base::beg:
            newoff = 0;
            break;
        case ios_base::cur:
            newoff = pptr() - pbase();
            break;
        case ios_base::end:
            newoff = epptr() - pbase();
            break;
        default:
            return pos_type(-1);
        }
        newoff += off;
        if (newoff &lt; 0 || newoff &gt; epptr() - pbase())
            return pos_type(-1);
        setp(pbase(), epptr());
        pbump(newoff);
    }
    return pos_type(newoff);
}

strstreambuf::pos_type
strstreambuf::seekpos(pos_type sp, ios_base::openmode which)
{
    off_type newoff = -1;
    if (which &amp; ios_base::in)
    {
        newoff = sp;  // hh 980909
        if (newoff &lt; 0 || newoff &gt; egptr() - eback())
            return pos_type(-1);
        setg(eback(), eback()+newoff, egptr());
    }
    if (which &amp; ios_base::out)
    {
        newoff = sp;  // hh 980909
        if (newoff &lt; 0 || newoff &gt; epptr() - pbase())
            return pos_type(-1);
        setp(pbase(), epptr());
        pbump(newoff);
    }
    return pos_type(newoff);
}

streambuf*
strstreambuf::setbuf(char* s, streamsize n)
{   // hh 990423
    if (s == 0 || n == 0)
        return 0;
    if ((strmode_ &amp; allocated) != 0 &amp;&amp; (strmode_ &amp; frozen) == 0)
    {
        if (pfree_ != 0)
            pfree_(eback());
        else
            delete [] eback();
    }
    strmode_ = 0;
    init(s, n, s);
    return this;
}

void
strstreambuf::init(char* gnext_arg, streamsize n, char* pbeg_arg)
{
    streamsize N = n;
    if (N == 0)
        N = (streamsize)strlen(gnext_arg);
    else if (N &lt; 0)
        N = INT_MAX;
    if (pbeg_arg == 0)
        setg(gnext_arg, gnext_arg, gnext_arg + N);
    else
    {
        setg(gnext_arg, gnext_arg, pbeg_arg);
        setp(pbeg_arg, pbeg_arg + N);
    }
}

// istrstream

// ostrstream

#ifndef _MSL_NO_CPP_NAMESPACE
    }
#endif

#endif // _MSL_NO_IO

// hh 980910 Fixed bug in strstreambuf::overflow, pend was being incorrectly set
// hh 990120 changed name of MSIPL flags
// hh 990422 Put parenthesis around (strmode_ &amp; X) 6 places
// hh 990423 Corrected several mistakes concerning the placement and movement of
//           the get and put areas during underflow and overflow.
// hh 990423 Filled out setbuf
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>