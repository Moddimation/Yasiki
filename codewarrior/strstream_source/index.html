<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File strstream - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-strstream">File strstream</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_1d8bcf55c9e1564519df8a05b1def2d1/"><strong>MSL_C++</strong></a> <strong>&gt;</strong> <a href="../dir_fc42de24ef3c14a5dea3aca327bd2ec9/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_f262df31fb8e04d575b9a3aa2e30ecf8/"><strong>Include</strong></a> <strong>&gt;</strong> <a href="../strstream/"><strong>strstream</strong></a></p>
<p><a href="../strstream/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/12/09 17:59:46 $ 
 *  $Revision: 1.9.6.1 $ 
 *  $NoKeywords: $ 
 *
 *      Portions Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/**
 **  strstream
 **
 **/

#ifndef _STRSTREAM
#define _STRSTREAM

#include &lt;mslconfig&gt;

#ifndef _MSL_NO_IO

#include &lt;istream&gt;

#ifndef RC_INVOKED

#pragma options align=native
#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
    namespace std {
#endif

class strstreambuf
    : public streambuf
{
public:
    explicit strstreambuf(streamsize alsize_arg = 0);
    strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
    strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = 0);
    strstreambuf(const char* gnext_arg, streamsize n);
    strstreambuf(signed char* gnext_arg, streamsize n, signed char* pbeg_arg = 0);
    strstreambuf(const signed char* gnext_arg, streamsize n);
    strstreambuf(unsigned char* gnext_arg, streamsize n, unsigned char* pbeg_arg = 0);
    strstreambuf(const unsigned char* gnext_arg, streamsize n);
    virtual ~strstreambuf();
    void  freeze(bool freezefl = true);
    char* str();
    int   pcount() const;
protected:
    virtual int_type overflow (int_type c = EOF);
    virtual int_type pbackfail(int_type c = EOF);
    virtual int_type underflow();
    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
                             ios_base::openmode which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type sp,
                             ios_base::openmode which = ios_base::in | ios_base::out);
    virtual streambuf* setbuf(char* s, streamsize n);
private:
    typedef unsigned char strstate;
    static const strstate allocated = 1 &lt;&lt; 0;
    static const strstate constant  = 1 &lt;&lt; 1;
    static const strstate dynamic   = 1 &lt;&lt; 2;
    static const strstate frozen    = 1 &lt;&lt; 3;
    static const streamsize default_alsize = 128;
    streamsize alsize_;
    void* (*palloc_)(size_t);
    void (*pfree_)(void*);
    strstate strmode_;

    void init(char* gnext_arg, streamsize n, char* pbeg_arg = 0);
};

class istrstream
    : public basic_istream&lt;char&gt;
{
public:
    explicit istrstream(const char* s);
    explicit istrstream(char* s);
    istrstream(const char* s, streamsize n);
    istrstream(char* s, streamsize n);
    virtual ~istrstream();
    strstreambuf* rdbuf() const;
    char* str();
private:
    strstreambuf strbuf_;
};

class ostrstream
    : public basic_ostream&lt;char&gt;
{
public:
    ostrstream();
    ostrstream(char* s, int n, ios_base::openmode mode = ios_base::out);
    virtual ~ostrstream();
    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    char* str();
    int pcount() const;
private:
    strstreambuf strbuf_;
};

class strstream
    : public basic_iostream&lt;char&gt;
{
public:
    // Types
    typedef char                                char_type;
    typedef typename char_traits&lt;char&gt;::int_type int_type;
    typedef typename char_traits&lt;char&gt;::pos_type pos_type;
    typedef typename char_traits&lt;char&gt;::off_type off_type;
    // consturctors/destructor
    strstream();
    strstream(char* s, int n, ios_base::openmode mode = ios_base::in|ios_base::out);
    virtual ~strstream();
    // Members:
    strstreambuf* rdbuf() const;
    void freeze(bool freezefl = true);
    int pcount() const;
    char* str();
private:
    strstreambuf strbuf_;
};

// Implementation

// strstreambuf

inline
strstreambuf::strstreambuf(streamsize alsize_arg)
    : alsize_(alsize_arg),
      palloc_(0),
      pfree_(0),
      strmode_(dynamic)
{
    if (alsize_ &lt;= 0)
        alsize_ = default_alsize;
}

inline
strstreambuf::strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*))
    : alsize_(default_alsize),
      palloc_(palloc_arg),
      pfree_(pfree_arg),
      strmode_(dynamic)
{
}

inline
strstreambuf::strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg)
    : alsize_(default_alsize),
      palloc_(0),
      pfree_(0),
      strmode_(0)
{
    init(gnext_arg, n, pbeg_arg);
}

inline
strstreambuf::strstreambuf(const char* gnext_arg, streamsize n)
    : alsize_(default_alsize),
      palloc_(0),
      pfree_(0),
      strmode_(constant)
{
    init((char*)gnext_arg, n);
}

inline
strstreambuf::strstreambuf(signed char* gnext_arg, streamsize n, signed char* pbeg_arg)
    : alsize_(default_alsize),
      palloc_(0),
      pfree_(0),
      strmode_(0)
{
    init((char*)gnext_arg, n, (char*)pbeg_arg);
}

inline
strstreambuf::strstreambuf(const signed char* gnext_arg, streamsize n)
    : alsize_(default_alsize),
      palloc_(0),
      pfree_(0),
      strmode_(constant)
{
    init((char*)gnext_arg, n);
}

inline
strstreambuf::strstreambuf(unsigned char* gnext_arg, streamsize n, unsigned char* pbeg_arg)
    : alsize_(default_alsize),
      palloc_(0),
      pfree_(0),
      strmode_(0)
{
    init((char*)gnext_arg, n, (char*)pbeg_arg);
}

inline
strstreambuf::strstreambuf(const unsigned char* gnext_arg, streamsize n)
    : alsize_(default_alsize),
      palloc_(0),
      pfree_(0),
      strmode_(constant)
{
    init((char*)gnext_arg, n);
}

inline
char*
strstreambuf::str()
{
    freeze();
    return eback();
}

inline
int
strstreambuf::pcount() const
{
    return pptr() - pbase();
}

// istrstream

inline
istrstream::istrstream(const char* s)
    : basic_istream&lt;char&gt;(&amp;strbuf_),
      strbuf_(s, 0)
{
}

inline
istrstream::istrstream(char* s)
    : basic_istream&lt;char&gt;(&amp;strbuf_),
      strbuf_(s, 0)
{
}

inline
istrstream::istrstream(const char* s, streamsize n)
    : basic_istream&lt;char&gt;(&amp;strbuf_),
      strbuf_(s, n)
{
}

inline
istrstream::istrstream(char* s, streamsize n)
    : basic_istream&lt;char&gt;(&amp;strbuf_),
      strbuf_(s, n)
{
}

inline
istrstream::~istrstream()
{
}

inline
strstreambuf*
istrstream::rdbuf() const
{
    return (strstreambuf*)&amp;strbuf_;
}

inline
char*
istrstream::str()
{
    return rdbuf()-&gt;str();
}

// ostrstream

inline
ostrstream::ostrstream()
    : basic_ostream&lt;char&gt;(&amp;strbuf_)
{
}

inline
ostrstream::ostrstream(char* s, int n, ios_base::openmode mode)
    : basic_ostream&lt;char&gt;(&amp;strbuf_),
      strbuf_(mode &amp; app ? strstreambuf(s, n, s + strlen(s)) : strstreambuf(s, n, s))
{
}

inline
ostrstream::~ostrstream()
{
}

inline
strstreambuf*
ostrstream::rdbuf() const
{
    return (strstreambuf*)&amp;strbuf_;
}

inline
void
ostrstream::freeze(bool freezefl)
{
    strbuf_.freeze(freezefl);
}

inline
char*
ostrstream::str()
{
    return rdbuf()-&gt;str();
}

inline
int
ostrstream::pcount() const
{
    return rdbuf()-&gt;pcount();
}

// strstream

inline
strstream::strstream()
    : basic_iostream&lt;char&gt;(&amp;strbuf_)
{
}

inline
strstream::strstream(char* s, int n, ios_base::openmode mode)
    : basic_iostream&lt;char&gt;(&amp;strbuf_),
      strbuf_(mode &amp; app ? strstreambuf(s, n, s + strlen(s)) : strstreambuf(s, n, s))
{
}

inline
strstream::~strstream()
{
}

inline
strstreambuf*
strstream::rdbuf() const
{
    return (strstreambuf*)&amp;strbuf_;
}

inline
void
strstream::freeze(bool freezefl)
{
    strbuf_.freeze(freezefl);
}

inline
int
strstream::pcount() const
{
    return rdbuf()-&gt;pcount();
}

inline
char*
strstream::str()
{
    return rdbuf()-&gt;str();
}

#ifndef _MSL_NO_CPP_NAMESPACE
    } // namespace std 
#endif

#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _MSL_NO_IO

#endif // _STRSTREAM

// hh 990126 Changed from MSIPL flags to _MSL flags
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>