<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File memory - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-memory">File memory</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_1d8bcf55c9e1564519df8a05b1def2d1/"><strong>MSL_C++</strong></a> <strong>&gt;</strong> <a href="../dir_fc42de24ef3c14a5dea3aca327bd2ec9/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_f262df31fb8e04d575b9a3aa2e30ecf8/"><strong>Include</strong></a> <strong>&gt;</strong> <a href="../memory/"><strong>memory</strong></a></p>
<p><a href="../memory/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/12/09 17:59:44 $ 
 *  $Revision: 1.14.6.1 $ 
 *  $NoKeywords: $ 
 *
 *      Portions Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/**
 **  memory
 **/

#ifndef _MEMORY
#define _MEMORY

#include &lt;mslconfig&gt;

#include &lt;cstddef&gt;
#include &lt;cstring&gt;
#ifndef _MSL_NO_WCHART
    #include &lt;cwchar&gt;
#endif
#include &lt;new&gt;
#include &lt;limits&gt;
#include &lt;utility&gt;
#include &lt;iterator&gt;

#ifndef RC_INVOKED

#pragma options align=native
#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
    namespace std {
#endif

// Warning, __destroy is non-standard

template &lt;class T&gt;
inline
void
__destroy(T* pointer)
{
    pointer-&gt;~T ();
}

template &lt;class ForwardIterator&gt;
inline
void
__destroy(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
{ 
    for(; first != last; ++first) 
        __destroy(&amp;*first);
}

template &lt;class RandomAccessIterator&gt;
inline
void
__destroy(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)
{ 
    for(; first &lt; last; ++first) 
        __destroy(&amp;*first);
}

template &lt;class ForwardIterator&gt;
inline
void
__destroy(ForwardIterator first, ForwardIterator last)
{
    __destroy(first, last, iterator_traits&lt;ForwardIterator&gt;::iterator_category());
}

//  lib.default.allocator, the default allocator:

template &lt;class T&gt; class allocator;

//  specialize for  void:

template &lt;&gt;
class allocator&lt;void&gt;
{
public:
    typedef size_t      size_type;
    typedef ptrdiff_t   difference_type;
    typedef void*       pointer;
    typedef const void* const_pointer;
    typedef void        value_type;
#ifndef _MSL_NO_MEMBER_TEMPLATE
    template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
#endif
};

template &lt;class T&gt;
class allocator
{
public:
    typedef size_t    size_type;
    typedef ptrdiff_t difference_type;
    typedef T*        pointer;
    typedef const T*  const_pointer;
    typedef T&amp;        reference;
    typedef const T&amp;  const_reference;
    typedef T         value_type;
#ifndef _MSL_NO_MEMBER_TEMPLATE
    template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
#endif

    allocator() _MSL_THROW;
#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE
    template &lt;class U&gt; allocator(const allocator&lt;U&gt;&amp;) _MSL_THROW;
#else
    template &lt;class U&gt;
    inline
    allocator(const allocator&lt;U&gt;&amp;) _MSL_THROW
    {
    }
#endif
#endif

    pointer address(reference x) const;
    const_pointer address(const_reference x) const;

    pointer allocate(size_type n, allocator&lt;void&gt;::const_pointer hint = 0);
    void deallocate(pointer p, size_type n);
    size_type max_size() const _MSL_THROW;

    void construct(pointer p, const T&amp; val);
    void destroy(pointer p);
};

template &lt;class T&gt;
inline
allocator&lt;T&gt;::allocator() _MSL_THROW
{
}

#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE
    template &lt;class T&gt;
    template &lt;class U&gt;
    inline
    allocator&lt;T&gt;::allocator(const allocator&lt;U&gt;&amp;) _MSL_THROW
    {
    }
#endif
#endif

template &lt;class T&gt;
inline
typename allocator&lt;T&gt;::pointer
allocator&lt;T&gt;::address(reference x) const
{
    return &amp;x;
}

template &lt;class T&gt;
inline
typename allocator&lt;T&gt;::const_pointer
allocator&lt;T&gt;::address(const_reference x) const
{
    return &amp;x;
}

template &lt;class T&gt;
inline
typename allocator&lt;T&gt;::pointer
allocator&lt;T&gt;::allocate(size_type n, allocator&lt;void&gt;::const_pointer)
{
#ifndef _MSL_NO_EXCEPTIONS
    return static_cast&lt;pointer&gt;(operator new(n * sizeof(T)));
#else
    pointer p = static_cast&lt;pointer&gt;(operator new(n * sizeof(T)));
    if (p == 0)
        __msl_error(&quot;Memory allocation failure&quot;);
    return p;
#endif
}

template &lt;class T&gt;
inline
void
allocator&lt;T&gt;::deallocate(pointer p, size_type)
{
    operator delete(p);
}

template &lt;class T&gt;
inline
typename allocator&lt;T&gt;::size_type
allocator&lt;T&gt;::max_size() const _MSL_THROW
{
    return numeric_limits&lt;size_type&gt;::max() / sizeof(T);
}

template &lt;class T&gt;
inline
void
allocator&lt;T&gt;::construct(pointer p, const T&amp; val)
{
    new(p) T(val);
}

template &lt;class T&gt;
inline
void
allocator&lt;T&gt;::destroy(pointer p)
{
    p-&gt;~T();
}

template &lt;class T, class U&gt;
inline
bool
operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) _MSL_THROW
{
    return true;
}

template &lt;class T, class U&gt;
inline
bool
operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) _MSL_THROW
{
    return false;
}

//  lib.storage.iterator, raw storage iterator:

template &lt;class OutputIterator, class T&gt;
class raw_storage_iterator
    : public iterator&lt;output_iterator_tag, void, void, void, void&gt;
{
public:
    explicit raw_storage_iterator(OutputIterator x);

    raw_storage_iterator&amp; operator*();
    raw_storage_iterator&amp; operator=(const T&amp; element);
    raw_storage_iterator&amp; operator++();
    raw_storage_iterator  operator++(int);
private:
    OutputIterator x_;
};

template &lt;class OutputIterator, class T&gt;
inline
raw_storage_iterator&lt;OutputIterator, T&gt;::raw_storage_iterator(OutputIterator x)
    : x_(x)
{
}

template &lt;class OutputIterator, class T&gt;
inline
raw_storage_iterator&lt;OutputIterator, T&gt;&amp;
raw_storage_iterator&lt;OutputIterator, T&gt;::operator*()
{
    return *this;
}

template &lt;class OutputIterator, class T&gt;
inline
raw_storage_iterator&lt;OutputIterator, T&gt;&amp;
raw_storage_iterator&lt;OutputIterator, T&gt;::operator=(const T&amp; element)
{
    new(&amp;*x_) T(element);
}

template &lt;class OutputIterator, class T&gt;
inline
raw_storage_iterator&lt;OutputIterator, T&gt;&amp;
raw_storage_iterator&lt;OutputIterator, T&gt;::operator++()
{
    ++x_;
    return *this;
}

template &lt;class OutputIterator, class T&gt;
inline
raw_storage_iterator&lt;OutputIterator, T&gt;
raw_storage_iterator&lt;OutputIterator, T&gt;::operator++(int)
{
    raw_storage_iterator tmp(*this);
    ++x_;
    return return tmp;
}

//  lib.temporary.buffer, temporary buffers:
template &lt;class T&gt;
pair&lt;T*, ptrdiff_t&gt;
get_temporary_buffer(ptrdiff_t n)
{
    pair&lt;T*, ptrdiff_t&gt; result(0, 0);
    while (n &gt; 0)
    {
        result.first = reinterpret_cast&lt;T*&gt;(new(nothrow) char [sizeof(T)*n]);
        if (result.first != 0)
        {
            result.second = n;
            break;
        }
        else
            n /= 2;
    }
    return result;
}

template &lt;class T&gt;
inline
void
return_temporary_buffer(T* p)
{
    delete [] reinterpret_cast&lt;char*&gt;(p);
}

// hh 980601  Added non-standard class.  This facilitates use of
//            get_temporary_buffer in a exception-safe manner.
//            Used in &lt;algorithm&gt;
template &lt;class T&gt;
class _TempVec
{
public:
    // types:
    typedef T&amp;                                     reference;
//  typedef const T&amp;                               const_reference;
    class                                          iterator;
//  class                                          const_iterator;
    typedef size_t                                 size_type;
    typedef ptrdiff_t                              difference_type;
    typedef T                                      value_type;
    typedef T*                                     pointer;
//  typedef const T*                               const_pointer;
//  typedef _STD::reverse_iterator&lt;iterator&gt;       reverse_iterator;
//  typedef _STD::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;

    class proxy
    {
    public:
        reference operator = (const T&amp; rhs) const
        {
            if (cur_ - vec_-&gt;data_ &lt; vec_-&gt;size_)
                *cur_ = rhs;
            else
            {
                new (cur_) T(rhs);
                ++vec_-&gt;size_;
            }
            return *cur_;
        }

        operator const T&amp; () const {return *cur_;}

        friend bool operator == (const proxy&amp; x, const proxy&amp; y) {return *x.cur_ == *y.cur_;}
        friend bool operator == (const proxy&amp; x, const T&amp; y) {return *x.cur_ == y;}
        friend bool operator == (const T&amp; x, const proxy&amp; y) {return x == *y.cur_;}

        friend bool operator != (const proxy&amp; x, const proxy&amp; y) {return *x.cur_ != *y.cur_;}
        friend bool operator != (const proxy&amp; x, const T&amp; y) {return *x.cur_ != y;}
        friend bool operator != (const T&amp; x, const proxy&amp; y) {return x != *y.cur_;}

        friend bool operator &lt; (const proxy&amp; x, const proxy&amp; y) {return *x.cur_ &lt; *y.cur_;}
        friend bool operator &lt; (const proxy&amp; x, const T&amp; y) {return *x.cur_ &lt; y;}
        friend bool operator &lt; (const T&amp; x, const proxy&amp; y) {return x &lt; *y.cur_;}

        friend bool operator &lt;= (const proxy&amp; x, const proxy&amp; y) {return *x.cur_ &lt;= *y.cur_;}
        friend bool operator &lt;= (const proxy&amp; x, const T&amp; y) {return *x.cur_ &lt;= y;}
        friend bool operator &lt;= (const T&amp; x, const proxy&amp; y) {return x &lt;= *y.cur_;}

        friend bool operator &gt; (const proxy&amp; x, const proxy&amp; y) {return *x.cur_ &gt; *y.cur_;}
        friend bool operator &gt; (const proxy&amp; x, const T&amp; y) {return *x.cur_ &gt; y;}
        friend bool operator &gt; (const T&amp; x, const proxy&amp; y) {return x &gt; *y.cur_;}

        friend bool operator &gt;= (const proxy&amp; x, const proxy&amp; y) {return *x.cur_ &gt;= *y.cur_;}
        friend bool operator &gt;= (const proxy&amp; x, const T&amp; y) {return *x.cur_ &gt;= y;}
        friend bool operator &gt;= (const T&amp; x, const proxy&amp; y) {return x &gt;= *y.cur_;}

    private:
        T* cur_;
        _TempVec&lt;T&gt;* vec_;

        proxy(T* cur, _TempVec&lt;T&gt;* vec) : cur_(cur), vec_(vec) {}

        friend class iterator;
    };
    friend class proxy;

    class iterator
        : public _STD::iterator&lt;random_access_iterator_tag, T, ptrdiff_t, T*, T&amp;&gt;
    {
    public:
        iterator() {}
        proxy operator * () const {return proxy(cur_, vec_);}
        pointer operator -&gt; () const {return cur_;}
        iterator&amp; operator ++ () {++cur_; return *this;}
        iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}
        iterator&amp; operator -- () {--cur_; return *this;}
        iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}
        iterator&amp; operator += (difference_type n) {cur_ += n; return *this;}
        iterator operator + (difference_type n) const {return iterator(*this) += n;}
        iterator&amp; operator -= (difference_type n) {cur_ -= n; return *this;}
        iterator operator - (difference_type n) const {return iterator(*this) -= n;}
        difference_type operator - (const iterator&amp; rhs) const {return difference_type(cur_ - rhs.cur_);}
        proxy operator [] (size_type i) const {iterator tmp(*this); tmp += difference_type(i); return *tmp;}
        friend bool operator ==(const iterator&amp; x, const iterator&amp; y) {return x.cur_ == y.cur_;}
        friend bool operator !=(const iterator&amp; x, const iterator&amp; y) {return x.cur_ != y.cur_;}
        friend bool operator &lt; (const iterator&amp; x, const iterator&amp; y) {return x.cur_ &lt; y.cur_;}
        friend bool operator &lt;=(const iterator&amp; x, const iterator&amp; y) {return x.cur_ &lt;= y.cur_;}
        friend bool operator &gt; (const iterator&amp; x, const iterator&amp; y) {return x.cur_ &gt;  y.cur_;}
        friend bool operator &gt;=(const iterator&amp; x, const iterator&amp; y) {return x.cur_ &gt;= y.cur_;}
        friend iterator operator + (difference_type n, const iterator&amp; rhs)
            {return iterator(rhs) += n;}
    private:
        pointer cur_;
        _TempVec&lt;T&gt;* vec_;

        iterator(T* cur, _TempVec&lt;T&gt;* vec) : cur_(cur), vec_(vec) {}

        friend class _TempVec&lt;T&gt;;
    };

    _TempVec(ptrdiff_t cap);
    ~_TempVec();
    iterator begin();
    iterator end();
    ptrdiff_t size() const;
    ptrdiff_t capacity() const;
private:
    ptrdiff_t cap_;
    ptrdiff_t size_;
    T* data_;

    _TempVec(const _TempVec&amp;);             // Not defined
    _TempVec&amp; operator=(const _TempVec&amp;);  // Not defined
};

template &lt;class T&gt;
inline
_TempVec&lt;T&gt;::_TempVec(ptrdiff_t cap)
{
    pair&lt;T*, ptrdiff_t&gt; buf = get_temporary_buffer&lt;T&gt;(cap);
    data_ = buf.first;
    cap_ = buf.second;
    size_ = 0;
}

template &lt;class T&gt;
inline
_TempVec&lt;T&gt;::~_TempVec()
{
    __destroy(data_, data_ + size_);
    return_temporary_buffer(data_);
}

template &lt;class T&gt;
inline
typename _TempVec&lt;T&gt;::iterator
_TempVec&lt;T&gt;::begin()
{
    return iterator(data_, this);
}

template &lt;class T&gt;
inline
typename _TempVec&lt;T&gt;::iterator
_TempVec&lt;T&gt;::end()
{
    return iterator(data_ + cap_, this);
}

template &lt;class T&gt;
inline
ptrdiff_t
_TempVec&lt;T&gt;::size() const
{
    return size_;
}

template &lt;class T&gt;
inline
ptrdiff_t
_TempVec&lt;T&gt;::capacity() const
{
    return cap_;
}

//  lib.specialized.algorithms, specialized algorithms:

// uninitialized_copy

template &lt;class InputIterator, class ForwardIterator&gt;
inline
ForwardIterator
uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result)
{
    ForwardIterator save = result;
#ifndef _MSL_NO_EXCEPTIONS
    try
    {
#endif
        for (; first != last; ++result, ++first)
            new (&amp;*result) typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
#ifndef _MSL_NO_EXCEPTIONS
    }
    catch (...)
    {
        __destroy(save, result);
        throw;
    }
#endif
    return result;
}

template &lt;&gt;
inline
char*
uninitialized_copy(char* first, char* last, char* result)
{
    size_t len = static_cast&lt;size_t&gt;(last - first);
    memcpy(result, first, len);
    return result + len;
}

#ifndef _MSL_NO_WCHART

    template &lt;&gt;
    inline
    wchar_t*
    uninitialized_copy(wchar_t* first, wchar_t* last, wchar_t* result)
    {
        size_t len = static_cast&lt;size_t&gt;(last - first);
        wmemcpy(result, first, len);
        return result + len;
    }

#endif

// uninitialized_fill

template &lt;class ForwardIterator, class T&gt;
inline
void
uninitialized_fill(ForwardIterator first, ForwardIterator last, const T&amp; x)
{
    ForwardIterator save = first;
#ifndef _MSL_NO_EXCEPTIONS
    try
    {
#endif
        for (; first != last; ++first)
            new (&amp;*first) typename iterator_traits&lt;ForwardIterator&gt;::value_type(x);
#ifndef _MSL_NO_EXCEPTIONS
    }
    catch (...)
    {
        __destroy(save, first);
        throw;
    }
#endif
}

template &lt;&gt;
inline
void
uninitialized_fill(char* first, char* last, const char&amp; x)
{
    memset(first, x, static_cast&lt;size_t&gt;(last - first));
}

#ifndef _MSL_NO_WCHART

    template &lt;&gt;
    inline
    void
    uninitialized_fill(wchar_t* first, wchar_t* last, const wchar_t&amp; x)
    {
        wmemset(first, x, static_cast&lt;size_t&gt;(last - first));
    }

#endif

// uninitialized_fill_n

template &lt;class ForwardIterator, class Size, class T&gt;
inline
void
uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x)
{
    ForwardIterator save = first;
#ifndef _MSL_NO_EXCEPTIONS
    try
    {
#endif
        for (; n--; ++first)
            new (&amp;*first) typename iterator_traits&lt;ForwardIterator&gt;::value_type(x);
#ifndef _MSL_NO_EXCEPTIONS
    }
    catch (...)
    {
        __destroy(save, first);
        throw;
    }
#endif
}

template &lt;&gt;
inline
void
uninitialized_fill_n(char* first, size_t n, const char&amp; x)
{
    memset(first, x, n);
}

#ifndef _MSL_NO_WCHART

    template &lt;&gt;
    inline
    void
    uninitialized_fill_n(wchar_t* first, size_t n, const wchar_t&amp; x)
    {
        wmemset(first, x, n);
    }

#endif

//  lib.auto.ptr, pointers:

#ifndef _MSL_USE_AUTO_PTR_96

// hh 980103 Nov. '97 version of auto_ptr added
// hh 980805 member template operators not supported yet.

template&lt;class X&gt; class auto_ptr;

template &lt;class Y&gt;
struct auto_ptr_ref
{
    auto_ptr&lt;Y&gt;&amp; p_;
    auto_ptr_ref(const auto_ptr&lt;Y&gt;&amp; a);
};

template &lt;class Y&gt;
inline
auto_ptr_ref&lt;Y&gt;::auto_ptr_ref(const auto_ptr&lt;Y&gt;&amp; a)
    : p_(const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(a))
{
}

template&lt;class X&gt;
class auto_ptr
{
public:
    typedef X element_type;

    //  lib.auto.ptr.cons construct/copy/destroy:
    explicit auto_ptr(X* p = 0) _MSL_THROW;
    auto_ptr(auto_ptr&amp; a) _MSL_THROW;
#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE
    template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW;
#else
    template&lt;class Y&gt;
    inline
    auto_ptr(auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW
        : ptr_(a.release())
    {
    }
#endif
#endif
    auto_ptr&amp; operator=(auto_ptr&amp; a) _MSL_THROW;
#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE
    template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW;
#else
    template&lt;class Y&gt;
    inline
    auto_ptr&amp;
    operator=(auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW
    {
        reset(a.release());
        return *this;
    }
#endif
#endif
    ~auto_ptr() _MSL_THROW;

    //  lib.auto.ptr.members members:
    X&amp; operator*() const _MSL_THROW;
    X* operator-&gt;() const _MSL_THROW;
    X* get() const _MSL_THROW;
    X* release() _MSL_THROW;
    void reset(X* p = 0) _MSL_THROW;

    //  lib.auto.ptr.conv conversions:
    auto_ptr(auto_ptr_ref&lt;X&gt; r) _MSL_THROW;
    auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) _MSL_THROW;
#if !defined (_MSL_NO_MEMBER_TEMPLATE) &amp;&amp; __MWERKS__ &gt; 0x2400
    template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() _MSL_THROW;
    template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() _MSL_THROW;
#endif
private:
    X* ptr_;
};

template&lt;class X&gt;
inline
X*
auto_ptr&lt;X&gt;::release() _MSL_THROW
{
    X* tmp = ptr_;
    ptr_ = 0;
    return tmp;
}

template&lt;class X&gt;
inline
void
auto_ptr&lt;X&gt;::reset(X* p) _MSL_THROW
{
    if (ptr_)
        delete ptr_;
    ptr_ = p;
}

template&lt;class X&gt;
inline
auto_ptr&lt;X&gt;::auto_ptr(X* p) _MSL_THROW
    : ptr_(p)
{
}

template&lt;class X&gt;
inline
auto_ptr&lt;X&gt;::auto_ptr(auto_ptr&amp; a) _MSL_THROW
    : ptr_(a.release())
{
}

#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE

    template&lt;class X&gt;
    template&lt;class Y&gt;
    inline
    auto_ptr&lt;X&gt;::auto_ptr(auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW
        : ptr_(a.release())
    {
    }

#endif
#endif

template&lt;class X&gt;
inline
auto_ptr&lt;X&gt;&amp;
auto_ptr&lt;X&gt;::operator=(auto_ptr&amp; a) _MSL_THROW
{
    reset(a.release());
    return *this;
}

#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE

    template&lt;class X&gt;
    template&lt;class Y&gt;
    inline
    auto_ptr&lt;X&gt;&amp;
    auto_ptr&lt;X&gt;::operator=(auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW
    {
        reset(a.release());
        return *this;
    }

#endif
#endif

template&lt;class X&gt;
inline
auto_ptr&lt;X&gt;::~auto_ptr() _MSL_THROW
{
    delete ptr_;
}

template&lt;class X&gt;
inline
X&amp;
auto_ptr&lt;X&gt;::operator*() const _MSL_THROW
{
    return *ptr_;
}

template&lt;class X&gt;
inline
X*
auto_ptr&lt;X&gt;::operator-&gt;() const _MSL_THROW
{
    return ptr_;
}

template&lt;class X&gt;
inline
X*
auto_ptr&lt;X&gt;::get() const _MSL_THROW
{
    return ptr_;
}

template&lt;class X&gt;
inline
auto_ptr&lt;X&gt;::auto_ptr(auto_ptr_ref&lt;X&gt; r) _MSL_THROW
    : ptr_(r.p_.release())
{
}

template&lt;class X&gt;
inline
auto_ptr&lt;X&gt;&amp;
auto_ptr&lt;X&gt;::operator=(auto_ptr_ref&lt;X&gt; r) _MSL_THROW
{
    reset(r.p_.release());
    return *this;
}

#if !defined (_MSL_NO_MEMBER_TEMPLATE) &amp;&amp; __MWERKS__ &gt; 0x2400

    template&lt;class X&gt;
    template&lt;class Y&gt;
    inline
    auto_ptr&lt;X&gt;::operator auto_ptr_ref&lt;Y&gt;() _MSL_THROW
    {
        return *this;
    }

    template&lt;class X&gt;
    template&lt;class Y&gt;
    inline
    auto_ptr&lt;X&gt;::operator auto_ptr&lt;Y&gt;() _MSL_THROW
    {
        return auto_ptr&lt;Y&gt;(release());
    }

#endif

#else // _MSL_USE_AUTO_PTR_96

// hh 980103 Dec. '96 version of auto_ptr fixed

template &lt;class X&gt;
class auto_ptr
{
public :
    typedef X   element_type;
    explicit auto_ptr(X* p = 0) _MSL_THROW;
#ifndef _MSL_NO_MEMBER_TEMPLATE
    template &lt;class Y&gt; auto_ptr (const auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW;
    template &lt;class Y&gt; auto_ptr&amp; operator=(const auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW;
#endif
    auto_ptr (const auto_ptr&amp; a) _MSL_THROW;
    auto_ptr&amp; operator=(const auto_ptr&amp; a) _MSL_THROW;
    ~auto_ptr();
    X&amp; operator*() const _MSL_THROW;
    X* operator-&gt;() const _MSL_THROW;
    X* get() const _MSL_THROW;
    X* release() const _MSL_THROW;
    bool owns() const _MSL_THROW;
private:
    X* ptr_;
    mutable bool owns_;
};

template &lt;class X&gt;
inline
bool
auto_ptr&lt;X&gt;::owns() const _MSL_THROW
{
    return owns_;
}

template &lt;class X&gt;
inline
X*
auto_ptr&lt;X&gt;::release() const _MSL_THROW
{ 
    owns_ = false; 
    return ptr_; 
}

template &lt;class X&gt;
inline
auto_ptr&lt;X&gt;::auto_ptr(X* p) _MSL_THROW
    : ptr_(p),
      owns_(p != 0)
{
}

#ifndef _MSL_NO_MEMBER_TEMPLATE

    template &lt;class X&gt;
    template &lt;class Y&gt;
    inline
    auto_ptr&lt;X&gt;::auto_ptr(const auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW
    {      
        owns_ = a.owns(); 
        ptr_ = a.release(); 
    }

    template &lt;class X&gt;
    template &lt;class Y&gt;
    inline
    auto_ptr&lt;X&gt;&amp;
    auto_ptr&lt;X&gt;::operator=(const auto_ptr&lt;Y&gt;&amp; a) _MSL_THROW
    {   
        if (owns_)
            delete ptr_;
        owns_ = a.owns();
        ptr_ = a.release();
        return *this;
    }

#endif

template &lt;class X&gt;
inline
auto_ptr&lt;X&gt;::auto_ptr(const auto_ptr&amp; a) _MSL_THROW 
{ 
    owns_ = a.owns_;
    ptr_ = a.release();
}

// hh 980923 rewrote op=
template &lt;class X&gt;
auto_ptr&lt;X&gt;&amp;
auto_ptr&lt;X&gt;::operator=(const auto_ptr&amp; a) _MSL_THROW
{
    if (this == &amp;a)
        return *this;
    if (ptr_ == a.ptr_)
    {
        owns_ = owns_ || a.owns_;
        ptr_ = a.release();
    }
    else
    {
        if (owns_)
            delete ptr_;
        owns_ = a.owns_;
        ptr_ = a.release();
    }
    return *this;
}

template &lt;class X&gt;
inline
auto_ptr&lt;X&gt;::~auto_ptr()
{
    if (owns_)
        delete ptr_;
}

template &lt;class X&gt;
inline
X&amp;
auto_ptr&lt;X&gt;::operator* () const _MSL_THROW
{
    return *ptr_;
}

template &lt;class X&gt;
inline
X*
auto_ptr&lt;X&gt;::operator-&gt; () const _MSL_THROW
{
    return ptr_;
}

template &lt;class X&gt;
inline
X*
auto_ptr&lt;X&gt;::get() const _MSL_THROW
{
    return ptr_;
}

#endif // _MSL_USE_AUTO_PTR_96

// Warning, non-standard
// Credit:  Nathan C. Myers

template &lt;class _Base, class _Member&gt;
struct _EmptyMemberOpt
    : public _Base
{
    _EmptyMemberOpt();
    _EmptyMemberOpt(_Base const&amp; __b);
    _EmptyMemberOpt(_Base const&amp; __b, _Member const&amp; __mem);

    _Member m_;
};

template &lt;class _Base, class _Member&gt;
inline
_EmptyMemberOpt&lt;_Base, _Member&gt;::_EmptyMemberOpt() 
    : _Base(_Base()),
      m_(_Member())
{
}

template &lt;class _Base, class _Member&gt;
inline
_EmptyMemberOpt&lt;_Base, _Member&gt;::_EmptyMemberOpt(_Base const&amp; __b) 
    : _Base(__b),
      m_(_Member())
{
}

template &lt;class _Base, class _Member&gt;
inline
_EmptyMemberOpt&lt;_Base, _Member&gt;::_EmptyMemberOpt(_Base const&amp; __b, _Member const&amp; __mem) 
    : _Base(__b),
      m_(__mem)
{
}

#ifndef _MSL_NO_CPP_NAMESPACE
    } // namespace std
#endif

#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _MEMORY

// hh 971220 fixed MOD_INCLUDE and MOD_C_INCLUDE
// hh 971222 made include guards standard
// hh 971222 added alignment wrapper
// hh 971227 silence unused warning
// hh 971227 removed unused argument from deallocate
// hh 971230 added RC_INVOKED wrapper
// hh 980103 fixed Dec. '96 version of auto_ptr
// hh 980103 added Nov. '97 version of auto_ptr
// hh 980106 removed #include &lt;stdexcept&gt;
//           &lt;memory&gt; can not throw a stdexecpt because it can not process strings.
// hh 980106 removed null pointer checks from allocate::construct and destroy
// hh 980522  Rewrote get/return_temporary_buffer because of concerns about
//            multi-threading.
// hh 980730 added (char*) cast to return_temporary_buffer
// hh 980805 member template operators not supported yet.
//           modified auto_ptr '97 to pre-member template functionality
// hh 980902 #ifdef'd out exception code when ndef MSIPL_EXCEPT
// hh 980923 fixed bug in the '96 auto_ptr::op=
// hh 981220 Added typename to appropriate return types
// hh 990315 Split destroy(first, last) into two methods to help compiler optimize
//           away empty loops.
// hh 990503 Rewrote.
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>