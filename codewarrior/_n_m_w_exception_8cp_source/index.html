<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File NMWException.cp - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-nmwexceptioncp">File NMWException.cp</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_e69745e3285a8d4f155d29d88e1a7b6b/"><strong>Runtime</strong></a> <strong>&gt;</strong> <a href="../dir_1789e36d750963f536ec280b459db2bf/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../_n_m_w_exception_8cp/"><strong>NMWException.cp</strong></a></p>
<p><a href="../_n_m_w_exception_8cp/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/************************************************************************/
/*  Project...: Standard C++ Library                                    */
/*  Name......: NMWException.cp                                         */
/*  Purpose...: portable exception handling                             */
/*  Copyright.: Copyright 1993-1997 Metrowerks, Inc.                    */
/************************************************************************/

#if __MWERKS__ &amp;&amp; !__embedded_cplusplus
#pragma exceptions on
#endif

#ifdef __MC68K__
#pragma far_data off
#endif

#define __NOSTRING__    //  do not include &lt;string&gt;

//#include &lt;Types.h&gt;    // hh 971215 commented out per John McEnerney's instructions
#include &lt;stdlib.h&gt;
#include &lt;MWCPlusLib.h&gt;
#if !__embedded_cplusplus
#include &lt;exception.h&gt;
#include &quot;NMWException.h&quot;
#endif

#ifdef _MSL_USING_NAMESPACE      // hh 971207 Added namespace support
    namespace std {
#endif

#if !__embedded_cplusplus

static void dthandler()     { abort(); };           //  default terminate handler function
static terminate_handler    thandler = dthandler;   //  pointer to terminate handler function
static void duhandler()     { terminate(); };       //  default unexpected handler function
static unexpected_handler   uhandler = duhandler;   //  pointer to unexpected handler function

/************************************************************************/
/*  Purpose..:  Set a terminate handler function                        */
/*  Input....:  pointer to terminate handler function                   */
/*  Return...:  ---                                                     */
/************************************************************************/
extern terminate_handler set_terminate(terminate_handler handler) throw()  // hh 980102 added exception specific
{
    terminate_handler old=thandler; thandler=handler; return old;
}

/************************************************************************/
/*  Purpose..:  Terminate exception handling                            */
/*  Input....:  ---                                                     */
/*  Return...:  --- (shall not return to caller)                        */
/************************************************************************/
extern void terminate()
{
    thandler();
}

/************************************************************************/
/*  Purpose..:  Set an unexpected handler function                      */
/*  Input....:  pointer to unexpected handler function                  */
/*  Return...:  ---                                                     */
/************************************************************************/
extern unexpected_handler set_unexpected(unexpected_handler handler) throw()  // hh 980102 added exception specific
{
    unexpected_handler old=uhandler; uhandler=handler; return old;
}

/************************************************************************/
/*  Purpose..:  Handle unexpected exception                             */
/*  Input....:  ---                                                     */
/*  Return...:  --- (shall not return to caller)                        */
/************************************************************************/
extern void unexpected()
{
    uhandler();
}

#endif /* !__embedded_cplusplus */

#ifdef _MSL_USING_NAMESPACE
    }
#endif

/************************************************************************/
/*  Purpose..:  Register a global object for later destruction          */
/*  Input....:  pointer to global object                                */
/*  Input....:  pointer to destructor function                          */
/*  Input....:  pointer to global registration structure                */
/*  Return...:  pointer to global object (pass thru)                    */
/************************************************************************/
#if !defined(__POWERPC__) &amp;&amp; !defined(__CFM68K__)       //  only needed for classic 68K ...

extern void *__register_global_object(void *object,void *destructor,void *regmem)
{
    ((DestructorChain *)regmem)-&gt;next=__global_destructor_chain;
    ((DestructorChain *)regmem)-&gt;destructor=destructor;
    ((DestructorChain *)regmem)-&gt;object=object;
    __global_destructor_chain=(DestructorChain *)regmem;

    return object;
}

#endif

/************************************************************************/
/* Purpose..: Compare a throw and a catch type                          */
/* Input....: pointer to throw type                                     */
/* Input....: pointer to catch type (0L: catch(...)                     */
/* Return...: true: can catch; false: cannot catch                      */
/************************************************************************/
extern char __throw_catch_compare(const char *throwtype,const char *catchtype,long *offset_result)
{
    const char  *cptr1,*cptr2;

    *offset_result=0;   
    if((cptr2=catchtype)==0)
    {   //  catch(...)
        return true;
    }
    cptr1=throwtype;

    if(*cptr2=='P')
    {   //  catch(cv T *)
        cptr2++;
        if(*cptr2=='C') cptr2++;
        if(*cptr2=='V') cptr2++;
        if(*cptr2=='v')
        {   //  catch(cv void *)
            if(*cptr1=='P' || *cptr1=='*')
            {   //  throw T*;
                return true;
            }
        }
        cptr2=catchtype;
    }

    switch(*cptr1)
    {   //  class pointer/reference throw
    case '*':
    case '!':
        if(*cptr1++!=*cptr2++) return false;
        for(;;)
        {   //  class name compare loop
            if(*cptr1==*cptr2++)
            {
                if(*cptr1++=='!')
                {   //  class match found / get offset
                    long offset;

                    for(offset=0; *cptr1!='!';) offset=offset*10+*cptr1++-'0';
                    *offset_result=offset; return true;
                }
            }
            else
            {
                while(*cptr1++!='!') ;          //  skip class name
                while(*cptr1++!='!') ;          //  skip offset
                if(*cptr1==0) return false;     //  no more class names =&gt; no match
                cptr2=catchtype+1;              //  retry with next class name
            }
        }
        return false;
    }

    while((*cptr1=='P' || *cptr1=='R') &amp;&amp; *cptr1==*cptr2)
    {   //  pointer/reference catch =&gt; match cv-qualifiers
        cptr1++; cptr2++;
        if(*cptr2=='C')
        {   //  ignore 'const' in throw type
            if(*cptr1=='C') cptr1++;
            cptr2++;
        }
        if(*cptr1=='C') return false;   //  throw type is more cv-qualified

        if(*cptr2=='V')
        {   //  ignore 'volatile' in throw type
            if(*cptr1=='V') cptr1++;
            cptr2++;
        }
        if(*cptr1=='V') return false;   //  throw type is more cv-qualified
    }

    //  plain type throw catch
    for(; *cptr1==*cptr2; cptr1++,cptr2++) if(*cptr1==0) return true;
    return false;
}

#if defined(__MC68K__)  

/************************************************************************/
/*  Purpose..:  Initialize a new allocated array of objects             */
/*  Input....:  pointer to allocated memory (+8 bytes) (0L: error)      */
/*  Input....:  pointer to default constructor function (or 0L)         */
/*  Input....:  pointer to destructor function (or 0L)                  */
/*  Input....:  size of one array element                               */
/*  Input....:  number of array elements                                */
/*  Return...:  pointer to first object in array                        */
/************************************************************************/
extern void *__construct_new_array(void *block,ConstructorDestructor ctor,ConstructorDestructor dtor_arg,size_t size,size_t n)
{
    char    *ptr;

    if((ptr=(char *)block)!=0L)
    {
        //  store number of allocated objects and size of one object at the beginnig of the allocated block
        *(size_t *)ptr=size;
        *(size_t *)(ptr+sizeof(size_t))=n;
        ptr+=sizeof(size_t)*2;

        if(ctor)
        {   //  call constructor to initialize array
            volatile ConstructorDestructor  dtor=dtor_arg;  //  force reference to dtor
            char                            *p;
            size_t                          i;

            #pragma exception_arrayinit
            //  this #pragma adds partial array construction exception action (ptr,dtor,size,i)

            for(i=0,p=ptr; i&lt;n; i++,p+=size)
            {
                CTORCALL_COMPLETE(ctor,p);
            }
        }
    }
    return ptr; //  return pointer to first object;
}

/************************************************************************/
/*  Purpose..:  Construct an array of objects                           */
/*  Input....:  pointer to array memory                                 */
/*  Input....:  pointer to default constructor function                 */
/*  Input....:  pointer to destructor function (or 0L)                  */
/*  Input....:  size of one array element                               */
/*  Input....:  number of array elements                                */
/*  Return...:  ---                                                     */
/************************************************************************/
extern void __construct_array(void *ptr,ConstructorDestructor ctor,ConstructorDestructor dtor_arg,size_t size,size_t n)
{
    volatile ConstructorDestructor  dtor=dtor_arg;  //  force reference to dtor
    char                            *p;
    size_t                          i;

    #pragma exception_arrayinit
    //  this #pragma adds partial array construction exception action (ptr,dtor,size,i)

    for(i=0,p=(char *)ptr; i&lt;n; i++,p+=size)
    {
        CTORCALL_COMPLETE(ctor,p);
    }
}

#else

//  class __partial_array_destructor
//
//      This class is used to guarantee correct destruction of partially
//      constructed arrays if an exception is thrown from an array-element constructor.
//      We use the members of this class to keep track of the partially-constructed
//      state of the array. If the destructor for this class is called and the
//      array was not fully-constructed, we must have thrown an exception, so we
//      destroy each fully-constructed element of the array in reverse order.

class __partial_array_destructor {
private:
    void*                   p;      //  pointer to start of array being constructed
    size_t                  size;   //  size of each array element
    size_t                  n;      //  # of elements being constructed
    ConstructorDestructor   dtor;   //  pointer to destructor for elements or 0
public:
    size_t                  i;      //  current element being constructed

    __partial_array_destructor(void* array, size_t elementsize, size_t nelements, ConstructorDestructor destructor)
    {
        p=array; size=elementsize; n=nelements; dtor=destructor; i=n;
    }

    ~__partial_array_destructor()
    {
        char *ptr;

        if(i&lt;n &amp;&amp; dtor)
        {
            for(ptr=(char *)p+size*i; i&gt;0; i--)
            {
                ptr-=size;
                DTORCALL_COMPLETE(dtor,ptr);
            }
        }
    }
};

/************************************************************************/
/*  Purpose..:  Initialize a new allocated array of objects             */
/*  Input....:  pointer to allocated memory (+8 bytes) (0L: error)      */
/*  Input....:  pointer to default constructor function (or 0L)         */
/*  Input....:  pointer to destructor function (or 0L)                  */
/*  Input....:  size of one array element                               */
/*  Input....:  number of array elements                                */
/*  Return...:  pointer to first object in array                        */
/************************************************************************/
extern void *__construct_new_array(void *block,ConstructorDestructor ctor,ConstructorDestructor dtor,size_t size,size_t n)
{
    char    *ptr;

    if((ptr=(char *)block)!=0L)
    {
        //  store number of allocated objects and size of one object at the beginnig of the allocated block
        *(size_t *)ptr=size;
        *(size_t *)(ptr+sizeof(size_t))=n;
        ptr+=sizeof(size_t)*2;

        if(ctor)
        {   //  call constructor to initialize array
            __partial_array_destructor pad(ptr,size,n,dtor);
            char    *p;

            for(pad.i=0,p=(char *)ptr; pad.i&lt;n; pad.i++,p+=size) CTORCALL_COMPLETE(ctor,p);
        }
    }
    return ptr; //  return pointer to first object;
}

/************************************************************************/
/*  Purpose..:  Construct an array of objects                           */
/*  Input....:  pointer to array memory                                 */
/*  Input....:  pointer to default constructor function                 */
/*  Input....:  pointer to destructor function (or 0L)                  */
/*  Input....:  size of one array element                               */
/*  Input....:  number of array elements                                */
/*  Return...:  ---                                                     */
/************************************************************************/
extern void __construct_array(void *ptr,ConstructorDestructor ctor,ConstructorDestructor dtor,size_t size,size_t n)
{
    __partial_array_destructor pad(ptr,size,n,dtor);
    char    *p;

    for(pad.i=0,p=(char *)ptr; pad.i&lt;n; pad.i++,p+=size) CTORCALL_COMPLETE(ctor,p);
}

#endif

/************************************************************************/
/*  Purpose..:  Destroy an array of objects                             */
/*  Input....:  pointer to array memory                                 */
/*  Input....:  pointer to destructor function                          */
/*  Input....:  size of one object                                      */
/*  Input....:  number of objects                                       */
/*  Return...:  ---                                                     */
/************************************************************************/
extern void __destroy_arr(void *block,ConstructorDestructor dtor,size_t size,size_t n)
{
    char    *p;

    for(p=(char *)block+size*n; n&gt;0; n--)
    {
        p-=size;
        DTORCALL_COMPLETE(dtor,p);
    }
}

/************************************************************************/
/*  Purpose..:  Delete an array of objects                              */
/*  Input....:  pointer to first object (can be NULL)                   */
/*  Input....:  pointer to destructor function                          */
/*  Return...:  ---                                                     */
/************************************************************************/
extern void __destroy_new_array(void *block,ConstructorDestructor dtor)
{
    if(block)
    {
        if(dtor)
        {
            size_t  i,objects,objectsize;
            char    *p;

            objectsize=*(size_t *)((char *)block-2*sizeof(size_t));
            objects=*(size_t *)((char *)block-sizeof(size_t));
            p=(char *)block+objectsize*objects;
            for(i=0; i&lt;objects; i++)
            {
                p-=objectsize;
                DTORCALL_COMPLETE(dtor,p);
            }
        }
        #if __MWERKS__&gt;=0x2020
        ::operator delete[] ((char *)block-2*sizeof(size_t));
        #else
        ::operator delete ((char *)block-2*sizeof(size_t));
        #endif
    }
}

/************************************************************************/
/*  Purpose..:  Destroy a new allocated array of objects                */
/*  Input....:  pointer to first object (can be NULL)                   */
/*  Input....:  pointer to destructor function (not NULL)               */
/*  Return...:  pointer to complete array block                         */
/************************************************************************/
extern void *__destroy_new_array2(void *block,ConstructorDestructor dtor)
{
    size_t  i,objects,objectsize;
    char    *p;

    if(block==NULL) return NULL;

    if(dtor)
    {   //  destroy array members
        objectsize=*(size_t *)((char *)block-2*sizeof(size_t));
        objects=*(size_t *)((char *)block-sizeof(size_t));
        p=(char *)block+objectsize*objects;
        for(i=0; i&lt;objects; i++)
        {
            p-=objectsize;
            DTORCALL_COMPLETE(dtor,p);
        }
    }

    //  return pointer to complete array block
    return (char *)block-2*sizeof(size_t);
}

// hh 971207 Added namespace support
// hh 971215 commented out &lt;Types.h&gt; per John McEnerney's instructions
// hh 980102 added exception specific to set_terminate and set_unexpected
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>