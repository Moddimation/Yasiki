<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File vector - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-vector">File vector</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_1d8bcf55c9e1564519df8a05b1def2d1/"><strong>MSL_C++</strong></a> <strong>&gt;</strong> <a href="../dir_fc42de24ef3c14a5dea3aca327bd2ec9/"><strong>MSL_Common</strong></a> <strong>&gt;</strong> <a href="../dir_f262df31fb8e04d575b9a3aa2e30ecf8/"><strong>Include</strong></a> <strong>&gt;</strong> <a href="../vector/"><strong>vector</strong></a></p>
<p><a href="../vector/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/*  Metrowerks Standard Library  */

/*  $Date: 1999/12/09 17:59:47 $ 
 *  $Revision: 1.16.4.1 $ 
 *  $NoKeywords: $ 
 *
 *      Portions Copyright 1995-1999 Metrowerks, Inc.
 *      All rights reserved.
 */

/**
 **  vector
 **/

#ifndef _VECTOR
#define _VECTOR

#include &lt;mslconfig&gt;

#include &lt;climits&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;new&gt;
#include &lt;stdexcept&gt;

#ifndef RC_INVOKED

#pragma options align=native
#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
    namespace std {
#endif

template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
class vector
{
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;bool b&gt; struct chooser {};
    #endif
public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef typename Allocator::pointer           iterator;
    typedef typename Allocator::const_pointer     const_iterator;
    typedef typename Allocator::size_type         size_type;
    typedef typename Allocator::difference_type   difference_type;
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef _STD::reverse_iterator&lt;iterator&gt;       reverse_iterator;
    typedef _STD::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
    // _lib.vector.cons_ construct/copy/destroy:
    explicit vector(const Allocator&amp; = Allocator());
    explicit vector(size_type n, const T&amp; value = T(), const Allocator&amp; = Allocator());
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;class InputIterator&gt;
            inline
            vector(InputIterator first, InputIterator last, const Allocator&amp; a = Allocator())
                : alloc_(a),
                  size_(0),
                  data_(0)
            {
                choose_init(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
    #else
            vector(const_iterator first, const_iterator last, const Allocator&amp; = Allocator());
    #endif
    vector(const vector&lt;T,Allocator&gt;&amp; x);
    ~vector();
    vector&lt;T,Allocator&gt;&amp; operator=(const vector&lt;T,Allocator&gt;&amp; x);
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;class InputIterator&gt;
            inline
            void assign(InputIterator first, InputIterator last)
            {
                choose_assign(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
    #else
        void assign(const_iterator first, const_iterator last);
    #endif
    void assign(size_type n, const T&amp; u);
    allocator_type get_allocator() const;
    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;
    // _lib.vector.capacity_ capacity:
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, T c = T());
    size_type capacity() const;
    bool      empty() const;
    void      reserve(size_type n);

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;
    // _lib.vector.modifiers_ modifiers:
    void push_back(const T&amp; x);
    void pop_back();
    iterator insert(iterator position, const T&amp; x);
    void     insert(iterator position, size_type n, const T&amp; x);
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;class InputIterator&gt;
            inline
            void insert(iterator position, InputIterator first, InputIterator last)
            {
                choose_insert(position, first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
    #else
        void insert(iterator position, const_iterator first, const_iterator last);
    #endif
    iterator erase(iterator position);
    iterator erase(iterator first, iterator last);
    void     swap(vector&lt;T,Allocator&gt;&amp;);
    void     clear();
private:
    _EmptyMemberOpt&lt;Allocator, size_type&gt; alloc_;  // m_ is capacity
    size_type size_;
    pointer data_;

    #ifndef _MSL_NO_MEMBER_TEMPLATE
        template &lt;class InputIterator&gt;
            inline
            void
            choose_init(InputIterator first, InputIterator last, chooser&lt;true&gt;)
            {
                init(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_init(InputIterator first, InputIterator last, chooser&lt;false&gt;)
            {
                init(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            init(InputIterator first, InputIterator last, input_iterator_tag)
            {
                #ifndef _MSL_NO_EXCEPTIONS
                try
                {
                #endif
                    for (; first != last; ++first)
                        push_back(*first);
                #ifndef _MSL_NO_EXCEPTIONS
                }
                catch (...)
                {
                    tear_down();
                    throw;
                }
                #endif
            }

        template &lt;class ForwardIterator&gt;
            void
            init(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
            {
                size_ = alloc_.m_ = (size_type)distance(first, last);
                if (size_ &gt; max_size())
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;vector::construction length error&quot;);
                    #else
                        __msl_error(&quot;vector::construction length error\n&quot;);
                    #endif
                if (alloc_.m_ &gt; 0)
                {
                    data_ = alloc_.allocate(alloc_.m_);
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        uninitialized_copy(first, last, data_);
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        alloc_.deallocate(data_, alloc_.m_);
                        throw;
                    }
                    #endif
                }
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_assign(InputIterator first, InputIterator last, chooser&lt;true&gt;)
            {
                assign(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_assign(InputIterator first, InputIterator last, chooser&lt;false&gt;)
            {
                do_assign(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            do_assign(InputIterator first, InputIterator last, input_iterator_tag)
            {
                vector temp(first, last, get_allocator());
                const vector&amp; tempr = temp;
                do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
            }

        template &lt;class ForwardIterator&gt;
            void
            do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
            {
                size_type n = (size_type)distance(first, last);
                if (n &gt; max_size())
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;vector::assign length error&quot;);
                    #else
                        __msl_error(&quot;vector::assign length error\n&quot;);
                    #endif
                if (n &lt;= capacity())
                {
                    size_type n1 = min(n, size_);
                    iterator i = begin();
                    iterator e = i + n1;
                    for (; i &lt; e; ++i, ++first)
                        *i = *first;
                    if (n &lt; size_)
                        __destroy(i, end());
                    else if (size_ &lt; n)
                        uninitialized_copy(first, last, i);
                    size_ = n;
                }
                else
                {
                    pointer olddata = data_;
                    data_ = alloc_.allocate(n);
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        uninitialized_copy(first, last, data_);
                        if (olddata != 0)
                        {
                            __destroy(olddata, olddata + size_);
                            alloc_.deallocate(olddata, alloc_.m_);
                        }
                        size_ = alloc_.m_ = n;
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        alloc_.deallocate(data_, n);
                        data_ = olddata;
                        throw;
                    }
                    #endif
                }
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_insert(iterator position, InputIterator first, InputIterator last,
                chooser&lt;true&gt;)
            {
                insert(position, static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_insert(iterator position, InputIterator first, InputIterator last,
                chooser&lt;false&gt;)
            {
                do_insert(position, first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            do_insert(iterator position, InputIterator first, InputIterator last,
                input_iterator_tag)
            {
                vector temp(first, last, get_allocator());
                const vector&amp; tempr = temp;
                do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());
            }

        template &lt;class ForwardIterator&gt;
            void
            do_insert(iterator position, ForwardIterator first, ForwardIterator last,
                forward_iterator_tag)
            {
                size_type n = (size_type)distance(first, last);
                if (n == 0)
                    return;
                size_type ms = max_size();
                if (n &gt; ms || size_ &gt; ms - n)
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;vector::insert length error&quot;);
                    #else
                        __msl_error(&quot;vector::insert length error\n&quot;);
                    #endif
                if (size_ + n &lt;= capacity())
                {
                    size_type n1 = size_type(end() - position);
                    if (n1 &gt; 0)
                    {
                        size_type n2 = min(n, n1);
                        size_type n3 = n &gt; n1 ? n - n1 : 0;
                        uninitialized_copy(data_ + size_ - n2, data_ + size_, data_ + size_ + n3);
                        #ifndef _MSL_NO_EXCEPTIONS
                        try
                        {
                        #endif
                            if (n &lt; n1)
                                copy_backward(position, data_ + size_ - n2,  data_ + size_);
                            iterator e = position + n2;
                            for (; position &lt; e; ++position, ++first)
                                *position = *first;
                            uninitialized_copy(first, last, position);
                        #ifndef _MSL_NO_EXCEPTIONS
                        }
                        catch (...)
                        {
                            __destroy(data_ + size_ + n3, data_ + size_ + n);
                            throw;
                        }
                        #endif
                    }
                    else
                        uninitialized_copy(first, last, position);
                    size_ += n;
                }
                else
                {
                    pointer olddata = data_;
                    size_type newsize = size_ + n;
                    size_type newcap = alloc_.m_;
                    size_type pos = size_type(position - data_);
                    if (newcap == 0)
                        newcap = 1;
                    while (newsize &gt; newcap)
                        newcap *= 2;
                    data_ = alloc_.allocate(newcap);
                    size_type done = 0;
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        if (pos &gt; 0)
                        {
                            uninitialized_copy(olddata, olddata + pos, data_);
                            done = pos;
                        }
                        uninitialized_copy(first, last, data_ + pos);
                        done += n;
                        if (pos &lt; size_)
                            uninitialized_copy(olddata + pos, olddata + size_, data_ + pos + n);
                        if (olddata != 0)
                        {
                            __destroy(olddata, olddata + size_);
                            alloc_.deallocate(olddata, alloc_.m_);
                        }
                        size_ = newsize;
                        alloc_.m_ = newcap;
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        __destroy(data_, data_ + done);
                        alloc_.deallocate(data_, newcap);
                        data_ = olddata;
                        throw;
                    }
                    #endif
                }
            }

    #endif

    void init(size_type n, const T&amp; value);
    void tear_down();
};

template &lt;class T, class Allocator&gt;
bool
operator==(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator!=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator&lt; (const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator&gt; (const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator&gt;=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);

template &lt;class T, class Allocator&gt;
bool
operator&lt;=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y);

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void
swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);

// Implementation

template &lt;class T, class Allocator&gt;
inline
vector&lt;T, Allocator&gt;::vector(const Allocator&amp; a)
    : alloc_(a),
      size_(0),
      data_(0)
{
}

template &lt;class T, class Allocator&gt;
inline
vector&lt;T, Allocator&gt;::vector(size_type n, const T&amp; value, const Allocator&amp; a)
    : alloc_(a),
      size_(0),
      data_(0)
{
    init(n, value);
}     

template &lt;class T, class Allocator&gt;
vector&lt;T, Allocator&gt;::vector(const vector&lt;T,Allocator&gt;&amp; x)
    : alloc_(x.alloc_, x.size_),
      size_(x.size_),
      data_(0)
{
    if (alloc_.m_ &gt; 0)
    {
        data_ = alloc_.allocate(alloc_.m_);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            uninitialized_copy(x.data_, x.data_ + x.size_, data_);
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(data_, alloc_.m_);
            throw;
        }
        #endif
    }
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

    template &lt;class T, class Allocator&gt;
    vector&lt;T, Allocator&gt;::vector(const_iterator first, const_iterator last, const Allocator&amp; a)
        : alloc_(a, size_type(last - first)),
          size_(alloc_.m_),
          data_(0)
    {
        if (alloc_.m_ &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::construction length error&quot;);
            #else
                __msl_error(&quot;vector::construction length error\n&quot;);
            #endif
        if (alloc_.m_ &gt; 0)
        {
            data_ = alloc_.allocate(alloc_.m_);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                uninitialized_copy(first, last, data_);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(data_, alloc_.m_);
                throw;
            }
            #endif
        }
    }

#endif

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::init(size_type n, const T&amp; value)
{
    if (n &gt; max_size())
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;vector::construction length error&quot;);
        #else
            __msl_error(&quot;vector::construction length error\n&quot;);
        #endif
    if (n &gt; 0)
    {
        size_ = alloc_.m_ = n;
        data_ = alloc_.allocate(n);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            uninitialized_fill_n(data_, size_, value);
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(data_, n);
            throw;
        }
        #endif
    }
}

template &lt;class T, class Allocator&gt;
inline
vector&lt;T, Allocator&gt;::~vector()
{
    tear_down();
}

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::tear_down()
{
    if (data_ != 0)
    {
        __destroy(data_, data_ + size_);
        alloc_.deallocate(data_, alloc_.m_);
    }
}

template &lt;class T, class Allocator&gt;
vector&lt;T, Allocator&gt;&amp;
vector&lt;T, Allocator&gt;::operator=(const vector&lt;T,Allocator&gt;&amp; x)
{
    if (this != &amp;x)
        assign(x.begin(), x.end());
    return *this;
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

    template &lt;class T, class Allocator&gt;
    void
    vector&lt;T, Allocator&gt;::assign(const_iterator first, const_iterator last)
    {
        size_type n = (size_type)distance(first, last);
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::assign length error&quot;);
            #else
                __msl_error(&quot;vector::assign length error\n&quot;);
            #endif
        if (n &lt;= capacity())
        {
            size_type n1 = min(n, size_);
            iterator i = begin();
            iterator e = i + n1;
            for (; i &lt; e; ++i, ++first)
                *i = *first;
            if (n &lt; size_)
                __destroy(i, end());
            else if (size_ &lt; n)
                uninitialized_copy(first, last, i);
            size_ = n;
        }
        else
        {
            pointer olddata = data_;
            data_ = alloc_.allocate(n);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                uninitialized_copy(first, last, data_);
                if (olddata != 0)
                {
                    __destroy(olddata, olddata + size_);
                    alloc_.deallocate(olddata, alloc_.m_);
                }
                size_ = alloc_.m_ = n;
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                alloc_.deallocate(data_, n);
                data_ = olddata;
                throw;
            }
            #endif
        }
    }

#endif

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::assign(size_type n, const T&amp; u)
{
    if (n &gt; max_size())
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;vector::assign length error&quot;);
        #else
            __msl_error(&quot;vector::assign length error\n&quot;);
        #endif
    if (n &lt;= capacity())
    {
        size_type n1 = min(n, size_);
        iterator i = begin();
        iterator e = i + n1;
        for (; i &lt; e; ++i)
            *i = u;
        if (n &lt; size_)
            __destroy(i, end());
        else if (size_ &lt; n)
            uninitialized_fill(i, begin() + n, u);
        size_ = n;
    }
    else
    {
        pointer olddata = data_;
        data_ = alloc_.allocate(n);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            uninitialized_fill_n(data_, n, u);
            if (olddata != 0)
            {
                __destroy(olddata, olddata + size_);
                alloc_.deallocate(olddata, alloc_.m_);
            }
            size_ = alloc_.m_ = n;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(data_, n);
            data_ = olddata;
            throw;
        }
        #endif
    }
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::allocator_type
vector&lt;T, Allocator&gt;::get_allocator() const
{
    return alloc_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::iterator
vector&lt;T, Allocator&gt;::begin()
{
    return data_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::const_iterator
vector&lt;T, Allocator&gt;::begin() const
{
    return data_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::iterator
vector&lt;T, Allocator&gt;::end()
{
    return data_ + size_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::const_iterator
vector&lt;T, Allocator&gt;::end() const
{
    return data_ + size_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::reverse_iterator
vector&lt;T, Allocator&gt;::rbegin()
{
    return reverse_iterator(end());
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::const_reverse_iterator
vector&lt;T, Allocator&gt;::rbegin() const
{
    return const_reverse_iterator(end());
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::reverse_iterator
vector&lt;T, Allocator&gt;::rend()
{
    return reverse_iterator(begin());
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::const_reverse_iterator
vector&lt;T, Allocator&gt;::rend() const
{
    return const_reverse_iterator(begin());
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::size_type
vector&lt;T, Allocator&gt;::size() const
{
    return size_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::size_type
vector&lt;T, Allocator&gt;::max_size() const
{
    return alloc_.max_size();
}

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::resize(size_type sz, T c)
{
    if (sz &gt; size())
        insert(end(), sz-size(), c);
    else if (sz &lt; size())
        erase(begin() + sz, end());
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::size_type
vector&lt;T, Allocator&gt;::capacity() const
{
    return alloc_.m_;
}

template &lt;class T, class Allocator&gt;
inline
bool
vector&lt;T, Allocator&gt;::empty() const
{
    return size_ == 0;
}

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::reserve(size_type n)
{
    if (n &gt; max_size())
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;vector::reserve length error&quot;);
        #else
            __msl_error(&quot;vector::reserve length error\n&quot;);
        #endif
    if (n &gt; capacity())
    {
        pointer olddata = data_;
        data_ = alloc_.allocate(n);
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            if (olddata != 0)
            {
                uninitialized_copy(olddata, olddata + size_, data_);
                __destroy(olddata, olddata + size_);
                alloc_.deallocate(olddata, alloc_.m_);
            }
            alloc_.m_ = n;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            alloc_.deallocate(data_, n);
            data_ = olddata;
            throw;
        }
        #endif
    }
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::reference
vector&lt;T, Allocator&gt;::operator[](size_type n)
{
    return *(data_ + n);
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::const_reference
vector&lt;T, Allocator&gt;::operator[](size_type n) const
{
    return *(data_ + n);
}

template &lt;class T, class Allocator&gt;
typename vector&lt;T, Allocator&gt;::const_reference
vector&lt;T, Allocator&gt;::at(size_type n) const
{
    if (n &gt;= size_)
        #ifndef _MSL_NO_EXCEPTIONS
            throw out_of_range(&quot;vector::at index out of range&quot;);
        #else
            __msl_error(&quot;vector::at index out of range&quot;);
        #endif
    return *(data_ + n);
}

template &lt;class T, class Allocator&gt;
typename vector&lt;T, Allocator&gt;::reference
vector&lt;T, Allocator&gt;::at(size_type n)
{
    if (n &gt;= size_)
        #ifndef _MSL_NO_EXCEPTIONS
            throw out_of_range(&quot;vector::at index out of range&quot;);
        #else
            __msl_error(&quot;vector::at index out of range&quot;);
        #endif
    return *(data_ + n);
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::reference
vector&lt;T, Allocator&gt;::front()
{
    return *data_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::const_reference
vector&lt;T, Allocator&gt;::front() const
{
    return *data_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::reference
vector&lt;T, Allocator&gt;::back()
{
    return *(data_ + size_ - 1);
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::const_reference
vector&lt;T, Allocator&gt;::back() const
{
    return *(data_ + size_ - 1);
}

// hh 990217 Specialized push_back (used to call insert)
template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::push_back(const T&amp; x)
{
    size_type ms = max_size();
    if (size_ &gt; ms - 1)
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;vector::push_back length error&quot;);
        #else
            __msl_error(&quot;vector::push_back length error\n&quot;);
        #endif
    if (size_ &lt; capacity())
    {
        new (data_ + size_) T(x);
        ++size_;
    }
    else
    {
        pointer olddata = data_;
        size_type newcap = alloc_.m_;
        if (newcap == 0)
            newcap = 1;
        else
            newcap *= 2;
        data_ = alloc_.allocate(newcap);
        size_type done = 0;
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            uninitialized_copy(olddata, olddata + size_, data_);
            done = size_;
            new (data_ + size_) T(x);
            if (olddata != 0)
            {
                __destroy(olddata, olddata + size_);
                alloc_.deallocate(olddata, alloc_.m_);
            }
            ++size_;
            alloc_.m_ = newcap;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            __destroy(data_, data_ + done);
            alloc_.deallocate(data_, newcap);
            data_ = olddata;
            throw;
        }
        #endif
    }
}

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::pop_back()
{   
    alloc_.destroy(&amp;*(end() - 1));
    --size_;
}

template &lt;class T, class Allocator&gt;
inline
typename vector&lt;T, Allocator&gt;::iterator
vector&lt;T, Allocator&gt;::insert(iterator position, const T&amp; x)
{
    size_type pos = size_type(position - data_);
    insert(position, 1, x);
    return data_ + pos;
}

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::insert(iterator position, size_type n, const T&amp; x)
{
    if (n == 0)
        return;
    size_type ms = max_size();
    if (n &gt; ms || size_ &gt; ms - n)
        #ifndef _MSL_NO_EXCEPTIONS
            throw length_error(&quot;vector::insert length error&quot;);
        #else
            __msl_error(&quot;vector::insert length error\n&quot;);
        #endif
    if (size_ + n &lt;= capacity())
    {
        size_type n1 = size_type(end() - position);
        if (n1 &gt; 0)
        {
            size_type n2 = min(n, n1);
            size_type n3 = n &gt; n1 ? n - n1 : 0;
            uninitialized_copy(data_ + size_ - n2, data_ + size_, data_ + size_ + n3);
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                if (n &lt; n1)
                    copy_backward(position, data_ + size_ - n2,  data_ + size_);
                iterator e = position + n2;
                for (; position &lt; e; ++position)
                    *position = x;
                uninitialized_fill(position, position + n3, x);
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                __destroy(data_ + size_ + n3, data_ + size_ + n);
                throw;
            }
            #endif
        }
        else
            uninitialized_fill_n(position, n, x);
        size_ += n;
    }
    else
    {
        pointer olddata = data_;
        size_type newsize = size_ + n;
        size_type newcap = alloc_.m_;
        size_type pos = size_type(position - data_);
        if (newcap == 0)
            newcap = 1;
        while (newsize &gt; newcap)
            newcap *= 2;
        data_ = alloc_.allocate(newcap);
        size_type done = 0;
        #ifndef _MSL_NO_EXCEPTIONS
        try
        {
        #endif
            if (pos &gt; 0)
            {
                uninitialized_copy(olddata, olddata + pos, data_);
                done = pos;
            }
            uninitialized_fill_n(data_ + pos, n, x);
            done += n;
            if (pos &lt; size_)
                uninitialized_copy(olddata + pos, olddata + size_, data_ + pos + n);
            if (olddata != 0)
            {
                __destroy(olddata, olddata + size_);
                alloc_.deallocate(olddata, alloc_.m_);
            }
            size_ = newsize;
            alloc_.m_ = newcap;
        #ifndef _MSL_NO_EXCEPTIONS
        }
        catch (...)
        {
            __destroy(data_, data_ + done);
            alloc_.deallocate(data_, newcap);
            data_ = olddata;
            throw;
        }
        #endif
    }
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

    template &lt;class T, class Allocator&gt;
    void
    vector&lt;T, Allocator&gt;::insert(iterator position, const_iterator first, const_iterator last)
    {
        size_type n = (size_type)distance(first, last);
        if (n == 0)
            return;
        size_type ms = max_size();
        if (n &gt; ms || size_ &gt; ms - n)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::insert length error&quot;);
            #else
                __msl_error(&quot;vector::insert length error\n&quot;);
            #endif
        if (size_ + n &lt;= capacity())
        {
            size_type n1 = size_type(end() - position);
            if (n1 &gt; 0)
            {
                size_type n2 = min(n, n1);
                size_type n3 = n &gt; n1 ? n - n1 : 0;
                uninitialized_copy(data_ + size_ - n2, data_ + size_, data_ + size_ + n3);
                #ifndef _MSL_NO_EXCEPTIONS
                try
                {
                #endif
                    if (n &lt; n1)
                        copy_backward(position, data_ + size_ - n2,  data_ + size_);
                    iterator e = position + n2;
                    for (; position &lt; e; ++position, ++first)
                        *position = *first;
                    uninitialized_copy(first, last, position);
                #ifndef _MSL_NO_EXCEPTIONS
                }
                catch (...)
                {
                    __destroy(data_ + size_ + n3, data_ + size_ + n);
                    throw;
                }
                #endif
            }
            else
                uninitialized_copy(first, last, position);
            size_ += n;
        }
        else
        {
            pointer olddata = data_;
            size_type newsize = size_ + n;
            size_type newcap = alloc_.m_;
            size_type pos = size_type(position - data_);
            if (newcap == 0)
                newcap = 1;
            while (newsize &gt; newcap)
                newcap *= 2;
            data_ = alloc_.allocate(newcap);
            size_type done = 0;
            #ifndef _MSL_NO_EXCEPTIONS
            try
            {
            #endif
                if (pos &gt; 0)
                {
                    uninitialized_copy(olddata, olddata + pos, data_);
                    done = pos;
                }
                uninitialized_copy(first, last, data_ + pos);
                done += n;
                if (pos &lt; size_)
                    uninitialized_copy(olddata + pos, olddata + size_, data_ + pos + n);
                if (olddata != 0)
                {
                    __destroy(olddata, olddata + size_);
                    alloc_.deallocate(olddata, alloc_.m_);
                }
                size_ = newsize;
                alloc_.m_ = newcap;
            #ifndef _MSL_NO_EXCEPTIONS
            }
            catch (...)
            {
                __destroy(data_, data_ + done);
                alloc_.deallocate(data_, newcap);
                data_ = olddata;
                throw;
            }
            #endif
        }
    }

#endif

template &lt;class T, class Allocator&gt;
typename vector&lt;T, Allocator&gt;::iterator
vector&lt;T, Allocator&gt;::erase(iterator position)
{
    size_type n = size_type(end() - position - 1);
    if (n &gt; 0)
        copy(position + 1, end(), position);
    --size_;
    __destroy(end());
    return position;
}

template &lt;class T, class Allocator&gt;
typename vector&lt;T, Allocator&gt;::iterator
vector&lt;T, Allocator&gt;::erase(iterator first, iterator last)
{
    if (first == last)
        return first;
    size_type n = size_type(end() - last);
    if (n &gt; 0)
        copy(last, end(), first);
    __destroy(first + n, end());
    size_ -= size_type(last - first);
    return first;
}

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::swap(vector&lt;T,Allocator&gt;&amp; x)
{
    if (this != &amp;x)
    {
        _STD::swap(alloc_, x.alloc_);
        _STD::swap(size_, x.size_);
        _STD::swap(data_, x.data_);
    }
}

template &lt;class T, class Allocator&gt;
void
vector&lt;T, Allocator&gt;::clear()
{
    __destroy(begin(), end());
    size_ = 0;
}

template &lt;class T, class Allocator&gt;
inline
bool
operator==(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y)
{
    return x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());
}

template &lt;class T, class Allocator&gt;
inline
bool
operator!=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y)
{
    return !(x == y);
}

template &lt;class T, class Allocator&gt;
inline
bool
operator&lt; (const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y)
{
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template &lt;class T, class Allocator&gt;
inline
bool
operator&gt; (const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y)
{
    return y &lt; x;
}

template &lt;class T, class Allocator&gt;
inline
bool
operator&gt;=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y)
{
    return !(x &lt; y);
}

template &lt;class T, class Allocator&gt;
inline
bool
operator&lt;=(const vector&lt;T,Allocator&gt;&amp; x, const vector&lt;T,Allocator&gt;&amp; y)
{
    return !(y &lt; x);
}

template &lt;class T, class Allocator&gt;
inline
void
swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y)
{
    x.swap(y);
}

#if !defined(_MSL_NO_PARTIAL_SPECIALIZATION) &amp;&amp; !defined(_MSL_NO_MEMBER_TEMPLATE) &amp;&amp; !defined(_Inhibit_Container_Optimization)

    // Specialize for T* to save on code bloat

    // void*

    template &lt;class Allocator&gt;
    class vector&lt;void*, Allocator&gt;
    {
        template &lt;bool b&gt; struct chooser {};
    public:
        // types:
        typedef typename Allocator::reference         reference;
        typedef typename Allocator::const_reference   const_reference;
        typedef typename Allocator::pointer           iterator;
        typedef typename Allocator::const_pointer     const_iterator;
        typedef typename Allocator::size_type         size_type;
        typedef typename Allocator::difference_type   difference_type;
        typedef void*                                 value_type;
        typedef Allocator                             allocator_type;
        typedef typename Allocator::pointer           pointer;
        typedef typename Allocator::const_pointer     const_pointer;
        typedef _STD::reverse_iterator&lt;iterator&gt;       reverse_iterator;
        typedef _STD::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
        // _lib.vector.cons_ construct/copy/destroy:
        explicit vector(const Allocator&amp; = Allocator());
        explicit vector(size_type n, const value_type&amp; value = 0, const Allocator&amp; = Allocator());
        template &lt;class InputIterator&gt;
            inline
            vector(InputIterator first, InputIterator last, const Allocator&amp; a = Allocator())
                : alloc_(a),
                  size_(0),
                  data_(0)
            {
                choose_init(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
        vector(const vector&amp; x);
        ~vector();
        vector&amp; operator=(const vector&amp; x);
        template &lt;class InputIterator&gt;
            inline
            void assign(InputIterator first, InputIterator last)
            {
                choose_assign(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
        void assign(size_type n, const value_type&amp; u);
        allocator_type get_allocator() const;
        // iterators:
        iterator               begin();
        const_iterator         begin() const;
        iterator               end();
        const_iterator         end() const;
        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator       rend();
        const_reverse_iterator rend() const;
        // _lib.vector.capacity_ capacity:
        size_type size() const;
        size_type max_size() const;
        void      resize(size_type sz, value_type c = 0);
        size_type capacity() const;
        bool      empty() const;
        void      reserve(size_type n);

        // element access:
        reference       operator[](size_type n);
        const_reference operator[](size_type n) const;
        const_reference at(size_type n) const;
        reference       at(size_type n);
        reference       front();
        const_reference front() const;
        reference       back();
        const_reference back() const;
        // _lib.vector.modifiers_ modifiers:
        void push_back(const value_type&amp; x);
        void pop_back();
        iterator insert(iterator position, const value_type&amp; x);
        void     insert(iterator position, size_type n, const value_type&amp; x);
        template &lt;class InputIterator&gt;
            inline
            void insert(iterator position, InputIterator first, InputIterator last)
            {
                choose_insert(position, first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
            }
        iterator erase(iterator position);
        iterator erase(iterator first, iterator last);
        void     swap(vector&amp;);
        void     clear();
    private:
        _EmptyMemberOpt&lt;Allocator, size_type&gt; alloc_;  // m_ is capacity
        size_type size_;
        pointer data_;

        template &lt;class InputIterator&gt;
            inline
            void
            choose_init(InputIterator first, InputIterator last, chooser&lt;true&gt;)
            {
                init(static_cast&lt;size_type&gt;(first), reinterpret_cast&lt;value_type&gt;(last));  // hh 981208
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_init(InputIterator first, InputIterator last, chooser&lt;false&gt;)
            {
                init(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            init(InputIterator first, InputIterator last, input_iterator_tag)
            {
                #ifndef _MSL_NO_EXCEPTIONS
                try
                {
                #endif
                    for (; first != last; ++first)
                        push_back(*first);
                #ifndef _MSL_NO_EXCEPTIONS
                }
                catch (...)
                {
                    tear_down();
                    throw;
                }
                #endif
            }

        template &lt;class ForwardIterator&gt;
            void
            init(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
            {
                if (size_ &gt; max_size())
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;vector::construction length error&quot;);
                    #else
                        __msl_error(&quot;vector::construction length error\n&quot;);
                    #endif
                size_ = alloc_.m_ = (size_type)distance(first, last);
                if (alloc_.m_ &gt; 0)
                {
                    data_ = alloc_.allocate(alloc_.m_);
                    copy(first, last, data_);
                }
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_assign(InputIterator first, InputIterator last, chooser&lt;true&gt;)
            {
                assign(static_cast&lt;size_type&gt;(first), reinterpret_cast&lt;value_type&gt;(last));  // hh 981221
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_assign(InputIterator first, InputIterator last, chooser&lt;false&gt;)
            {
                do_assign(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            do_assign(InputIterator first, InputIterator last, input_iterator_tag)
            {
                vector temp(first, last, get_allocator());
                const vector&amp; tempr = temp;
                do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
            }

        template &lt;class ForwardIterator&gt;
            void
            do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
            {
                size_type n = (size_type)distance(first, last);
                if (n &gt; max_size())
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;vector::assign length error&quot;);
                    #else
                        __msl_error(&quot;vector::assign length error\n&quot;);
                    #endif
                if (n &lt;= capacity())
                {
                    copy(first, last, data_);
                    size_ = n;
                }
                else
                {
                    pointer olddata = data_;
                    data_ = alloc_.allocate(n);
                    copy(first, last, data_);
                    if (olddata != 0)
                        alloc_.deallocate(olddata, alloc_.m_);
                    size_ = alloc_.m_ = n;
                }
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_insert(iterator position, InputIterator first, InputIterator last,
                chooser&lt;true&gt;)
            {
                insert(position, static_cast&lt;size_type&gt;(first), reinterpret_cast&lt;value_type&gt;(last));  // hh 981221
            }

        template &lt;class InputIterator&gt;
            inline
            void
            choose_insert(iterator position, InputIterator first, InputIterator last,
                chooser&lt;false&gt;)
            {
                do_insert(position, first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
            }

        template &lt;class InputIterator&gt;
            void
            do_insert(iterator position, InputIterator first, InputIterator last,
                input_iterator_tag)
            {
                vector temp(first, last, get_allocator());
                const vector&amp; tempr = temp;
                do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());
            }

        template &lt;class ForwardIterator&gt;
            void
            do_insert(iterator position, ForwardIterator first, ForwardIterator last,
                forward_iterator_tag)
            {
                size_type n = (size_type)distance(first, last);
                if (n == 0)
                    return;
                size_type ms = max_size();
                if (n &gt; ms || size_ &gt; ms - n)
                    #ifndef _MSL_NO_EXCEPTIONS
                        throw length_error(&quot;vector::insert length error&quot;);
                    #else
                        __msl_error(&quot;vector::insert length error\n&quot;);
                    #endif
                if (size_ + n &lt;= capacity())
                {
                    size_type n1 = size_type(end() - position);
                    if (n1 &gt; 0)
                        copy_backward(position, data_ + size_,  data_ + size_ + n);
                    copy(first, last, position);
                    size_ += n;
                }
                else
                {
                    pointer olddata = data_;
                    size_type newsize = size_ + n;
                    size_type newcap = alloc_.m_;
                    size_type pos = size_type(position - data_);
                    if (newcap == 0)
                        newcap = 1;
                    while (newsize &gt; newcap)
                        newcap *= 2;
                    data_ = alloc_.allocate(newcap);
                    if (pos &gt; 0)
                        copy(olddata, olddata + pos, data_);
                    copy(first, last, data_ + pos);
                    if (pos &lt; size_)
                        copy(olddata + pos, olddata + size_, data_ + pos + n);
                    if (olddata != 0)
                        alloc_.deallocate(olddata, alloc_.m_);
                    size_ = newsize;
                    alloc_.m_ = newcap;
                }
            }

        void init(size_type n, const value_type&amp; value);
        void tear_down();
    };

    // Implementation vector&lt;void*&gt;

    template &lt;class Allocator&gt;
    inline
    vector&lt;void*, Allocator&gt;::vector(const Allocator&amp; a)
        : alloc_(a),
          size_(0),
          data_(0)
    {
    }

    template &lt;class Allocator&gt;
    inline
    vector&lt;void*, Allocator&gt;::vector(size_type n, const value_type&amp; value, const Allocator&amp; a)
        : alloc_(a),
          size_(0),
          data_(0)
    {
        init(n, value);
    }     

    template &lt;class Allocator&gt;
    vector&lt;void*, Allocator&gt;::vector(const vector&amp; x)
        : alloc_(x.alloc_, x.size_),
          size_(x.size_),
          data_(0)
    {
        if (alloc_.m_ &gt; 0)
        {
            data_ = alloc_.allocate(alloc_.m_);
            copy(x.begin(), x.end(), data_);
        }
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;void*, Allocator&gt;::init(size_type n, const value_type&amp; value)
    {
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::construction length error&quot;);
            #else
                __msl_error(&quot;vector::construction length error\n&quot;);
            #endif
        if (n &gt; 0)
        {
            size_ = alloc_.m_ = n;
            data_ = alloc_.allocate(n);
            fill_n(data_, n, value);
        }
    }

    template &lt;class Allocator&gt;
    inline
    vector&lt;void*, Allocator&gt;::~vector()
    {
        tear_down();
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;void*, Allocator&gt;::tear_down()
    {
        if (data_ != 0)
            alloc_.deallocate(data_, alloc_.m_);
    }

    template &lt;class Allocator&gt;
    vector&lt;void*, Allocator&gt;&amp;
    vector&lt;void*, Allocator&gt;::operator=(const vector&amp; x)
    {
        if (this != &amp;x)
            assign(x.begin(), x.end());
        return *this;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;void*, Allocator&gt;::assign(size_type n, const value_type&amp; u)
    {
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::assign length error&quot;);
            #else
                __msl_error(&quot;vector::assign length error\n&quot;);
            #endif
        if (n &lt;= capacity())
        {
            fill_n(data_, n, u);
            size_ = n;
        }
        else
        {
            pointer olddata = data_;
            data_ = alloc_.allocate(n);
            fill_n(data_, n, u);
            if (olddata != 0)
                alloc_.deallocate(olddata, alloc_.m_);
            size_ = alloc_.m_ = n;
        }
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::allocator_type
    vector&lt;void*, Allocator&gt;::get_allocator() const
    {
        return alloc_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::iterator
    vector&lt;void*, Allocator&gt;::begin()
    {
        return data_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::const_iterator
    vector&lt;void*, Allocator&gt;::begin() const
    {
        return data_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::iterator
    vector&lt;void*, Allocator&gt;::end()
    {
        return data_ + size_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::const_iterator
    vector&lt;void*, Allocator&gt;::end() const
    {
        return data_ + size_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::reverse_iterator
    vector&lt;void*, Allocator&gt;::rbegin()
    {
        return reverse_iterator(end());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::const_reverse_iterator
    vector&lt;void*, Allocator&gt;::rbegin() const
    {
        return const_reverse_iterator(end());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::reverse_iterator
    vector&lt;void*, Allocator&gt;::rend()
    {
        return reverse_iterator(begin());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::const_reverse_iterator
    vector&lt;void*, Allocator&gt;::rend() const
    {
        return const_reverse_iterator(begin());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::size_type
    vector&lt;void*, Allocator&gt;::size() const
    {
        return size_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::size_type
    vector&lt;void*, Allocator&gt;::max_size() const
    {
        return alloc_.max_size();
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;void*, Allocator&gt;::resize(size_type sz, value_type c)
    {
        if (sz &gt; size())
            insert(end(), sz-size(), c);
        else if (sz &lt; size())
            erase(begin() + sz, end());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::size_type
    vector&lt;void*, Allocator&gt;::capacity() const
    {
        return alloc_.m_;
    }

    template &lt;class Allocator&gt;
    inline
    bool
    vector&lt;void*, Allocator&gt;::empty() const
    {
        return size_ == 0;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;void*, Allocator&gt;::reserve(size_type n)
    {
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::reserve length error&quot;);
            #else
                __msl_error(&quot;vector::reserve length error\n&quot;);
            #endif
        if (n &gt; capacity())
        {
            pointer olddata = data_;
            data_ = alloc_.allocate(n);
            if (olddata != 0)
            {
                copy(olddata, olddata + size_, data_);
                alloc_.deallocate(olddata, alloc_.m_);
            }
            alloc_.m_ = n;
        }
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::reference
    vector&lt;void*, Allocator&gt;::operator[](size_type n)
    {
        return *(data_ + n);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::const_reference
    vector&lt;void*, Allocator&gt;::operator[](size_type n) const
    {
        return *(data_ + n);
    }

    template &lt;class Allocator&gt;
    typename vector&lt;void*, Allocator&gt;::const_reference
    vector&lt;void*, Allocator&gt;::at(size_type n) const
    {
        if (n &gt;= size_)
            #ifndef _MSL_NO_EXCEPTIONS
                throw out_of_range(&quot;vector::at index out of range&quot;);
            #else
                __msl_error(&quot;vector::at index out of range&quot;);
            #endif
        return *(data_ + n);
    }

    template &lt;class Allocator&gt;
    typename vector&lt;void*, Allocator&gt;::reference
    vector&lt;void*, Allocator&gt;::at(size_type n)
    {
        if (n &gt;= size_)
            #ifndef _MSL_NO_EXCEPTIONS
                throw out_of_range(&quot;vector::at index out of range&quot;);
            #else
                __msl_error(&quot;vector::at index out of range&quot;);
            #endif
        return *(data_ + n);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::reference
    vector&lt;void*, Allocator&gt;::front()
    {
        return *data_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::const_reference
    vector&lt;void*, Allocator&gt;::front() const
    {
        return *data_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::reference
    vector&lt;void*, Allocator&gt;::back()
    {
        return *(data_ + size_ - 1);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::const_reference
    vector&lt;void*, Allocator&gt;::back() const
    {
        return *(data_ + size_ - 1);
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;void*, Allocator&gt;::push_back(const value_type&amp; x)
    {
        size_type ms = max_size();
        if (size_ &gt; ms - 1)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::insert length error&quot;);
            #else
                __msl_error(&quot;vector::insert length error\n&quot;);
            #endif
        if (size_ &lt; capacity())
        {
            size_type n1 = 0;
            data_[size_++] = x;
        }
        else
        {
            pointer olddata = data_;
            size_type newcap = alloc_.m_;
            if (newcap == 0)
                newcap = 1;
            else
                newcap *= 2;
            data_ = alloc_.allocate(newcap);
            if (size_ &gt; 0)
                copy(olddata, olddata + size_, data_);
            data_[size_] = x;
            if (olddata != 0)
                alloc_.deallocate(olddata, alloc_.m_);
            ++size_;
            alloc_.m_ = newcap;
        }
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;void*, Allocator&gt;::pop_back()
    {
        --size_;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;void*, Allocator&gt;::iterator
    vector&lt;void*, Allocator&gt;::insert(iterator position, const value_type&amp; x)
    {
        size_type pos = size_type(position - data_);
        insert(position, 1, x);
        return data_ + pos;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;void*, Allocator&gt;::insert(iterator position, size_type n, const value_type&amp; x)
    {
        if (n == 0)
            return;
        size_type ms = max_size();
        if (n &gt; ms || size_ &gt; ms - n)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::insert length error&quot;);
            #else
                __msl_error(&quot;vector::insert length error\n&quot;);
            #endif
        if (size_ + n &lt;= capacity())
        {
            size_type n1 = size_type(end() - position);
            if (n1 &gt; 0)
                copy_backward(position, data_ + size_,  data_ + size_ + n);
            for (size_type i = 0; i &lt; n; ++i, ++position)
                *position = x;
            size_ += n;
        }
        else
        {
            pointer olddata = data_;
            size_type newsize = size_ + n;
            size_type newcap = alloc_.m_;
            size_type pos = size_type(position - data_);
            if (newcap == 0)
                newcap = 1;
            while (newsize &gt; newcap)
                newcap *= 2;
            data_ = alloc_.allocate(newcap);
            if (pos &gt; 0)
                copy(olddata, olddata + pos, data_);
            for (size_type i = 0; i &lt; n; ++i)
                data_[pos + i] = x;
            if (pos &lt; size_)
                copy(olddata + pos, olddata + size_, data_ + pos + n);
            if (olddata != 0)
                alloc_.deallocate(olddata, alloc_.m_);
            size_ = newsize;
            alloc_.m_ = newcap;
        }
    }

    template &lt;class Allocator&gt;
    typename vector&lt;void*, Allocator&gt;::iterator
    vector&lt;void*, Allocator&gt;::erase(iterator position)
    {
        size_type n = size_type(end() - position - 1);
        if (n &gt; 0)
            copy(position + 1, end(), position);
        --size_;
        return position;
    }

    template &lt;class Allocator&gt;
    typename vector&lt;void*, Allocator&gt;::iterator
    vector&lt;void*, Allocator&gt;::erase(iterator first, iterator last)
    {
        if (first == last)
            return first;
        size_type n = size_type(end() - last);
        if (n &gt; 0)
            copy(last, end(), first);
        size_ -= size_type(last - first);
        return first;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;void*, Allocator&gt;::swap(vector&amp; x)
    {
        if (this != &amp;x)
        {
            _STD::swap(alloc_, x.alloc_);
            _STD::swap(size_, x.size_);
            _STD::swap(data_, x.data_);
        }
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;void*, Allocator&gt;::clear()
    {
        size_ = 0;
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator==(const vector&lt;void*, Allocator&gt;&amp; x, const vector&lt;void*, Allocator&gt;&amp; y)
    {
        return x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator!=(const vector&lt;void*, Allocator&gt;&amp; x, const vector&lt;void*, Allocator&gt;&amp; y)
    {
        return !(x == y);
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&lt; (const vector&lt;void*,Allocator&gt;&amp; x, const vector&lt;void*,Allocator&gt;&amp; y)
    {
        return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&gt; (const vector&lt;void*,Allocator&gt;&amp; x, const vector&lt;void*,Allocator&gt;&amp; y)
    {
        return y &lt; x;
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&gt;=(const vector&lt;void*,Allocator&gt;&amp; x, const vector&lt;void*,Allocator&gt;&amp; y)
    {
        return !(x &lt; y);
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&lt;=(const vector&lt;void*,Allocator&gt;&amp; x, const vector&lt;void*,Allocator&gt;&amp; y)
    {
        return !(y &lt; x);
    }

    template &lt;class Allocator&gt;
    inline
    void
    swap(vector&lt;void*,Allocator&gt;&amp; x, vector&lt;void*,Allocator&gt;&amp; y)
    {
        x.swap(y);
    }

    // T*

    template &lt;class T, class Allocator&gt;
    class vector&lt;T*, Allocator&gt;
        : private vector&lt;void*, Allocator::rebind&lt;void*&gt;::other&gt;
    {
        typedef vector&lt;void*, Allocator::rebind&lt;void*&gt;::other&gt; base;
        typedef base::allocator_type base_allocator;
    public:
        // types:
        typedef typename Allocator::reference         reference;
        typedef typename Allocator::const_reference   const_reference;
        typedef typename Allocator::pointer           iterator;
        typedef typename Allocator::const_pointer     const_iterator;
        typedef typename Allocator::size_type         size_type;
        typedef typename Allocator::difference_type   difference_type;
        typedef T*                                    value_type;
        typedef Allocator                             allocator_type;
        typedef typename Allocator::pointer           pointer;
        typedef typename Allocator::const_pointer     const_pointer;
        typedef _STD::reverse_iterator&lt;iterator&gt;       reverse_iterator;
        typedef _STD::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
        // _lib.vector.cons_ construct/copy/destroy:
        explicit vector(const Allocator&amp; = Allocator());
        explicit vector(size_type n, const value_type&amp; value = 0, const Allocator&amp; = Allocator());
        template &lt;class InputIterator&gt;
            inline
            vector(InputIterator first, InputIterator last, const Allocator&amp; a = Allocator())
                : base(first, last, base_allocator(a))
            {
            }
        template &lt;class InputIterator&gt;
            inline
            void assign(InputIterator first, InputIterator last)
            {
                base::assign(first, last);
            }
        void assign(size_type n, const value_type&amp; u);
        allocator_type get_allocator() const;
        // iterators:
        iterator               begin();
        const_iterator         begin() const;
        iterator               end();
        const_iterator         end() const;
        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator       rend();
        const_reverse_iterator rend() const;
        // _lib.vector.capacity_ capacity:
        size_type size() const;
        size_type max_size() const;
        void      resize(size_type sz, value_type c = 0);
        size_type capacity() const;
        bool      empty() const;
        void      reserve(size_type n);

        // element access:
        reference       operator[](size_type n);
        const_reference operator[](size_type n) const;
        const_reference at(size_type n) const;
        reference       at(size_type n);
        reference       front();
        const_reference front() const;
        reference       back();
        const_reference back() const;
        // _lib.vector.modifiers_ modifiers:
        void push_back(const value_type&amp; x);
        void pop_back();
        iterator insert(iterator position, const value_type&amp; x);
        void     insert(iterator position, size_type n, const value_type&amp; x);
        template &lt;class InputIterator&gt;
            inline
            void insert(iterator position, InputIterator first, InputIterator last)
            {
                base::insert(position, first, last);
            }
        iterator erase(iterator position);
        iterator erase(iterator first, iterator last);
        void     swap(vector&amp;);
        void     clear();
    };

    template &lt;class T, class Allocator&gt;
    inline
    vector&lt;T*, Allocator&gt;::vector(const Allocator&amp; a)
        : base(base_allocator(a))
    {
    }

    template &lt;class T, class Allocator&gt;
    inline
    vector&lt;T*, Allocator&gt;::vector(size_type n, const value_type&amp; value, const Allocator&amp; a)
        : base(n, value, base_allocator(a))
    {
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    vector&lt;T*, Allocator&gt;::assign(size_type n, const value_type&amp; u)
    {
        base::assign(n, u);
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::allocator_type
    vector&lt;T*, Allocator&gt;::get_allocator() const
    {
        return base::get_allocator();
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::iterator
    vector&lt;T*, Allocator&gt;::begin()
    {
        return iterator(base::begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::const_iterator
    vector&lt;T*, Allocator&gt;::begin() const
    {
        return const_iterator(base::begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::iterator
    vector&lt;T*, Allocator&gt;::end()
    {
        return iterator(base::end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::const_iterator
    vector&lt;T*, Allocator&gt;::end() const
    {
        return const_iterator(base::end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::reverse_iterator
    vector&lt;T*, Allocator&gt;::rbegin()
    {
        return reverse_iterator(end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::const_reverse_iterator
    vector&lt;T*, Allocator&gt;::rbegin() const
    {
        return const_reverse_iterator(end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::reverse_iterator
    vector&lt;T*, Allocator&gt;::rend()
    {
        return reverse_iterator(begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::const_reverse_iterator
    vector&lt;T*, Allocator&gt;::rend() const
    {
        return const_reverse_iterator(begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::size_type
    vector&lt;T*, Allocator&gt;::size() const
    {
        return base::size();
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::size_type
    vector&lt;T*, Allocator&gt;::max_size() const
    {
        return base::max_size();
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    vector&lt;T*, Allocator&gt;::resize(size_type sz, value_type c)
    {
        base::resize(sz, c);
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::size_type
    vector&lt;T*, Allocator&gt;::capacity() const
    {
        return base::capacity();
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    vector&lt;T*, Allocator&gt;::empty() const
    {
        return base::empty();
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    vector&lt;T*, Allocator&gt;::reserve(size_type n)
    {
        base::reserve(n);
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::reference
    vector&lt;T*, Allocator&gt;::operator[](size_type n)
    {
        return reference(base::operator[](n));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::const_reference
    vector&lt;T*, Allocator&gt;::operator[](size_type n) const
    {
        return const_reference(base::operator[](n));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::const_reference
    vector&lt;T*, Allocator&gt;::at(size_type n) const
    {
        return const_reference(base::at(n));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::reference
    vector&lt;T*, Allocator&gt;::at(size_type n)
    {
        return reference(base::at(n));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::reference
    vector&lt;T*, Allocator&gt;::front()
    {
        return reference(base::front());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::const_reference
    vector&lt;T*, Allocator&gt;::front() const
    {
        return const_reference(base::front());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::reference
    vector&lt;T*, Allocator&gt;::back()
    {
        return reference(base::back());
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::const_reference
    vector&lt;T*, Allocator&gt;::back() const
    {
        return const_reference(base::back());
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    vector&lt;T*, Allocator&gt;::push_back(const value_type&amp; x)
    {
        base::push_back(x);
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    vector&lt;T*, Allocator&gt;::pop_back()
    {
        base::pop_back();
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::iterator
    vector&lt;T*, Allocator&gt;::insert(iterator position, const value_type&amp; x)
    {
        return iterator(base::insert(position, x));
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    vector&lt;T*, Allocator&gt;::insert(iterator position, size_type n, const value_type&amp; x)
    {
        base::insert(position, n, x);
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::iterator
    vector&lt;T*, Allocator&gt;::erase(iterator position)
    {
        return iterator(base::erase(position));
    }

    template &lt;class T, class Allocator&gt;
    inline
    typename vector&lt;T*, Allocator&gt;::iterator
    vector&lt;T*, Allocator&gt;::erase(iterator first, iterator last)
    {
        return iterator(base::erase(first, last));
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    vector&lt;T*, Allocator&gt;::swap(vector&amp; rhs)
    {
        base::swap((base&amp;)rhs);
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    vector&lt;T*, Allocator&gt;::clear()
    {
        base::clear();
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator==(const vector&lt;T*, Allocator&gt;&amp; x, const vector&lt;T*, Allocator&gt;&amp; y)
    {
        return x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator!=(const vector&lt;T*, Allocator&gt;&amp; x, const vector&lt;T*, Allocator&gt;&amp; y)
    {
        return !(x == y);
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator&lt; (const vector&lt;T*,Allocator&gt;&amp; x, const vector&lt;T*,Allocator&gt;&amp; y)
    {
        return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator&gt; (const vector&lt;T*,Allocator&gt;&amp; x, const vector&lt;T*,Allocator&gt;&amp; y)
    {
        return y &lt; x;
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator&gt;=(const vector&lt;T*,Allocator&gt;&amp; x, const vector&lt;T*,Allocator&gt;&amp; y)
    {
        return !(x &lt; y);
    }

    template &lt;class T, class Allocator&gt;
    inline
    bool
    operator&lt;=(const vector&lt;T*,Allocator&gt;&amp; x, const vector&lt;T*,Allocator&gt;&amp; y)
    {
        return !(y &lt; x);
    }

    template &lt;class T, class Allocator&gt;
    inline
    void
    swap(vector&lt;T*,Allocator&gt;&amp; x, vector&lt;T*,Allocator&gt;&amp; y)
    {
        x.swap(y);
    }

#endif // !defined(_MSL_NO_PARTIAL_SPECIALIZATION) &amp;&amp; !defined(_MSL_NO_MEMBER_TEMPLATE) &amp;&amp; !defined(_Inhibit_Container_Optimization)

#ifndef _MSL_NO_PARTIAL_SPECIALIZATION
#ifndef __GNUC__
    // vector&lt;bool&gt;

    template &lt;class Allocator&gt;
    class vector&lt;bool, Allocator&gt;
    {
        #ifndef _MSL_NO_MEMBER_TEMPLATE
            template &lt;bool b&gt; struct chooser {};
        #endif
        typedef _MSL_REBIND (unsigned long)            internal_allocator; // must be unsigned
        typedef internal_allocator::value_type        ia_value_type;  // -1 must set all bits on
    public:
        class reference;
        class iterator;
        class const_iterator;
        friend class reference;
        friend class iterator;
        friend class const_iterator;
        // types:
        typedef bool                                  const_reference;
        typedef typename internal_allocator::size_type size_type;
        typedef typename internal_allocator::difference_type difference_type;
        typedef bool                                  value_type;
        typedef Allocator                             allocator_type;
        typedef typename internal_allocator::pointer  pointer;
        typedef typename internal_allocator::const_pointer const_pointer;
        typedef _STD::reverse_iterator&lt;iterator&gt;       reverse_iterator;
        typedef _STD::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
        // bit reference:
        class reference
        {
        public:
            operator bool() const {return vec_.test_bit(pos_);}
            reference&amp; operator=(const bool x) {vec_.set(pos_, x); return *this;}
            reference&amp; operator=(const reference&amp; x) {vec_.set(pos_, x); return *this;}
            void flip() {vec_.flip(pos_);}
        private:
            vector&amp; vec_;
            size_type pos_;

            reference(vector&amp; vec, size_type pos)
                : vec_(vec),
                  pos_(pos)
            {}

            friend class vector;
            friend class iterator;
            friend class const_iterator;
        };

        // bit iterator:
        class iterator
            : public _STD::iterator&lt;random_access_iterator_tag, bool,
                difference_type, bool*, vector::reference&gt;
        {
        public:
            iterator() {}
            vector::reference operator * () const {return vector::reference(*vec_, pos_);}
            iterator&amp; operator ++ () {++pos_; return *this;}
            iterator operator ++ (int) {iterator tmp(*this); ++pos_; return tmp;}
            iterator&amp; operator -- () {--pos_; return *this;}
            iterator operator -- (int) {iterator tmp(*this); --pos_; return tmp;}
            iterator&amp; operator += (difference_type n) {pos_ += n; return *this;}
            iterator operator + (difference_type n) const {return iterator(*this) += n;}
            iterator&amp; operator -= (difference_type n) {pos_ -= n; return *this;}
            iterator operator - (difference_type n) const {return iterator(*this) -= n;}
            difference_type operator - (const iterator&amp; rhs) const {return difference_type(pos_ - rhs.pos_);}
            vector::reference operator [] (size_type i) const {return vector::reference(*vec_, pos_ + i);}
            bool operator ==(const iterator&amp; rhs) const {return pos_ == rhs.pos_;}
            bool operator !=(const iterator&amp; rhs) const {return pos_ != rhs.pos_;}
            bool operator &lt; (const iterator&amp; rhs) const {return pos_ &lt;  rhs.pos_;}
            bool operator &lt;=(const iterator&amp; rhs) const {return pos_ &lt;= rhs.pos_;}
            bool operator &gt; (const iterator&amp; rhs) const {return pos_ &gt;  rhs.pos_;}
            bool operator &gt;=(const iterator&amp; rhs) const {return pos_ &gt;= rhs.pos_;}
            friend iterator operator + (difference_type n, const iterator&amp; rhs)
                {return iterator(rhs) += n;}
        private:
            vector* vec_;
            size_type pos_;

            iterator(vector* vec, size_type pos)
                : vec_(vec),
                  pos_(pos)
            {}

            friend class vector;
            friend class vector::const_iterator;
        };

        // bit iterator:
        class const_iterator
            : public _STD::iterator&lt;random_access_iterator_tag, bool,
                difference_type, const bool*, bool&gt;
        {
        public:
            const_iterator() {}
            const_iterator(const vector::iterator&amp; rhs) : vec_(rhs.vec_), pos_(rhs.pos_) {}
            const_reference operator * () const {return vector::reference(*(vector*)vec_, pos_);}
            const_iterator&amp; operator ++ () {++pos_; return *this;}
            const_iterator operator ++ (int) {const_iterator tmp(*this); ++pos_; return tmp;}
            const_iterator&amp; operator -- () {--pos_; return *this;}
            const_iterator operator -- (int) {const_iterator tmp(*this); --pos_; return tmp;}
            const_iterator&amp; operator += (difference_type n) {pos_ += n; return *this;}
            const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}
            const_iterator&amp; operator -= (difference_type n) {pos_ -= n; return *this;}
            const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}
            difference_type operator - (const const_iterator&amp; rhs) const {return difference_type(pos_ - rhs.pos_);}
            const_reference operator [] (size_type i) const {return vector::reference(*(vector*)vec_, pos_ + i);}
            bool operator ==(const const_iterator&amp; rhs) const {return pos_ == rhs.pos_;}
            bool operator !=(const const_iterator&amp; rhs) const {return pos_ != rhs.pos_;}
            bool operator &lt; (const const_iterator&amp; rhs) const {return pos_ &lt;  rhs.pos_;}
            bool operator &lt;=(const const_iterator&amp; rhs) const {return pos_ &lt;= rhs.pos_;}
            bool operator &gt; (const const_iterator&amp; rhs) const {return pos_ &gt;  rhs.pos_;}
            bool operator &gt;=(const const_iterator&amp; rhs) const {return pos_ &gt;= rhs.pos_;}
            friend const_iterator operator + (difference_type n, const const_iterator&amp; rhs)
                {return const_iterator(rhs) += n;}
        private:
            const vector* vec_;
            size_type pos_;

            const_iterator(const vector* vec, size_type pos)
                : vec_(vec),
                  pos_(pos)
            {}

            friend class vector;
        };

        // construct/copy/destroy:
        explicit vector(const Allocator&amp; = Allocator());
        explicit vector(size_type n, const bool&amp; value = bool(), const Allocator&amp; a = Allocator());
        #ifndef _MSL_NO_MEMBER_TEMPLATE
            template &lt;class InputIterator&gt;
                inline
                vector(InputIterator first, InputIterator last, const Allocator&amp; a = Allocator())
                #ifndef _MSL_NO_MEMBER_TEMPLATE
                    : alloc_(internal_allocator(a)),
                #else
                    :
                #endif
                      size_(0),
                      data_(0)
                {
                    choose_init(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
                }
        #else
            vector(const_iterator first, const_iterator last, const Allocator&amp; a = Allocator());
        #endif
        vector(const vector&amp; x);
        ~vector();
        vector&amp; operator=(const vector&amp; x);
        #ifndef _MSL_NO_MEMBER_TEMPLATE
            template &lt;class InputIterator&gt;
                inline
                void assign(InputIterator first, InputIterator last)
                {
                    choose_assign(first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
                }
        #else
            void assign(const_iterator first, const_iterator last);
        #endif
        void assign(size_type n, const bool&amp; t);
        allocator_type get_allocator() const;
        // iterators:
        iterator               begin();
        const_iterator         begin() const;
        iterator               end();
        const_iterator         end() const;
        reverse_iterator       rbegin();
        const_reverse_iterator rbegin() const;
        reverse_iterator       rend();
        const_reverse_iterator rend() const;
        // capacity:
        size_type size() const;
        size_type max_size() const;
        void      resize(size_type sz, bool c = false);
        size_type capacity() const;
        bool      empty() const;
        void      reserve(size_type n);
        // element access:
        reference       operator[](size_type n);
        const_reference operator[](size_type n) const;
        const_reference at(size_type n) const;
        reference       at(size_type n);
        reference       front();
        const_reference front() const;
        reference       back();
        const_reference back() const;
        // modifiers:
        void push_back(const bool&amp; x);
        void pop_back();
        iterator insert(iterator position, const bool&amp; x);
        void     insert (iterator position, size_type n, const bool&amp; x);
        #ifndef _MSL_NO_MEMBER_TEMPLATE
            template &lt;class InputIterator&gt;
                inline
                void insert(iterator position, InputIterator first, InputIterator last)
                {
                    choose_insert(position, first, last, chooser&lt;numeric_limits&lt;InputIterator&gt;::is_integer&gt;());
                }
        #else
            void insert(iterator position, const_iterator first, const_iterator last);
        #endif
        iterator erase(iterator position);
        iterator erase(iterator first, iterator last);
        void swap(vector&amp;);
        static void swap(reference x, reference y);
        void flip();                // flips all bits
        void clear();
    private:
        _EmptyMemberOpt&lt;internal_allocator, size_type&gt; alloc_;  // m_ is capacity
        size_type size_;
        pointer data_;
        static const size_type num_bits_word = CHAR_BIT * sizeof(ia_value_type);

        #ifndef _MSL_NO_MEMBER_TEMPLATE

            template &lt;class InputIterator&gt;
                inline
                void
                choose_init(InputIterator first, InputIterator last, chooser&lt;true&gt;)
                {
                    init(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
                }

            template &lt;class InputIterator&gt;
                inline
                void
                choose_init(InputIterator first, InputIterator last, chooser&lt;false&gt;)
                {
                    init(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
                }

            template &lt;class InputIterator&gt;
                void
                init(InputIterator first, InputIterator last, input_iterator_tag)
                {
                    #ifndef _MSL_NO_EXCEPTIONS
                    try
                    {
                    #endif
                        for (; first != last; ++first)
                            push_back(*first);
                    #ifndef _MSL_NO_EXCEPTIONS
                    }
                    catch (...)
                    {
                        tear_down();
                        throw;
                    }
                    #endif
                }

            // hh 990222 Removed init(ForwardIterator, ForwardIterator, forward_iterator_tag)

            template &lt;class InputIterator&gt;
                inline
                void
                choose_assign(InputIterator first, InputIterator last, chooser&lt;true&gt;)
                {
                    assign(static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
                }

            template &lt;class InputIterator&gt;
                inline
                void
                choose_assign(InputIterator first, InputIterator last, chooser&lt;false&gt;)
                {
                    do_assign(first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
                }

            template &lt;class InputIterator&gt;
                void
                do_assign(InputIterator first, InputIterator last, input_iterator_tag)
                {
                    vector temp(first, last, get_allocator());
                    const vector&amp; tempr = temp;
                    do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
                }

            template &lt;class ForwardIterator&gt;
                void
                do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
                {
                    size_type n = (size_type)distance(first, last);
                    if (n &gt; max_size())
                        #ifndef _MSL_NO_EXCEPTIONS
                            throw length_error(&quot;vector::assign length error&quot;);
                        #else
                            __msl_error(&quot;vector::assign length error\n&quot;);
                        #endif
                    if (n &lt;= capacity())
                    {
                        size_ = 0;
                        for (size_type i = 0; i &lt; n; ++i, ++first)
                            push_back(*first);
                    }
                    else
                    {
                        pointer olddata = data_;
                        size_type newcap = recommend(n);
                        size_type nw = num_words(newcap);
                        data_ = alloc_.allocate(nw);
                        if (olddata != 0)
                            alloc_.deallocate(olddata, num_words(alloc_.m_));
                        size_ = 0;
                        alloc_.m_ = newcap;
                        for (size_type i = 0; i &lt; n; ++i, ++first)
                            push_back(*first);
                    }
                }

            template &lt;class InputIterator&gt;
                inline
                void
                choose_insert(iterator position, InputIterator first, InputIterator last,
                    chooser&lt;true&gt;)
                {
                    insert(position, static_cast&lt;size_type&gt;(first), static_cast&lt;value_type&gt;(last));
                }

            template &lt;class InputIterator&gt;
                inline
                void
                choose_insert(iterator position, InputIterator first, InputIterator last,
                    chooser&lt;false&gt;)
                {
                    do_insert(position, first, last, iterator_traits&lt;InputIterator&gt;::iterator_category());
                }

            template &lt;class InputIterator&gt;
                void
                do_insert(iterator position, InputIterator first, InputIterator last,
                    input_iterator_tag)
                {
                    vector temp(first, last, get_allocator());
                    const vector&amp; tempr = temp;
                    do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());
                }

            template &lt;class ForwardIterator&gt;
                void
                do_insert(iterator position, ForwardIterator first, ForwardIterator last,
                    forward_iterator_tag)
                {
                    size_type n = (size_type)distance(first, last);
                    if (n == 0)
                        return;
                    size_type ms = max_size();
                    if (n &gt; ms || size_ &gt; ms - n)
                        #ifndef _MSL_NO_EXCEPTIONS
                            throw length_error(&quot;vector::insert length error&quot;);
                        #else
                            __msl_error(&quot;vector::insert length error\n&quot;);
                        #endif
                    if (size_ + n &gt; capacity())
                    {
                        size_type newsize = size_ + n;
                        size_type newcap = alloc_.m_;
                        if (newcap == 0)
                            newcap = 1;
                        while (newsize &gt; newcap)
                            newcap *= 2;
                        pointer olddata = data_;
                        data_ = alloc_.allocate(num_words(newcap));
                        if (olddata != 0)
                        {
                            size_type nw = num_words(alloc_.m_);
                            copy(olddata, olddata + nw, data_);
                            alloc_.deallocate(olddata, nw);
                        }
                        alloc_.m_ = newcap;
                    }
                    size_type n1 = size_type(end() - position);
                    if (n1 &gt; 0)
                        shift_out(position, n);
                    copy(first, last, position);
                    size_ += n;
                }

        #endif

        void init(size_type n, const bool&amp; value);
        void init(iterator first, iterator last, random_access_iterator_tag);
        void init(const_iterator first, const_iterator last, random_access_iterator_tag);
        void tear_down();
        void do_assign(iterator first, iterator last, random_access_iterator_tag);
        void do_assign(const_iterator first, const_iterator last, random_access_iterator_tag);
        void do_insert(iterator position, iterator first, iterator last, random_access_iterator_tag);
        void do_insert(iterator position, const_iterator first, const_iterator last, random_access_iterator_tag);
        bool test_bit(size_type pos);
        void set(size_type pos, bool x);
        void set(size_type pos, size_type n, bool x);
        void flip(size_type pos);
        void copy_bits(const_pointer frmdata, size_type first, size_type last, size_type to);
        void shift_out(iterator pos, size_type n);
        void shift_in(iterator pos, size_type n);
        void trim() const;
        static size_type num_words(size_type capacity);  // capacity must be &gt; 0
        static size_type recommend(size_type capacity);

        friend bool operator== &lt;Allocator&gt;(const vector&amp; x, const vector&amp; y);
    };

    template &lt;class Allocator&gt;
    bool
    operator==(const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y);

    template &lt;class Allocator&gt;
    bool
    operator&lt; (const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y);

    template &lt;class Allocator&gt;
    bool
    operator!=(const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y);

    template &lt;class Allocator&gt;
    bool
    operator&gt; (const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y);

    template &lt;class Allocator&gt;
    bool
    operator&gt;=(const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y);

    template &lt;class Allocator&gt;
    bool
    operator&lt;=(const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y);

    // specialized algorithms:
    template &lt;class Allocator&gt;
    void
    swap(vector&lt;bool,Allocator&gt;&amp; x, vector&lt;bool,Allocator&gt;&amp; y);

    // Implementation vector&lt;bool&gt;

    template &lt;class Allocator&gt;
    inline
    vector&lt;bool, Allocator&gt;::vector(const Allocator&amp; a)
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        : alloc_(internal_allocator(a)),
    #else
        :
    #endif
          size_(0),
          data_(0)
    {
    }

    template &lt;class Allocator&gt;
    inline
    vector&lt;bool, Allocator&gt;::vector(size_type n, const bool&amp; value, const Allocator&amp; a)
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        : alloc_(internal_allocator(a)),
    #else
        :
    #endif
          size_(0),
          data_(0)
    {
        init(n, value);
    }     

    #ifdef _MSL_NO_MEMBER_TEMPLATE

        template &lt;class Allocator&gt;
        inline
        vector&lt;bool, Allocator&gt;::vector(const_iterator first, const_iterator last, const Allocator&amp; a)
        #ifndef _MSL_NO_MEMBER_TEMPLATE
            : alloc_(internal_allocator(a), size_type(last - first)),
        #else
            : alloc_(internal_allocator(), size_type(last - first)),
        #endif
              size_(alloc_.m_),
              data_(0)
        {
            init(first, last, random_access_iterator_tag());
        }

    #endif

    template &lt;class Allocator&gt;
    vector&lt;bool, Allocator&gt;::vector(const vector&amp; x)
    #ifndef _MSL_NO_MEMBER_TEMPLATE
        : alloc_(internal_allocator(x.alloc_), x.size_),
    #else
        : alloc_(internal_allocator(), x.size_),
    #endif
          size_(x.size_),
          data_(0)
    {
        if (alloc_.m_ &gt; 0)
        {
            alloc_.m_ = recommend(alloc_.m_);
            size_type nw = num_words(alloc_.m_);
            data_ = alloc_.allocate(nw);
            copy(x.data_, x.data_ + nw, data_);
        }
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::init(size_type n, const bool&amp; value)
    {
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::construction length error&quot;);
            #else
                __msl_error(&quot;vector::construction length error\n&quot;);
            #endif
        if (n &gt; 0)
        {
            size_ = n;
            alloc_.m_ = recommend(n);
            size_type nw = num_words(alloc_.m_);
            data_ = alloc_.allocate(nw);
            ia_value_type v = value ? ia_value_type(-1) : ia_value_type(0);
            for (size_type i = 0; i &lt; nw; ++i)
                data_[i] = v;
        }
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;bool, Allocator&gt;::init(iterator first, iterator last, random_access_iterator_tag)
    {
        init(const_iterator(first), const_iterator(last), random_access_iterator_tag());
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::init(const_iterator first, const_iterator last, random_access_iterator_tag)
    {
        size_type n = size_type(last - first);
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::construction length error&quot;);
            #else
                __msl_error(&quot;vector::construction length error\n&quot;);
            #endif
        if (n &gt; 0)
        {
            alloc_.m_ = recommend(n);
            data_ = alloc_.allocate(num_words(alloc_.m_));
            copy_bits(first.vec_-&gt;data_, first.pos_, last.pos_, 0);
            size_ = n;
        }
    }

    template &lt;class Allocator&gt;
    inline
    vector&lt;bool, Allocator&gt;::~vector()
    {
        tear_down();
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;bool, Allocator&gt;::tear_down()
    {
        if (data_ != 0)
            alloc_.deallocate(data_, num_words(alloc_.m_));
    }

    template &lt;class Allocator&gt;
    vector&lt;bool, Allocator&gt;&amp;
    vector&lt;bool, Allocator&gt;::operator=(const vector&amp; x)
    {
        if (this != &amp;x)
        {
            if (capacity() &lt; x.size())
            {
                pointer olddata = data_;
                size_type newcap = recommend(x.size());
                size_type nw = num_words(newcap);
                data_ = alloc_.allocate(nw);
                if (olddata != 0)
                    alloc_.deallocate(olddata, num_words(alloc_.m_));
                alloc_.m_ = newcap;
            }
            size_ = x.size();
            if (x.size() &gt; 0)
            {
                size_type nw = num_words(x.size());
                for (size_type i = 0; i &lt; nw; ++i)
                    data_[i] = x.data_[i];
            }
        }
        return *this;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::assign(size_type n, const value_type&amp; u)
    {
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::assign length error&quot;);
            #else
                __msl_error(&quot;vector::assign length error\n&quot;);
            #endif
        if (n &gt; capacity())
        {
            pointer olddata = data_;
            size_type newcap = recommend(n);
            size_type nw = num_words(newcap);
            data_ = alloc_.allocate(nw);
            if (olddata != 0)
                alloc_.deallocate(olddata, num_words(alloc_.m_));
            alloc_.m_ = newcap;
        }
        size_ = n;
        if (n &gt; 0)
        {
            n = num_words(n);
            ia_value_type v = u ? ia_value_type(-1) : ia_value_type(0);
            for (size_type i = 0; i &lt; n; ++i)
                data_[i] = v;
        }
    }

    #ifdef _MSL_NO_MEMBER_TEMPLATE

        template &lt;class Allocator&gt;
        inline
        void
        vector&lt;bool, Allocator&gt;::assign(const_iterator first, const_iterator last)
        {
            do_assign(first, last, random_access_iterator_tag());
        }

    #endif

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;bool, Allocator&gt;::do_assign(iterator first, iterator last, random_access_iterator_tag)
    {
        do_assign(const_iterator(first), const_iterator(last), random_access_iterator_tag());
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::do_assign(const_iterator first, const_iterator last, random_access_iterator_tag)
    {
        size_type n = (size_type)(last - first);
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::assign length error&quot;);
            #else
                __msl_error(&quot;vector::assign length error\n&quot;);
            #endif
        if (n &gt; capacity())
        {
            pointer olddata = data_;
            size_type newcap = recommend(n);
            size_type nw = num_words(newcap);
            data_ = alloc_.allocate(nw);
            if (olddata != 0)
                alloc_.deallocate(olddata, num_words(alloc_.m_));
            alloc_.m_ = newcap;
        }
        size_ = n;
        if (n &gt; 0)
            copy_bits(first.vec_-&gt;data_, first.pos_, last.pos_, 0);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::allocator_type
    vector&lt;bool, Allocator&gt;::get_allocator() const
    {
        #ifndef _MSL_NO_MEMBER_TEMPLATE
            return allocator_type(alloc_);
        #else
            return allocator_type();
        #endif
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::iterator
    vector&lt;bool, Allocator&gt;::begin()
    {
        return iterator(this, 0);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::const_iterator
    vector&lt;bool, Allocator&gt;::begin() const
    {
        return const_iterator(this, 0);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::iterator
    vector&lt;bool, Allocator&gt;::end()
    {
        return iterator(this, size_);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::const_iterator
    vector&lt;bool, Allocator&gt;::end() const
    {
        return const_iterator(this, size_);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::reverse_iterator
    vector&lt;bool, Allocator&gt;::rbegin()
    {
        return reverse_iterator(end());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::const_reverse_iterator
    vector&lt;bool, Allocator&gt;::rbegin() const
    {
        return const_reverse_iterator(end());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::reverse_iterator
    vector&lt;bool, Allocator&gt;::rend()
    {
        return reverse_iterator(begin());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::const_reverse_iterator
    vector&lt;bool, Allocator&gt;::rend() const
    {
        return const_reverse_iterator(begin());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::size_type
    vector&lt;bool, Allocator&gt;::size() const
    {
        return size_;
    }

    template &lt;class Allocator&gt;
    typename vector&lt;bool, Allocator&gt;::size_type
    vector&lt;bool, Allocator&gt;::max_size() const
    {
        size_type ms = alloc_.max_size();
        size_type mx = numeric_limits&lt;size_type&gt;::max();
        if (ms &gt; mx / num_bits_word)
            return mx;
        return ms * num_bits_word;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::resize(size_type sz, value_type c)
    {
        if (sz &gt; size())
            insert(end(), sz-size(), c);
        else if (sz &lt; size())
            erase(begin() + difference_type(sz), end());
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::size_type
    vector&lt;bool, Allocator&gt;::capacity() const
    {
        return alloc_.m_;
    }

    template &lt;class Allocator&gt;
    inline
    bool
    vector&lt;bool, Allocator&gt;::empty() const
    {
        return size_ == 0;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::reserve(size_type n)
    {
        if (n &gt; max_size())
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::reserve length error&quot;);
            #else
                __msl_error(&quot;vector::reserve length error\n&quot;);
            #endif
        if (n &gt; capacity())
        {
            pointer olddata = data_;
            size_type newcap = recommend(n);
            size_type nw = num_words(newcap);
            data_ = alloc_.allocate(nw);
            if (olddata != 0)
            {
                nw = num_words(alloc_.m_);
                for (size_type i = 0; i &lt; nw; ++i)
                    data_[i] = olddata[i];
                alloc_.deallocate(olddata, num_words(alloc_.m_));
            }
            alloc_.m_ = newcap;
        }
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::reference
    vector&lt;bool, Allocator&gt;::operator[](size_type n)
    {
        return reference(*this, n);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::const_reference
    vector&lt;bool, Allocator&gt;::operator[](size_type n) const
    {
        return reference(*(vector*)this, n);
    }

    template &lt;class Allocator&gt;
    typename vector&lt;bool, Allocator&gt;::const_reference
    vector&lt;bool, Allocator&gt;::at(size_type n) const
    {
        if (n &gt;= size_)
            #ifndef _MSL_NO_EXCEPTIONS
                throw out_of_range(&quot;vector::at index out of range&quot;);
            #else
                __msl_error(&quot;vector::at index out of range&quot;);
            #endif
        return reference(*(vector*)this, n);
    }

    template &lt;class Allocator&gt;
    typename vector&lt;bool, Allocator&gt;::reference
    vector&lt;bool, Allocator&gt;::at(size_type n)
    {
        if (n &gt;= size_)
            #ifndef _MSL_NO_EXCEPTIONS
                throw out_of_range(&quot;vector::at index out of range&quot;);
            #else
                __msl_error(&quot;vector::at index out of range&quot;);
            #endif
        return reference(*this, n);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::reference
    vector&lt;bool, Allocator&gt;::front()
    {
        return reference(*this, 0);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::const_reference
    vector&lt;bool, Allocator&gt;::front() const
    {
        return reference(*(vector*)this, 0);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::reference
    vector&lt;bool, Allocator&gt;::back()
    {
        return reference(*this, size_ - 1);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::const_reference
    vector&lt;bool, Allocator&gt;::back() const
    {
        return reference(*(vector*)this, size_ - 1);
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;bool, Allocator&gt;::push_back(const value_type&amp; x)
    {
        insert(end(), x);
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;bool, Allocator&gt;::pop_back()
    {   
        erase(end() - 1);
    }

    template &lt;class Allocator&gt;
    typename vector&lt;bool, Allocator&gt;::iterator
    vector&lt;bool, Allocator&gt;::insert(iterator position, const value_type&amp; x)
    {
        difference_type pos = position - begin();
        insert(position, 1, x);
        return begin() + pos;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::insert(iterator position, size_type n, const value_type&amp; x)
    {
        if (n == 0)
            return;
        size_type ms = max_size();
        if (n &gt; ms || size_ &gt; ms - n)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::insert length error&quot;);
            #else
                __msl_error(&quot;vector::insert length error\n&quot;);
            #endif
        if (size_ + n &lt;= capacity())
        {
            size_type n1 = size_type(end() - position);
            if (n1 &gt; 0)
                shift_out(position, n);
            set(size_type(position - begin()), n, x);
            size_ += n;
        }
        else
        {
            pointer olddata = data_;
            size_type newsize = size_ + n;
            size_type newcap = alloc_.m_;
            size_type pos = size_type(position - begin());
            if (newcap == 0)
                newcap = recommend(1);
            while (newsize &gt; newcap)
                newcap *= 2;
            size_type nw = num_words(newcap);
            data_ = alloc_.allocate(nw);
            if (pos &gt; 0)
                copy_bits(olddata, 0, pos, 0);
            set(pos, n, x);
            if (pos &lt; size_)
                copy_bits(olddata, pos, size_, pos + n);
            if (olddata != 0)
                alloc_.deallocate(olddata, num_words(alloc_.m_));
            size_ = newsize;
            alloc_.m_ = newcap;
        }
    }

    #ifdef _MSL_NO_MEMBER_TEMPLATE

        template &lt;class Allocator&gt;
        inline
        void
        vector&lt;bool, Allocator&gt;::insert(iterator position, const_iterator first, const_iterator last)
        {
            do_insert(position, first, last, random_access_iterator_tag());
        }

    #endif

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;bool, Allocator&gt;::do_insert(iterator position, iterator first, iterator last,
        random_access_iterator_tag)
    {
        do_insert(position, const_iterator(first), const_iterator(last), random_access_iterator_tag());
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::do_insert(iterator position, const_iterator first,
        const_iterator last, random_access_iterator_tag)
    {
        size_type n = size_type(last - first);
        if (n == 0)
            return;
        size_type ms = max_size();
        if (n &gt; ms || size_ &gt; ms - n)
            #ifndef _MSL_NO_EXCEPTIONS
                throw length_error(&quot;vector::insert length error&quot;);
            #else
                __msl_error(&quot;vector::insert length error\n&quot;);
            #endif
        if (size_ + n &lt;= capacity())
        {
            size_type n1 = size_type(end() - position);
            if (n1 &gt; 0)
                shift_out(position, n);
            copy_bits(first.vec_-&gt;data_, first.pos_, last.pos_, position.pos_);
            size_ += n;
        }
        else
        {
            pointer olddata = data_;
            size_type newsize = size_ + n;
            size_type newcap = alloc_.m_;
            size_type pos = size_type(position - begin());
            if (newcap == 0)
                newcap = recommend(1);
            while (newsize &gt; newcap)
                newcap *= 2;
            size_type nw = num_words(newcap);
            data_ = alloc_.allocate(nw);
            if (pos &gt; 0)
                copy_bits(olddata, 0, pos, 0);
            copy_bits(first.vec_-&gt;data_, first.pos_, last.pos_, position.pos_);
            if (pos &lt; size_)
                copy_bits(olddata, pos, size_, pos + n);
            if (olddata != 0)
                alloc_.deallocate(olddata, num_words(alloc_.m_));
            size_ = newsize;
            alloc_.m_ = newcap;
        }
    }

    template &lt;class Allocator&gt;
    typename vector&lt;bool, Allocator&gt;::iterator
    vector&lt;bool, Allocator&gt;::erase(iterator position)
    {
        size_type n = size_type(end() - position - 1);
        if (n &gt; 0)
            shift_in(position + 1, 1);
        --size_;
        return position;
    }

    template &lt;class Allocator&gt;
    typename vector&lt;bool, Allocator&gt;::iterator
    vector&lt;bool, Allocator&gt;::erase(iterator first, iterator last)
    {
        if (first == last)
            return first;
        size_type n = size_type(end() - last);
        size_type len = size_type(last - first);
        if (n &gt; 0)
            shift_in(last, len);
        size_ -= len;
        return first;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::swap(vector&amp; x)
    {
        if (this != &amp;x)
        {
            _STD::swap(alloc_, x.alloc_);
            _STD::swap(size_, x.size_);
            _STD::swap(data_, x.data_);
        }
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::swap(reference x, reference y)
    {
        ia_value_type bitmaskx = ia_value_type(1) &lt;&lt; x.pos_ % num_bits_word;
        ia_value_type&amp; xref = x.vec_.data_[x.pos_ / num_bits_word];
        bool bx = bool(xref &amp; bitmaskx);
        ia_value_type bitmasky = ia_value_type(1) &lt;&lt; y.pos_ % num_bits_word;
        ia_value_type&amp; yref = y.vec_.data_[y.pos_ / num_bits_word];
        bool by = bool(yref &amp; bitmasky);
        if (bx ^ by)
        {
            if (by)
            {
                xref |= bitmaskx;
                yref &amp;= ~bitmasky;
            }
            else
            {
                xref &amp;= ~bitmaskx;
                yref |= bitmasky;
            }
        }
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::flip()
    {
        size_type nw = num_words(size_);
        for (size_type i = 0; i &lt; nw; ++i)
            data_[i] = ~data_[i];
    }

    template &lt;class Allocator&gt;
    inline
    void
    vector&lt;bool, Allocator&gt;::clear()
    {
        size_ = 0;
    }

    template &lt;class Allocator&gt;
    bool
    vector&lt;bool, Allocator&gt;::test_bit(size_type pos)
    {
        size_type word = pos / num_bits_word;
        ia_value_type bitmask = (ia_value_type)1 &lt;&lt; pos % num_bits_word;
        return bool(data_[word] &amp; bitmask);
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::set(size_type pos, bool x)
    {
        size_type word = pos / num_bits_word;
        ia_value_type bitmask = (ia_value_type)1 &lt;&lt; pos % num_bits_word;
        if (x)
            data_[word] |= bitmask;
        else
            data_[word] &amp;= ~bitmask;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::set(size_type pos, size_type n, bool x)
    {
        size_type w1 = pos / num_bits_word;
        size_type w2 = (pos + n - 1) / num_bits_word;
        ia_value_type bitmask1 = ia_value_type(-1) &lt;&lt; pos % num_bits_word;
        ia_value_type bitmask2 = ia_value_type(-1);
        ia_value_type tmp = num_bits_word - (pos + n) % num_bits_word;
        if (tmp &lt; num_bits_word)
            bitmask2 &gt;&gt;= tmp;
        if (w1 == w2)
        {
            bitmask1 &amp;= bitmask2;
            if (x)
                data_[w1] |= bitmask1;
            else
                data_[w1] &amp;= ~bitmask1;
        }
        else
        {
            if (x)
            {
                data_[w1] |= bitmask1;
                for (size_type i = w1 + 1; i &lt; w2; ++i)
                    data_[i] = ia_value_type(-1);
                data_[w2] |= bitmask2;
            }
            else
            {
                data_[w1] &amp;= ~bitmask1;
                for (size_type i = w1 + 1; i &lt; w2; ++i)
                    data_[i] = ia_value_type(0);
                data_[w2] &amp;= ~bitmask2;
            }
        }
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::flip(size_type pos)
    {
        size_type word = pos / num_bits_word;
        ia_value_type bitmask = (ia_value_type)1 &lt;&lt; pos % num_bits_word;
        ia_value_type&amp; bits = data_[word];
        if (bits &amp; bitmask)
            bits &amp;= ~bitmask;
        else
            bits |= bitmask;
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::copy_bits(const_pointer frmdata, size_type first, size_type last,
        size_type to)
    {
        while (first != last)
        {
            size_type len = last - first;
            size_type o1 = first % num_bits_word;
            size_type o2 = to    % num_bits_word;
            size_type tmp = num_bits_word - o1;
            if (len &gt; tmp)
                len = tmp;
            tmp = num_bits_word - o2;
            if (len &gt; tmp)
                len = tmp;
            ia_value_type lmask = ia_value_type(-1) &lt;&lt; o1;
            ia_value_type rmask = ia_value_type(-1);
            tmp = (num_bits_word - (first + len) % num_bits_word);
            if (tmp &lt; num_bits_word)
                rmask &gt;&gt;= tmp;
            ia_value_type mask = lmask &amp; rmask;
            ia_value_type bits = frmdata[first / num_bits_word] &amp; mask;
            if (o1 &lt; o2)
            {
                bits &lt;&lt;= (o2 - o1);
                mask &lt;&lt;= (o2 - o1);
            }
            else if (o2 &lt; o1)
            {
                bits &gt;&gt;= (o1 - o2);
                mask &gt;&gt;= (o1 - o2);
            }
            ia_value_type&amp; target = data_[to / num_bits_word];
            target &amp;= ~mask;
            target |= bits;
            first += len;
            to += len;
        }
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::shift_out(iterator pos, size_type n)
    {
        size_type floor = pos.pos_ / num_bits_word;
        ia_value_type floormask = ia_value_type(-1) &lt;&lt; pos.pos_ % num_bits_word;
        size_type offset = n / num_bits_word;
        size_type nwords = num_words(size_ + n);
        size_type e = floor + offset;
        if (offset &gt; 0)
        {
            for (size_type i = nwords - 1; i &gt;= e; --i)
                data_[i] = data_[i-offset];
        }
        ia_value_type rshift = num_bits_word - n % num_bits_word;
        ia_value_type lshift = n % num_bits_word;
        for (size_type i = nwords - 1; i &gt; e; --i)
        {
            data_[i] &lt;&lt;= lshift;
            data_[i] |= data_[i-1] &gt;&gt; rshift;
        }
        if (offset &gt; 0 || floormask == ia_value_type(-1))
            data_[e] &lt;&lt;= lshift;
        else
        {
            ia_value_type tmp = data_[e];
            data_[e] &lt;&lt;= lshift;
            data_[e] &amp;= floormask;
            data_[e] |= ~floormask &amp; tmp;
        }
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::shift_in(iterator pos, size_type n)
    {
        size_type floor = (pos.pos_ - n) / num_bits_word;
        ia_value_type floormask = ia_value_type(-1) &lt;&lt; (pos.pos_ - n) % num_bits_word;
        size_type offset = n / num_bits_word;
        size_type nwords = num_words(size_);
        size_type e = nwords - offset;
        if (offset &gt; 0)
        {
            if (floormask == ia_value_type(-1))
                data_[floor] = data_[floor+offset];
            else
            {
                ia_value_type tmp = data_[floor];
                data_[floor] = data_[floor+offset];
                data_[floor] &amp;= floormask;
                data_[floor] |= ~floormask &amp; tmp;
            }
            for (size_type i = floor + 1; i &lt; e; ++i)
                data_[i] = data_[i+offset];
        }
        ia_value_type rshift = n % num_bits_word;
        ia_value_type lshift = num_bits_word - n % num_bits_word;
        if (floormask == ia_value_type(-1))
        {
            data_[floor] &gt;&gt;= rshift;
            if (floor &lt; nwords - 1)
                data_[floor] |= data_[floor + 1] &lt;&lt; lshift;
        }
        else
        {
            ia_value_type tmp = data_[floor];
            data_[floor] &gt;&gt;= rshift;
            if (floor &lt; nwords - 1)
                data_[floor] |= data_[floor + 1] &lt;&lt; lshift;
            data_[floor] &amp;= floormask;
            data_[floor] |= ~floormask &amp; tmp;
        }
        for (size_type i = floor + 1; i &lt; nwords - 1; ++i)
        {
            data_[i] &gt;&gt;= rshift;
            data_[i] |= data_[i+1] &lt;&lt; lshift;
        }
        if (floor != nwords - 1)
        {
            if (floormask == ia_value_type(-1))
                data_[nwords - 1] &gt;&gt;= rshift;
            else
            {
                ia_value_type tmp = data_[nwords - 1];
                data_[nwords - 1] &gt;&gt;= rshift;
                data_[nwords - 1] &amp;= floormask;
                data_[nwords - 1] |= ~floormask &amp; tmp;
            }
        }
    }

    template &lt;class Allocator&gt;
    void
    vector&lt;bool, Allocator&gt;::trim() const
    {
        size_type n = alloc_.m_ - size_;
        if (n &gt; 0)
            ((vector*)this)-&gt;set(size_, n, false);
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::size_type
    vector&lt;bool, Allocator&gt;::num_words(size_type capacity)
    {
        return (capacity - 1) / num_bits_word + 1;
    }

    template &lt;class Allocator&gt;
    inline
    typename vector&lt;bool, Allocator&gt;::size_type
    vector&lt;bool, Allocator&gt;::recommend(size_type capacity)
    {
        return capacity + num_bits_word - ((capacity - 1) % num_bits_word + 1);
    }

    template &lt;class Allocator&gt;
    bool
    operator==(const vector&lt;bool, Allocator&gt;&amp; x, const vector&lt;bool, Allocator&gt;&amp; y)
    {
        if (x.size() != y.size())
            return false;
        if (x.size() == 0)
            return true;
        x.trim();
        y.trim();
        return equal(x.data_, x.data_ + vector&lt;bool, Allocator&gt;::num_words(x.size_), y.data_);
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator!=(const vector&lt;bool, Allocator&gt;&amp; x, const vector&lt;bool, Allocator&gt;&amp; y)
    {
        return !(x == y);
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&lt; (const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y)
    {
        return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&gt; (const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y)
    {
        return y &lt; x;
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&gt;=(const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y)
    {
        return !(x &lt; y);
    }

    template &lt;class Allocator&gt;
    inline
    bool
    operator&lt;=(const vector&lt;bool,Allocator&gt;&amp; x, const vector&lt;bool,Allocator&gt;&amp; y)
    {
        return !(y &lt; x);
    }

    template &lt;class Allocator&gt;
    inline
    void
    swap(vector&lt;bool,Allocator&gt;&amp; x, vector&lt;bool,Allocator&gt;&amp; y)
    {
        x.swap(y);
    }

#endif // !__GNUC__
#endif // _MSL_NO_PARTIAL_SPECIALIZATION

#ifndef _MSL_NO_CPP_NAMESPACE
    } // namespace std 
#endif

#if defined(__CFM68K__) &amp;&amp; !defined(__USING_STATIC_LIBS__)
    #pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _VECTOR

// hh 981005 rewrote
// hh 981208 changed static_cast to reinterpret_cast on the value_type (pointer specialization only)
// hh 981220 Added typename to appropriate return types
// hh 981220 Modifed some method signitures to simplified syntax
// hh 981221 changed static_cast to reinterpret_cast on the value_type (pointer specialization only)
// hh 990120 changed name of MSIPL flags
// hh 990217 Specialized push_back (used to call insert)
// hh 990222 Removed init(ForwardIterator, ForwardIterator, forward_iterator_tag) from vector&lt;bool&gt;.
//           It was both incorrect and unnecessary.
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>