<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File msghndlr.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-msghndlrc">File msghndlr.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_25028620cc1a8a9857c414f885e69890/"><strong>MetroTRK</strong></a> <strong>&gt;</strong> <a href="../dir_6f2d6a2144e1eea12d16d0bd9685bdc9/"><strong>Src</strong></a> <strong>&gt;</strong> <a href="../dir_5cbf840bf773d4847fc83ef20b01209e/"><strong>Portable</strong></a> <strong>&gt;</strong> <a href="../msghndlr_8c/"><strong>msghndlr.c</strong></a></p>
<p><a href="../msghndlr_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#include &quot;Portable/msghndlr.h&quot;
#include &quot;Portable/nubevent.h&quot;
#include &quot;Portable/msgbuf.h&quot;
#include &quot;Portable/msg.h&quot;
#include &quot;Os/dolphin/targcont.h&quot;
#include &quot;Processor/ppc/Generic/targimpl.h&quot;
#include &quot;trk.h&quot;

static void TRKMessageIntoReply(TRKBuffer* buffer, u8 ackCmd,
                                DSReplyError errSentInAck)
{
    TRKResetBuffer(buffer, 1);

    TRKAppendBuffer1_ui8(buffer, ackCmd);
    TRKAppendBuffer1_ui8(buffer, errSentInAck);
}

DSError TRKSendACK(TRKBuffer* buffer)
{
    DSError err;
    int ackTries;

    ackTries = 3;
    do {
        err = TRKMessageSend((TRK_Msg*)buffer);
        --ackTries;
    } while (err != DS_NoError &amp;&amp; ackTries &gt; 0);

    return err;
}

DSError TRKStandardACK(TRKBuffer* buffer, MessageCommandID commandID,
                       DSReplyError replyError)
{
    TRKMessageIntoReply(buffer, commandID, replyError);
    TRKSendACK(buffer);
    return DS_NoError;
}

DSError TRKDoUnsupported(TRKBuffer* buffer)
{
    return TRKStandardACK(buffer, DSMSG_ReplyACK,
                          DSREPLY_UnsupportedCommandError);
}

DSError TRKDoConnect(TRKBuffer* buffer)
{
    return TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_NoError);
}

DSError TRKDoDisconnect(TRKBuffer* buffer)
{
    DSError error = DS_NoError;
    TRKEvent event;

    if ((error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_NoError))
        == DS_NoError) {
        TRKConstructEvent(&amp;event, 1);
        TRKPostEvent(&amp;event);
    }
    return error;
}

DSError TRKDoReset(TRKBuffer* buffer)
{
    TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_NoError);
    __TRK_reset();
    return DS_NoError;
}

DSError TRKDoVersions(TRKBuffer* buffer)
{
    DSError error;
    DSVersions versions;

    if (buffer-&gt;length != 1) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);
    } else {
        TRKMessageIntoReply(buffer, DSMSG_ReplyACK, DSREPLY_NoError);
        error = TRKTargetVersions(&amp;versions);

        if (error == DS_NoError)
            error = TRKAppendBuffer1_ui8(buffer, versions.kernelMajor);
        if (error == DS_NoError)
            error = TRKAppendBuffer1_ui8(buffer, versions.kernelMinor);
        if (error == DS_NoError)
            error = TRKAppendBuffer1_ui8(buffer, versions.protocolMajor);
        if (error == DS_NoError)
            error = TRKAppendBuffer1_ui8(buffer, versions.protocolMinor);

        if (error != DS_NoError)
            error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_CWDSError);
        else
            error = TRKSendACK(buffer);
    }
    return error;
}

DSError TRKDoSupportMask(TRKBuffer* buffer)
{
    DSError error;
    u8 mask[32];

    if (buffer-&gt;length == 1) {
        TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);
    } else {
        TRKMessageIntoReply(buffer, DSMSG_ReplyACK, DSREPLY_NoError);
        error = TRKTargetSupportMask(mask);

        if (error == DS_NoError)
            error = TRKAppendBuffer(buffer, mask, 32);
        if (error == DS_NoError)
            error = TRKAppendBuffer1_ui8(buffer, 2);

        if (error != DS_NoError)
            TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_CWDSError);
        else
            TRKSendACK(buffer);
    }
}

DSError TRKDoCPUType(TRKBuffer* buffer)
{
    DSError error;
    DSCPUType cputype;

    if (buffer-&gt;length != 1) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);
        return error;
    }

    TRKMessageIntoReply(buffer, DSMSG_ReplyACK, DSREPLY_NoError);

    error = TRKTargetCPUType(&amp;cputype);

    if (error == DS_NoError)
        error = TRKAppendBuffer1_ui8(buffer, cputype.cpuMajor);
    if (error == DS_NoError)
        error = TRKAppendBuffer1_ui8(buffer, cputype.cpuMinor);
    if (error == DS_NoError)
        error = TRKAppendBuffer1_ui8(buffer, cputype.bigEndian);
    if (error == DS_NoError)
        error = TRKAppendBuffer1_ui8(buffer, cputype.defaultTypeSize);
    if (error == DS_NoError)
        error = TRKAppendBuffer1_ui8(buffer, cputype.fpTypeSize);
    if (error == DS_NoError)
        error = TRKAppendBuffer1_ui8(buffer, cputype.extended1TypeSize);
    if (error == DS_NoError)
        error = TRKAppendBuffer1_ui8(buffer, cputype.extended2TypeSize);

    if (error != DS_NoError)
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_CWDSError);
    else
        error = TRKSendACK(buffer);

    return error;
}

DSError TRKDoReadMemory(TRKBuffer* buffer)
{
    DSError error;
    DSReplyError replyError;
    u8 tempBuf[0x800];
    u32 length;
    u32 msg_start;
    u16 msg_length;
    u8 msg_options;
    u8 msg_command;

    if (buffer-&gt;length != 8) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);
        return error;
    }

    TRKSetBufferPosition(buffer, DSREPLY_NoError);
    error = TRKReadBuffer1_ui8(buffer, &amp;msg_command);
    if (error == DS_NoError)
        error = TRKReadBuffer1_ui8(buffer, &amp;msg_options);

    if (error == DS_NoError)
        error = TRKReadBuffer1_ui16(buffer, &amp;msg_length);

    if (error == DS_NoError)
        error = TRKReadBuffer1_ui32(buffer, &amp;msg_start);

    if (msg_options &amp; 2) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK,
                               DSREPLY_UnsupportedOptionError);
        return error;
    }

    if (msg_length &gt; 0x800) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_ParameterError);
        return error;
    }

    TRKMessageIntoReply(buffer, DSMSG_ReplyACK, DSREPLY_NoError);

    if (error == DS_NoError) {
        length = (u32)msg_length;
        error  = TRKTargetAccessMemory(
            tempBuf, msg_start, &amp;length,
            (msg_options &amp; 8) ? MEMACCESS_UserMemory : MEMACCESS_DebuggerMemory,
            1);
        msg_length = (u16)length;
        if (error == DS_NoError)
            error = TRKAppendBuffer1_ui16(buffer, msg_length);
        if (error == DS_NoError)
            error = TRKAppendBuffer(buffer, tempBuf, length);
    }

    if (error != DS_NoError) {
        switch (error) {
        case DS_CWDSException:
            replyError = DSREPLY_CWDSException;
            break;
        case DS_InvalidMemory:
            replyError = DSREPLY_InvalidMemoryRange;
            break;
        case DS_InvalidProcessID:
            replyError = DSREPLY_InvalidProcessID;
            break;
        case DS_InvalidThreadID:
            replyError = DSREPLY_InvalidThreadID;
            break;
        case DS_OSError:
            replyError = DSREPLY_OSError;
            break;
        default:
            replyError = DSREPLY_CWDSError;
            break;
        }
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, replyError);
    } else {
        error = TRKSendACK(buffer);
    }

    return error;
}

DSError TRKDoWriteMemory(TRKBuffer* buffer)
{
    DSError error;
    DSReplyError replyError;
    u8 tmpBuffer[0x800];
    u32 length;
    u32 msg_start;
    u16 msg_length;
    u8 msg_options;
    u8 msg_command;

    if (buffer-&gt;length &lt;= 8) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);
        return error;
    }

    TRKSetBufferPosition(buffer, DSREPLY_NoError);
    error = TRKReadBuffer1_ui8(buffer, &amp;msg_command);
    if (error == DS_NoError)
        error = TRKReadBuffer1_ui8(buffer, &amp;msg_options);

    if (error == DS_NoError)
        error = TRKReadBuffer1_ui16(buffer, &amp;msg_length);

    if (error == DS_NoError)
        error = TRKReadBuffer1_ui32(buffer, &amp;msg_start);

    if (msg_options &amp; 2) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK,
                               DSREPLY_UnsupportedOptionError);
        return error;
    }

    if ((buffer-&gt;length != msg_length + 8) || (msg_length &gt; 0x800)) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_ParameterError);
    } else {
        if (error == DS_NoError) {
            length = (u32)msg_length;
            error  = TRKReadBuffer(buffer, tmpBuffer, length);
            if (error == DS_NoError) {
                error = TRKTargetAccessMemory(tmpBuffer, msg_start, &amp;length,
                                              (msg_options &amp; 8)
                                                  ? MEMACCESS_UserMemory
                                                  : MEMACCESS_DebuggerMemory,
                                              FALSE);
            }
            msg_length = (u16)length;
        }

        if (error == DS_NoError)
            TRKMessageIntoReply(buffer, DSMSG_ReplyACK, DSREPLY_NoError);

        if (error == DS_NoError)
            error = TRKAppendBuffer1_ui16(buffer, msg_length);

        if (error != DS_NoError) {
            switch (error) {
            case DS_CWDSException:
                replyError = DSREPLY_CWDSException;
                break;
            case DS_InvalidMemory:
                replyError = DSREPLY_InvalidMemoryRange;
                break;
            case DS_InvalidProcessID:
                replyError = DSREPLY_InvalidProcessID;
                break;
            case DS_InvalidThreadID:
                replyError = DSREPLY_InvalidThreadID;
                break;
            case DS_OSError:
                replyError = DSREPLY_OSError;
                break;
            default:
                replyError = DSREPLY_CWDSError;
                break;
            }
            error = TRKStandardACK(buffer, DSMSG_ReplyACK, replyError);
        } else {
            error = TRKSendACK(buffer);
        }
    }

    return error;
}

DSError TRKDoReadRegisters(TRKBuffer* buffer)
{
    DSError error;
    DSReplyError replyError;
    DSMessageRegisterOptions options;
    u32 registerDataLength;
    u16 msg_lastRegister;
    u16 msg_firstRegister;
    u8 msg_options;
    u8 msg_command;

    if (buffer-&gt;length != 6) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);
        return error;
    }
    TRKSetBufferPosition(buffer, DSREPLY_NoError);
    error = TRKReadBuffer1_ui8(buffer, &amp;msg_command);
    if (error == DS_NoError)
        error = TRKReadBuffer1_ui8(buffer, &amp;msg_options);

    if (error == DS_NoError)
        error = TRKReadBuffer1_ui16(buffer, &amp;msg_firstRegister);

    if (error == DS_NoError)
        error = TRKReadBuffer1_ui16(buffer, &amp;msg_lastRegister);

    if (msg_firstRegister &gt; msg_lastRegister) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK,
                               DSREPLY_InvalidRegisterRange);
        return error;
    }

    if (error == DS_NoError)
        TRKMessageIntoReply(buffer, DSMSG_ReplyACK, DSREPLY_NoError);

    options = (DSMessageRegisterOptions)msg_options;
    switch (options) {
    case DSREG_Default:
        error = TRKTargetAccessDefault(msg_firstRegister, msg_lastRegister,
                                       buffer, &amp;registerDataLength, TRUE);
        break;
    case DSREG_FP:
        error = TRKTargetAccessFP(msg_firstRegister, msg_lastRegister, buffer,
                                  &amp;registerDataLength, TRUE);
        break;
    case DSREG_Extended1:
        error = TRKTargetAccessExtended1(msg_firstRegister, msg_lastRegister,
                                         buffer, &amp;registerDataLength, TRUE);
        break;
    case DSREG_Extended2:
        error = TRKTargetAccessExtended2(msg_firstRegister, msg_lastRegister,
                                         buffer, &amp;registerDataLength, TRUE);
        break;
    default:
        error = DS_UnsupportedError;
        break;
    }

    if (error != DS_NoError) {
        switch (error) {
        case DS_UnsupportedError:
            replyError = DSREPLY_UnsupportedOptionError;
            break;
        case DS_InvalidRegister:
            replyError = DSREPLY_InvalidRegisterRange;
            break;
        case DS_CWDSException:
            replyError = DSREPLY_CWDSException;
            break;
        case DS_InvalidProcessID:
            replyError = DSREPLY_InvalidProcessID;
            break;
        case DS_InvalidThreadID:
            replyError = DSREPLY_InvalidThreadID;
            break;
        case DS_OSError:
            replyError = DSREPLY_OSError;
            break;
        default:
            replyError = DSREPLY_CWDSError;
        }

        error = TRKStandardACK(buffer, DSMSG_ReplyACK, replyError);
    } else {
        error = TRKSendACK(buffer);
    }

    return error;
}

DSError TRKDoWriteRegisters(TRKBuffer* buffer)
{
    DSError error;
    DSReplyError replyError;
    DSMessageRegisterOptions options;
    u32 registerDataLength;
    u16 msg_lastRegister;
    u16 msg_firstRegister;
    u8 msg_options;
    u8 msg_command;

    if (buffer-&gt;length &lt;= 6) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);
        return error;
    }
    TRKSetBufferPosition(buffer, DSREPLY_NoError);
    error = TRKReadBuffer1_ui8(buffer, &amp;msg_command);
    if (error == DS_NoError)
        error = TRKReadBuffer1_ui8(buffer, &amp;msg_options);

    if (error == DS_NoError)
        error = TRKReadBuffer1_ui16(buffer, &amp;msg_firstRegister);

    if (error == DS_NoError)
        error = TRKReadBuffer1_ui16(buffer, &amp;msg_lastRegister);

    if (msg_firstRegister &gt; msg_lastRegister) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK,
                               DSREPLY_InvalidRegisterRange);
        return error;
    }

    options = (DSMessageRegisterOptions)msg_options;
    switch (options) {
    case DSREG_Default:
        error = TRKTargetAccessDefault(msg_firstRegister, msg_lastRegister,
                                       buffer, &amp;registerDataLength, FALSE);
        break;
    case DSREG_FP:
        error = TRKTargetAccessFP(msg_firstRegister, msg_lastRegister, buffer,
                                  &amp;registerDataLength, FALSE);
        break;
    case DSREG_Extended1:
        error = TRKTargetAccessExtended1(msg_firstRegister, msg_lastRegister,
                                         buffer, &amp;registerDataLength, FALSE);
        break;
    case DSREG_Extended2:
        error = TRKTargetAccessExtended2(msg_firstRegister, msg_lastRegister,
                                         buffer, &amp;registerDataLength, FALSE);
        break;
    default:
        error = DS_UnsupportedError;
        break;
    }

    if (error == DS_NoError)
        TRKMessageIntoReply(buffer, DSMSG_ReplyACK, DSREPLY_NoError);

    if (error != DS_NoError) {
        switch (error) {
        case DS_UnsupportedError:
            replyError = DSREPLY_UnsupportedOptionError;
            break;
        case DS_InvalidRegister:
            replyError = DSREPLY_InvalidRegisterRange;
            break;
        case DS_MessageBufferReadError:
            replyError = DSREPLY_PacketSizeError;
            break;
        case DS_CWDSException:
            replyError = DSREPLY_CWDSException;
            break;
        case DS_InvalidProcessID:
            replyError = DSREPLY_InvalidProcessID;
            break;
        case DS_InvalidThreadID:
            replyError = DSREPLY_InvalidThreadID;
            break;
        case DS_OSError:
            replyError = DSREPLY_OSError;
            break;
        default:
            replyError = DSREPLY_CWDSError;
        }

        error = TRKStandardACK(buffer, DSMSG_ReplyACK, replyError);
    } else {
        error = TRKSendACK(buffer);
    }

    return error;
}

DSError TRKDoFlushCache(TRKBuffer* buffer)
{
    DSError error;
    DSReplyError replyErr;
    u32 msg_end;
    u32 msg_start;
    u8 msg_options;
    u8 msg_command;

    if (buffer-&gt;length != 10) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);
        return error;
    }

    TRKSetBufferPosition(buffer, DSREPLY_NoError);
    error = TRKReadBuffer1_ui8(buffer, &amp;msg_command);
    if (error == DS_NoError)
        error = TRKReadBuffer1_ui8(buffer, &amp;msg_options);
    if (error == DS_NoError)
        error = TRKReadBuffer1_ui32(buffer, &amp;msg_start);
    if (error == DS_NoError)
        error = TRKReadBuffer1_ui32(buffer, &amp;msg_end);

    if (msg_start &gt; msg_end) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK,
                               DSREPLY_InvalidMemoryRange);
        return error;
    }

    if (error == DS_NoError)
        error = TRKTargetFlushCache(msg_options, (void*)msg_start,
                                    (void*)msg_end);

    if (error == DS_NoError)
        TRKMessageIntoReply(buffer, DSMSG_ReplyACK, DSREPLY_NoError);

    if (error != DS_NoError) {
        switch (error) {
        case DS_UnsupportedError:
            replyErr = DSREPLY_UnsupportedOptionError;
            break;
        default:
            replyErr = DSREPLY_CWDSError;
            break;
        }

        error = TRKStandardACK(buffer, DSMSG_ReplyACK, replyErr);
    } else {
        error = TRKSendACK(buffer);
    }

    return error;
}

DSError TRKDoContinue(TRKBuffer* buffer)
{
    DSError error;

    error = TRKTargetStopped();
    if (error == DS_NoError) {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_NotStopped);
        return error;
    }

    error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_NoError);
    if (error == DS_NoError)
        error = TRKTargetContinue();

    return error;
}

DSError TRKDoStep(TRKBuffer* buffer)
{
    DSError error;
    u8 msg_command;
    u8 msg_options;
    u8 msg_count;
    u32 msg_rangeStart;
    u32 msg_rangeEnd;
    u32 pc;

    if (buffer-&gt;length &lt; 3)
        return TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_PacketSizeError);

    TRKSetBufferPosition(buffer, DSREPLY_NoError);

    error = TRKReadBuffer1_ui8(buffer, &amp;msg_command);
    if (error == DS_NoError)
        error = TRKReadBuffer1_ui8(buffer, &amp;msg_options);

    switch (msg_options) {
    case DSSTEP_IntoCount:
    case DSSTEP_OverCount:
        if (error == DS_NoError)
            TRKReadBuffer1_ui8(buffer, &amp;msg_count);
        if (msg_count &gt;= 1) {
            break;
        }
        return TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_ParameterError);
    case DSSTEP_IntoRange:
    case DSSTEP_OverRange:
        if (buffer-&gt;length != 10)
            return TRKStandardACK(buffer, DSMSG_ReplyACK,
                                  DSREPLY_PacketSizeError);

        if (error == DS_NoError)
            error = TRKReadBuffer1_ui32(buffer, &amp;msg_rangeStart);
        if (error == DS_NoError)
            error = TRKReadBuffer1_ui32(buffer, &amp;msg_rangeEnd);

        pc = TRKTargetGetPC();
        if (pc &gt;= msg_rangeStart &amp;&amp; pc &lt;= msg_rangeEnd) {
            break;
        }
        return TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_ParameterError);
    default:
        return TRKStandardACK(buffer, DSMSG_ReplyACK,
                              DSREPLY_UnsupportedOptionError);
    }

    if (!TRKTargetStopped()) {
        return TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_NotStopped);
    } else {
        error = TRKStandardACK(buffer, DSMSG_ReplyACK, DSREPLY_NoError);
        if (error == DS_NoError)
            switch (msg_options) {
            case DSSTEP_IntoCount:
            case DSSTEP_OverCount:
                error = TRKTargetSingleStep(msg_count,
                                            (msg_options == DSSTEP_OverCount));
                break;
            case DSSTEP_IntoRange:
            case DSSTEP_OverRange:
                error = TRKTargetStepOutOfRange(
                    msg_rangeStart, msg_rangeEnd,
                    (msg_options == DSSTEP_OverRange));
                break;
            }

        return error;
    }
}

DSError TRKDoStop(TRKBuffer* b)
{
    DSReplyError replyError;

    switch (TRKTargetStop()) {
    case DS_NoError:
        replyError = DSREPLY_NoError;
        break;
    case DS_InvalidProcessID:
        replyError = DSREPLY_InvalidProcessID;
        break;
    case DS_InvalidThreadID:
        replyError = DSREPLY_InvalidThreadID;
        break;
    case DS_OSError:
        replyError = DSREPLY_OSError;
        break;
    default:
        replyError = DSREPLY_Error;
        break;
    }

    return TRKStandardACK(b, DSMSG_ReplyACK, replyError);
}
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>