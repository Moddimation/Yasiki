<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project Yasiki: Decompilation of Luigi's Mansion.">
    <link rel="stylesheet" href="https://moddi.dev/Yasiki/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Reggae+One&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://moddi.dev/Yasiki/assets/favicon.ico" type="image/x-icon">
    <title>File k_standard.c - Project Yasiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <!--Upper bar-->
      <div id="bar">

          <!--Project text / logo-->
          <a id="barTitle" href="https://moddi.dev/Yasiki/"><b>Project Yasiki</b></a>
          <div style="display: flex; flex-direction: column; align-items: start;">
            
            <!--Both progress badges-->
            <a href="https://github.com/Moddimation/Yasiki">
              <img style="padding-top:10px; width: 90px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=code&label=Code" alt="Go to github repo">
            </a>
            <a href="https://decomp.dev/Moddimation/Yasiki">
              <img style="padding-bottom:0px; width: 123px;" src="https://decomp.dev/Moddimation/Yasiki.svg?mode=shield&measure=functions&label=Progress" alt="Go to progress page">
            </a>
          </div>
          
          <p> </p>
          
          <!--Add each nav head here-->
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/files/'">Files</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/classes/'">Classes</button>
            </li>
            <li>
              <button onclick="window.location.href='https://moddi.dev/Yasiki/wiki/'">Full Wiki</button>
            </li>
      </div>
      
      <h1 id="file-k_standardc">File k_standard.c</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_5331e34b666a7435d77010d6d501c7d4/"><strong>CodeWarrior</strong></a> <strong>&gt;</strong> <a href="../dir_5715a3597842aab210f9a54cf5907db0/"><strong>PowerPC_EABI_Support</strong></a> <strong>&gt;</strong> <a href="../dir_f3cdfadcca1881c964e98cde56e67e68/"><strong>Msl</strong></a> <strong>&gt;</strong> <a href="../dir_30eb297d72d9bf6e37ae97b245365a16/"><strong>MSL_C</strong></a> <strong>&gt;</strong> <a href="../dir_862c03c3c35584d0a555c3abef6e72a9/"><strong>MSL_Common_Embedded</strong></a> <strong>&gt;</strong> <a href="../dir_12110d18fe016ada0ac20ca931a7efb5/"><strong>Math</strong></a> <strong>&gt;</strong> <a href="../dir_4aa136d99b9df2fc861ef3e829b58508/"><strong>Double_precision</strong></a> <strong>&gt;</strong> <a href="../k__standard_8c/"><strong>k_standard.c</strong></a></p>
<p><a href="../k__standard_8c/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">
#ifndef _No_Floating_Point  
/* @(#)k_standard.c 1.2 95/01/04 */
/* $Id: k_standard.c,v 1.2.4.1 1999/12/06 19:47:53 fassiott Exp $ */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

#include &quot;fdlibm.h&quot;
#include &lt;errno.h&gt;

#ifndef _USE_WRITE
#include &lt;stdio.h&gt;          /* fputs(), stderr */
#define WRITE2(u,v) fputs(u, stderr)
#else   /* !defined(_USE_WRITE) */
#include &lt;unistd.h&gt;         /* write */
#define WRITE2(u,v) write(2, u, v)
#undef fflush
#endif  /* !defined(_USE_WRITE) */

static double zero = 0.0;   /* used as const */

/* 
 * Standard conformance (non-IEEE) on exception cases.
 * Mapping:
 *  1 -- acos(|x|&gt;1)
 *  2 -- asin(|x|&gt;1)
 *  3 -- atan2(+-0,+-0)
 *  4 -- hypot overflow
 *  5 -- cosh overflow
 *  6 -- exp overflow
 *  7 -- exp underflow
 *  8 -- y0(0)
 *  9 -- y0(-ve)
 *  10-- y1(0)
 *  11-- y1(-ve)
 *  12-- yn(0)
 *  13-- yn(-ve)
 *  14-- lgamma(finite) overflow
 *  15-- lgamma(-integer)
 *  16-- log(0)
 *  17-- log(x&lt;0)
 *  18-- log10(0)
 *  19-- log10(x&lt;0)
 *  20-- pow(0.0,0.0)
 *  21-- pow(x,y) overflow
 *  22-- pow(x,y) underflow
 *  23-- pow(0,negative) 
 *  24-- pow(neg,non-integral)
 *  25-- sinh(finite) overflow
 *  26-- sqrt(negative)
 *      27-- fmod(x,0)
 *      28-- remainder(x,0)
 *  29-- acosh(x&lt;1)
 *  30-- atanh(|x|&gt;1)
 *  31-- atanh(|x|=1)
 *  32-- scalb overflow
 *  33-- scalb underflow
 *  34-- j0(|x|&gt;X_TLOSS)
 *  35-- y0(x&gt;X_TLOSS)
 *  36-- j1(|x|&gt;X_TLOSS)
 *  37-- y1(x&gt;X_TLOSS)
 *  38-- jn(|x|&gt;X_TLOSS, n)
 *  39-- yn(x&gt;X_TLOSS, n)
 *  40-- gamma(finite) overflow
 *  41-- gamma(-integer)
 *  42-- pow(NaN,0.0)
 */


#ifdef __STDC__
    double __kernel_standard(double x, double y, int type) 
#else
    double __kernel_standard(x,y,type) 
    double x,y; int type;
#endif
{

    struct exception exc;
#ifndef HUGE_VAL    /* this is the only routine that uses HUGE_VAL */ 
#define HUGE_VAL inf
    double inf = 0.0;

    __HI(inf) = 0x7ff00000; /* set inf to infinite */
#endif

#ifdef _USE_WRITE
    (void) fflush(stdout);
#endif
    exc.arg1 = x;
    exc.arg2 = y;
    switch(type) {
        case 1:
        /* acos(|x|&gt;1) */
        exc.type = DOMAIN;
        exc.name = &quot;acos&quot;;
        exc.retval = zero;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if(_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;acos: DOMAIN error\n&quot;, 19);
          }
          errno = EDOM;
        }
        break;
        case 2:
        /* asin(|x|&gt;1) */
        exc.type = DOMAIN;
        exc.name = &quot;asin&quot;;
        exc.retval = zero;
        if(_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if(_LIB_VERSION == _SVID_) {
                (void) WRITE2(&quot;asin: DOMAIN error\n&quot;, 19);
          }
          errno = EDOM;
        }
        break;
        case 3:
        /* atan2(+-0,+-0) */
        exc.arg1 = y;
        exc.arg2 = x;
        exc.type = DOMAIN;
        exc.name = &quot;atan2&quot;;
        exc.retval = zero;
        if(_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if(_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;atan2: DOMAIN error\n&quot;, 20);
              }
          errno = EDOM;
        }
        break;
        case 4:
        /* hypot(finite,finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;hypot&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = HUGE;
        else
          exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 5:
        /* cosh(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;cosh&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = HUGE;
        else
          exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 6:
        /* exp(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;exp&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = HUGE;
        else
          exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 7:
        /* exp(finite) underflow */
        exc.type = UNDERFLOW;
        exc.name = &quot;exp&quot;;
        exc.retval = zero;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 8:
        /* y0(0) = -inf */
        exc.type = DOMAIN;  /* should be SING for IEEE */
        exc.name = &quot;y0&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;y0: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 9:
        /* y0(x&lt;0) = NaN */
        exc.type = DOMAIN;
        exc.name = &quot;y0&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;y0: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 10:
        /* y1(0) = -inf */
        exc.type = DOMAIN;  /* should be SING for IEEE */
        exc.name = &quot;y1&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;y1: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 11:
        /* y1(x&lt;0) = NaN */
        exc.type = DOMAIN;
        exc.name = &quot;y1&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;y1: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 12:
        /* yn(n,0) = -inf */
        exc.type = DOMAIN;  /* should be SING for IEEE */
        exc.name = &quot;yn&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;yn: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 13:
        /* yn(x&lt;0) = NaN */
        exc.type = DOMAIN;
        exc.name = &quot;yn&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;yn: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 14:
        /* lgamma(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;lgamma&quot;;
                if (_LIB_VERSION == _SVID_)
                  exc.retval = HUGE;
                else
                  exc.retval = HUGE_VAL;
                if (_LIB_VERSION == _POSIX_)
            errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        errno = ERANGE;
        }
        break;
        case 15:
        /* lgamma(-integer) or lgamma(0) */
        exc.type = SING;
        exc.name = &quot;lgamma&quot;;
                if (_LIB_VERSION == _SVID_)
                  exc.retval = HUGE;
                else
                  exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;lgamma: SING error\n&quot;, 19);
              }
          errno = EDOM;
        }
        break;
        case 16:
        /* log(0) */
        exc.type = SING;
        exc.name = &quot;log&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;log: SING error\n&quot;, 16);
              }
          errno = EDOM;
        }
        break;
        case 17:
        /* log(x&lt;0) */
        exc.type = DOMAIN;
        exc.name = &quot;log&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;log: DOMAIN error\n&quot;, 18);
              }
          errno = EDOM;
        }
        break;
        case 18:
        /* log10(0) */
        exc.type = SING;
        exc.name = &quot;log10&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;log10: SING error\n&quot;, 18);
              }
          errno = EDOM;
        }
        break;
        case 19:
        /* log10(x&lt;0) */
        exc.type = DOMAIN;
        exc.name = &quot;log10&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;log10: DOMAIN error\n&quot;, 20);
              }
          errno = EDOM;
        }
        break;
        case 20:
        /* pow(0.0,0.0) */
        /* error only if _LIB_VERSION == _SVID_ */
        exc.type = DOMAIN;
        exc.name = &quot;pow&quot;;
        exc.retval = zero;
        if (_LIB_VERSION != _SVID_) exc.retval = 1.0;
        else if (!matherr(&amp;exc)) {
            (void) WRITE2(&quot;pow(0,0): DOMAIN error\n&quot;, 23);
            errno = EDOM;
        }
        break;
        case 21:
        /* pow(x,y) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;pow&quot;;
        if (_LIB_VERSION == _SVID_) {
          exc.retval = HUGE;
          y *= 0.5;
          if(x&lt;zero&amp;&amp;rint(y)!=y) exc.retval = -HUGE;
        } else {
          exc.retval = HUGE_VAL;
          y *= 0.5;
          if(x&lt;zero&amp;&amp;rint(y)!=y) exc.retval = -HUGE_VAL;
        }
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 22:
        /* pow(x,y) underflow */
        exc.type = UNDERFLOW;
        exc.name = &quot;pow&quot;;
        exc.retval =  zero;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 23:
        /* 0**neg */
        exc.type = DOMAIN;
        exc.name = &quot;pow&quot;;
        if (_LIB_VERSION == _SVID_) 
          exc.retval = zero;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;pow(0,neg): DOMAIN error\n&quot;, 25);
              }
          errno = EDOM;
        }
        break;
        case 24:
        /* neg**non-integral */
        exc.type = DOMAIN;
        exc.name = &quot;pow&quot;;
        if (_LIB_VERSION == _SVID_) 
            exc.retval = zero;
        else 
            exc.retval = zero/zero; /* X/Open allow NaN */
        if (_LIB_VERSION == _POSIX_) 
           errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;neg**non-integral: DOMAIN error\n&quot;, 32);
              }
          errno = EDOM;
        }
        break;
        case 25:
        /* sinh(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;sinh&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = ( (x&gt;zero) ? HUGE : -HUGE);
        else
          exc.retval = ( (x&gt;zero) ? HUGE_VAL : -HUGE_VAL);
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 26:
        /* sqrt(x&lt;0) */
        exc.type = DOMAIN;
        exc.name = &quot;sqrt&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = zero;
        else
          exc.retval = zero/zero;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;sqrt: DOMAIN error\n&quot;, 19);
              }
          errno = EDOM;
        }
        break;
            case 27:
                /* fmod(x,0) */
                exc.type = DOMAIN;
                exc.name = &quot;fmod&quot;;
                if (_LIB_VERSION == _SVID_)
                    exc.retval = x;
        else
            exc.retval = zero/zero;
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;fmod:  DOMAIN error\n&quot;, 20);
                  }
                  errno = EDOM;
                }
                break;
            case 28:
                /* remainder(x,0) */
                exc.type = DOMAIN;
                exc.name = &quot;remainder&quot;;
                exc.retval = zero/zero;
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;remainder: DOMAIN error\n&quot;, 24);
                  }
                  errno = EDOM;
                }
                break;
            case 29:
                /* acosh(x&lt;1) */
                exc.type = DOMAIN;
                exc.name = &quot;acosh&quot;;
                exc.retval = zero/zero;
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;acosh: DOMAIN error\n&quot;, 20);
                  }
                  errno = EDOM;
                }
                break;
            case 30:
                /* atanh(|x|&gt;1) */
                exc.type = DOMAIN;
                exc.name = &quot;atanh&quot;;
                exc.retval = zero/zero;
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;atanh: DOMAIN error\n&quot;, 20);
                  }
                  errno = EDOM;
                }
                break;
            case 31:
                /* atanh(|x|=1) */
                exc.type = SING;
                exc.name = &quot;atanh&quot;;
        exc.retval = x/zero;    /* sign(x)*inf */
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;atanh: SING error\n&quot;, 18);
                  }
                  errno = EDOM;
                }
                break;
        case 32:
        /* scalb overflow; SVID also returns +-HUGE_VAL */
        exc.type = OVERFLOW;
        exc.name = &quot;scalb&quot;;
        exc.retval = x &gt; zero ? HUGE_VAL : -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 33:
        /* scalb underflow */
        exc.type = UNDERFLOW;
        exc.name = &quot;scalb&quot;;
        exc.retval = copysign(zero,x);
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 34:
        /* j0(|x|&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;j0&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 35:
        /* y0(x&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;y0&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 36:
        /* j1(|x|&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;j1&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 37:
        /* y1(x&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;y1&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 38:
        /* jn(|x|&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;jn&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 39:
        /* yn(x&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;yn&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 40:
        /* gamma(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;gamma&quot;;
                if (_LIB_VERSION == _SVID_)
                  exc.retval = HUGE;
                else
                  exc.retval = HUGE_VAL;
                if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                  errno = ERANGE;
                }
        break;
        case 41:
        /* gamma(-integer) or gamma(0) */
        exc.type = SING;
        exc.name = &quot;gamma&quot;;
                if (_LIB_VERSION == _SVID_)
                  exc.retval = HUGE;
                else
                  exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;gamma: SING error\n&quot;, 18);
              }
          errno = EDOM;
        }
        break;
        case 42:
        /* pow(NaN,0.0) */
        /* error only if _LIB_VERSION == _SVID_ &amp; _XOPEN_ */
        exc.type = DOMAIN;
        exc.name = &quot;pow&quot;;
        exc.retval = x;
        if (_LIB_VERSION == _IEEE_ ||
            _LIB_VERSION == _POSIX_) exc.retval = 1.0;
        else if (!matherr(&amp;exc)) {
            errno = EDOM;
        }
        break;
    }
    return exc.retval;


}
#endif /* _No_Floating_Point  */
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>